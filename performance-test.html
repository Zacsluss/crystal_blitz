<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crystal Blitz - Performance Benchmarks</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      background: #0b0d10;
      color: #e3e7ef;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      color: #5af2c7;
      border-bottom: 2px solid #5af2c7;
      padding-bottom: 10px;
    }
    .benchmark {
      margin: 15px 0;
      padding: 15px;
      background: #12161d;
      border-left: 4px solid #5af2c7;
      border-radius: 4px;
    }
    .benchmark.warning {
      border-left-color: #ffd166;
    }
    .benchmark.fail {
      border-left-color: #ff5b6e;
    }
    .metric {
      font-size: 24px;
      font-weight: bold;
      color: #5af2c7;
      margin: 10px 0;
    }
    .threshold {
      font-size: 14px;
      color: #99a2b2;
      margin-left: 20px;
    }
    #summary {
      margin-top: 30px;
      padding: 20px;
      background: #1a1f29;
      border-radius: 8px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <h1>‚ö° Crystal Blitz - Performance Benchmarks</h1>
  <p>Automated performance regression tests to ensure 60 FPS target</p>

  <div id="benchmarks"></div>
  <div id="summary"></div>

  <script>
    'use strict';

    const benchmarkContainer = document.getElementById('benchmarks');
    const summaryContainer = document.getElementById('summary');
    const results = [];

    /**
     * Performance benchmark helper
     */
    function benchmark(name, actualValue, threshold, unit, higherIsBetter = true) {
      const passed = higherIsBetter ? actualValue >= threshold : actualValue <= threshold;
      const status = passed ? 'pass' : 'fail';

      results.push({ name, passed, actualValue, threshold });

      const benchmarkDiv = document.createElement('div');
      benchmarkDiv.className = `benchmark ${status}`;
      benchmarkDiv.innerHTML = `
        <div><strong>${passed ? '‚úÖ' : '‚ùå'} ${name}</strong></div>
        <div class="metric">${actualValue.toFixed(2)} ${unit}</div>
        <div class="threshold">Threshold: ${higherIsBetter ? '‚â•' : '‚â§'} ${threshold} ${unit}</div>
      `;
      benchmarkContainer.appendChild(benchmarkDiv);

      return passed;
    }

    /**
     * Test 1: Spatial Grid Query Performance
     * Target: <5ms for 200 entities (CI-friendly threshold)
     */
    function testSpatialGridPerformance() {
      // Simulate spatial grid
      const grid = new Map();
      const cellSize = 50;
      const entities = [];

      // Create 200 test entities
      for (let i = 0; i < 200; i++) {
        entities.push({
          x: Math.random() * 1000,
          y: Math.random() * 1000,
          r: 10
        });
      }

      // Insert into grid
      for (const entity of entities) {
        const cellX = Math.floor(entity.x / cellSize);
        const cellY = Math.floor(entity.y / cellSize);
        const key = `${cellX},${cellY}`;
        if (!grid.has(key)) grid.set(key, []);
        grid.get(key).push(entity);
      }

      // Benchmark neighbor queries
      const iterations = 1000;
      const start = performance.now();

      for (let i = 0; i < iterations; i++) {
        const queryX = 10;
        const queryY = 10;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const key = `${queryX + dx},${queryY + dy}`;
            if (grid.has(key)) {
              neighbors.push(...grid.get(key));
            }
          }
        }
      }

      const end = performance.now();
      const avgTime = (end - start) / iterations;

      benchmark('Spatial Grid Query', avgTime, 5.0, 'ms', false);
      return avgTime;
    }

    /**
     * Test 2: Object Pooling - Zero Allocations
     * Target: 0 new objects created (reuse existing)
     */
    function testObjectPooling() {
      const pool = [];
      const poolSize = 100;

      // Pre-allocate pool
      for (let i = 0; i < poolSize; i++) {
        pool.push({ x: 0, y: 0, alive: false });
      }

      // Simulate entity spawning/recycling
      const iterations = 10000;
      let allocations = 0;
      const start = performance.now();

      for (let i = 0; i < iterations; i++) {
        // Try to reuse from pool
        let entity = null;
        for (let j = 0; j < pool.length; j++) {
          if (!pool[j].alive) {
            entity = pool[j];
            break;
          }
        }

        // If no free entity, allocate new one (bad!)
        if (!entity) {
          entity = { x: 0, y: 0, alive: false };
          allocations++;
        }

        // Use entity
        entity.x = Math.random() * 1000;
        entity.y = Math.random() * 1000;
        entity.alive = true;

        // Recycle random entity
        const randomIndex = Math.floor(Math.random() * pool.length);
        pool[randomIndex].alive = false;
      }

      const end = performance.now();
      const totalTime = end - start;

      benchmark('Object Pool Allocations', allocations, 0, 'objects', false);
      return allocations === 0;
    }

    /**
     * Test 3: Math Operation Performance
     * Target: >10,000 ops/ms (CI-friendly threshold)
     */
    function testMathPerformance() {
      const iterations = 1000000;
      let result = 0;
      const start = performance.now();

      for (let i = 0; i < iterations; i++) {
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        result += Math.sqrt(x * x + y * y);
      }

      const end = performance.now();
      const totalTime = end - start;
      const opsPerMs = iterations / totalTime;

      benchmark('Math Operations', opsPerMs, 10000, 'ops/ms', true);
      return opsPerMs;
    }

    /**
     * Test 4: Canvas Drawing Performance
     * Target: >1,000 circles/second (CI-friendly threshold)
     */
    function testCanvasPerformance() {
      const canvas = document.createElement('canvas');
      canvas.width = 800;
      canvas.height = 600;
      const ctx = canvas.getContext('2d');

      const iterations = 1000;
      const start = performance.now();

      for (let i = 0; i < iterations; i++) {
        ctx.beginPath();
        ctx.arc(
          Math.random() * canvas.width,
          Math.random() * canvas.height,
          10,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = '#5af2c7';
        ctx.fill();
      }

      const end = performance.now();
      const totalTime = end - start;
      const circlesPerSecond = (iterations / totalTime) * 1000;

      benchmark('Canvas Draw Rate', circlesPerSecond, 1000, 'circles/sec', true);
      return circlesPerSecond;
    }

    /**
     * Test 5: Memory Allocation Efficiency
     * Target: <100MB for typical gameplay
     */
    function testMemoryUsage() {
      if (performance.memory) {
        const usedMemoryMB = performance.memory.usedJSHeapSize / (1024 * 1024);
        benchmark('Memory Usage', usedMemoryMB, 100, 'MB', false);
        return usedMemoryMB;
      } else {
        const benchmarkDiv = document.createElement('div');
        benchmarkDiv.className = 'benchmark warning';
        benchmarkDiv.innerHTML = `
          <div><strong>‚ö†Ô∏è Memory Usage</strong></div>
          <div class="metric">N/A</div>
          <div class="threshold">performance.memory not available (Chrome required)</div>
        `;
        benchmarkContainer.appendChild(benchmarkDiv);
        return null;
      }
    }

    /**
     * Run all performance tests
     */
    function runAllBenchmarks() {
      testSpatialGridPerformance();
      testObjectPooling();
      testMathPerformance();
      testCanvasPerformance();
      testMemoryUsage();

      // Generate summary
      const passed = results.filter(r => r.passed).length;
      const failed = results.filter(r => !r.passed).length;
      const total = results.length;

      summaryContainer.innerHTML = `
        <h2>Summary</h2>
        <p><span style="color: #28a745;">‚úÖ ${passed} passed</span> |
           <span style="color: #ff5b6e;">‚ùå ${failed} failed</span> |
           <strong>${total} total</strong></p>
        ${failed === 0 ?
          '<p style="color: #28a745;">üéâ All performance benchmarks passed! Game maintains 60 FPS target.</p>' :
          '<p style="color: #ffd166;">‚ö†Ô∏è Some benchmarks failed. Performance regression detected.</p>'
        }
        <p style="margin-top: 20px; font-size: 14px; color: #99a2b2;">
          These benchmarks ensure Crystal Blitz maintains 60 FPS with 200+ entities on screen.
        </p>
      `;

      // Exit with error code if tests failed (for CI)
      if (failed > 0 && typeof process !== 'undefined' && process.exit) {
        process.exit(1);
      }
    }

    // Run benchmarks on load
    window.addEventListener('load', () => {
      setTimeout(runAllBenchmarks, 100);
    });
  </script>
</body>
</html>
