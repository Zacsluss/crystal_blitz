<!doctype html>
<!-- Crystal Blitz v0.99 - Arena Shooter -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="screen-orientation" content="landscape">
  <meta name="version" content="0.99">
  <meta name="description" content="Crystal Blitz - High-performance arena shooter in a single HTML file">
  <title>CRYSTAL BLITZ</title>
  <style>
    :root {
      --bg: #0a0c0f;
      --fg: #f0f3f7;
      --muted: #9ba5b8;
      --accent: #4ee9c4;
      --accent-soft: #6ff2d1;
      --danger: #ff5b6e;
      --warning: #ffc857;
      --panel: #0e1218;
      --panel2: #0b0f15;
      --shadow: rgba(0,0,0,0.45);
      --shadow-elevated: rgba(0,0,0,0.6);
      --glass-border: rgba(255, 255, 255, 0.1);
      --glass-highlight: rgba(255, 255, 255, 0.05);
      --health-gradient: linear-gradient(135deg, #ff6b6b 0%, #ff8787 50%, #ffa5a5 100%);
      --stamina-gradient: linear-gradient(135deg, #ffc857 0%, #ffd97d 50%, #ffeb99 100%);
      --glass-noise: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iMzAwIj48ZmlsdGVyIGlkPSJhIj48ZmVUdXJidWxlbmNlIGJhc2VGcmVxdWVuY3k9Ii43NSIgc3RpdGNoVGlsZXM9InN0aXRjaCIgdHlwZT0iZnJhY3RhbE5vaXNlIi8+PGZlQ29sb3JNYXRyaXggdHlwZT0ic2F0dXJhdGUiIHZhbHVlcz0iMCIvPjwvZmlsdGVyPjxwYXRoIGQ9Ik0wIDBoMzAwdjMwMEgweiIgZmlsdGVyPSJ1cmwoI2EpIiBvcGFjaXR5PSIuMDUiLz48L3N2Zz4=');
    }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Noto Sans", "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    #hud {
      position: fixed;
      top: 20px;
      left: 20px;
      background: linear-gradient(135deg, rgba(14, 18, 24, 0.05), rgba(11, 15, 21, 0.0375)), var(--glass-noise);
      padding: 16px 19px;
      border-radius: 12px;
      box-shadow:
        0 8px 32px var(--shadow-elevated),
        inset 0 1px 0 var(--glass-highlight),
        inset 0 -1px 0 rgba(0, 0, 0, 0.2);
      border: 1px solid var(--glass-border);
      font-size: 19px;
      user-select: none;
      pointer-events: none;
      min-width: 295px;
      backdrop-filter: blur(10px) saturate(140%);
      -webkit-backdrop-filter: blur(10px) saturate(140%);
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transition: none;
      letter-spacing: -0.01em;
    }
    #hud .row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
      white-space: nowrap;
    }
    #hud .bar {
      --w: 214px;
      position: relative;
      width: var(--w);
      height: 12px;
      background: linear-gradient(180deg, rgba(10, 14, 20, 0.8), rgba(15, 19, 25, 0.6));
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow:
        inset 0 2px 4px rgba(0,0,0,0.6),
        inset 0 -1px 2px rgba(255, 255, 255, 0.02);
    }
    #hud .bar > i {
      display: block;
      height: 100%;
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        inset 0 -1px 0 rgba(0,0,0,0.2),
        0 0 12px rgba(78, 233, 196, 0.3);
      transition: none;
      position: relative;
      border-radius: 999px;
    }
    #hud .bar.healing > i::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, 
        rgba(255,255,255,0) 0%, 
        rgba(255,255,255,0.4) 45%, 
        rgba(255,255,255,0.6) 50%, 
        rgba(255,255,255,0.4) 55%, 
        rgba(255,255,255,0) 100%);
      animation: shimmer 1.5s infinite;
      opacity: 0.8;
    }
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(200%); }
    }
    #hud .bar.health > i { 
      background: var(--health-gradient); 
      box-shadow: 0 0 20px rgba(255, 107, 107, 1), 0 0 40px rgba(255, 107, 107, 0.6), inset 0 0 10px rgba(0,0,0,0.3);
      filter: brightness(1.1);
    }
    #hud .bar.health.taking-damage > i {
      background: linear-gradient(90deg, #ff3333, #ff6666) !important;
      box-shadow: 0 0 30px rgba(255, 0, 0, 1), 0 0 60px rgba(255, 0, 0, 0.8), inset 0 0 15px rgba(255,255,255,0.3) !important;
      filter: brightness(1.4) saturate(1.5);
      animation: damageFlash 0.3s ease-out;
    }
    @keyframes damageFlash {
      0% { 
        filter: brightness(2) saturate(2);
      }
      50% {
        filter: brightness(1.7) saturate(1.7);
      }
      100% { 
        filter: brightness(1.4) saturate(1.5);
      }
    }
    #hud .bar.health.low > i {
      animation: pulseLow 1s ease-in-out infinite;
    }
    @keyframes pulseLow {
      0%, 100% { 
        box-shadow: 0 0 20px rgba(255, 107, 107, 1), 0 0 40px rgba(255, 0, 0, 0.6), inset 0 0 10px rgba(0,0,0,0.3);
        filter: brightness(1.1);
      }
      50% { 
        box-shadow: 0 0 40px rgba(255, 107, 107, 1), 0 0 80px rgba(255, 0, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.2);
        filter: brightness(1.5);
      }
    }
    #hud .bar.stamina > i { 
      background: var(--stamina-gradient); 
      box-shadow: 0 0 20px rgba(255, 209, 102, 1), 0 0 40px rgba(255, 209, 102, 0.6), inset 0 0 10px rgba(0,0,0,0.3);
      filter: brightness(1.1);
    }
    #hud .bar.stamina.using-stamina > i {
      background: linear-gradient(90deg, #ff9933, #ffcc66) !important;
      box-shadow: 0 0 30px rgba(255, 153, 0, 1), 0 0 60px rgba(255, 200, 0, 0.8), inset 0 0 15px rgba(255,255,255,0.3) !important;
      filter: brightness(1.3) saturate(1.4);
      animation: staminaDrain 0.2s ease-out;
    }
    @keyframes staminaDrain {
      0% { 
        filter: brightness(1.8) saturate(1.8);
      }
      100% { 
        filter: brightness(1.3) saturate(1.4);
      }
    }
    #hud .bar.stamina.low > i {
      animation: pulseStaminaLow 0.8s ease-in-out infinite;
    }
    @keyframes pulseStaminaLow {
      0%, 100% { 
        box-shadow: 0 0 20px rgba(255, 209, 102, 1), 0 0 40px rgba(255, 200, 0, 0.6), inset 0 0 10px rgba(0,0,0,0.3);
        filter: brightness(1.1);
      }
      50% { 
        box-shadow: 0 0 40px rgba(255, 209, 102, 1), 0 0 80px rgba(255, 200, 0, 0.8), inset 0 0 20px rgba(255,255,255,0.2);
        filter: brightness(1.6);
      }
    }
    #hud .bar.heat > i { 
      background: linear-gradient(90deg, #ff9933, #ff6600);
      box-shadow: 0 0 15px rgba(255, 153, 51, 0.8), inset 0 0 8px rgba(0,0,0,0.3);
      filter: brightness(1.1);
      transition: all 0.15s ease;
    }
    #hud .bar.heat.warning > i {
      background: linear-gradient(90deg, #ff6600, #ff4400) !important;
      box-shadow: 0 0 25px rgba(255, 102, 0, 1), 0 0 50px rgba(255, 102, 0, 0.6), inset 0 0 12px rgba(0,0,0,0.3) !important;
      filter: brightness(1.2);
      animation: heatWarning 0.8s ease-in-out infinite;
    }
    @keyframes heatWarning {
      0%, 100% { filter: brightness(1.2); }
      50% { filter: brightness(1.5); }
    }
    #hud .bar.heat.danger > i {
      background: linear-gradient(90deg, #ff3300, #ff0000) !important;
      box-shadow: 0 0 35px rgba(255, 0, 0, 1), 0 0 70px rgba(255, 0, 0, 0.8), inset 0 0 15px rgba(255,255,255,0.2) !important;
      filter: brightness(1.4) saturate(1.5);
      animation: heatDanger 0.4s ease-in-out infinite;
    }
    @keyframes heatDanger {
      0%, 100% { 
        filter: brightness(1.4) saturate(1.5);
        transform: scaleY(1);
      }
      50% { 
        filter: brightness(1.8) saturate(2);
        transform: scaleY(1.05);
      }
    }
    #hud .bar.heat.overheated > i {
      background: linear-gradient(90deg, #ffffff, #ff0000, #ffffff) !important;
      box-shadow: 0 0 50px rgba(255, 0, 0, 1), 0 0 100px rgba(255, 0, 0, 1), inset 0 0 20px rgba(255,255,255,0.5) !important;
      filter: brightness(2) saturate(0.5);
      animation: overheatPulse 0.3s ease-in-out infinite;
    }
    @keyframes overheatPulse {
      0%, 100% { 
        filter: brightness(2) saturate(0.5);
        background-position: 0% 50%;
      }
      50% { 
        filter: brightness(2.5) saturate(0.3);
        background-position: 100% 50%;
      }
    }
    #hud .muted { color: var(--muted); }
    #help {
      position: fixed;
      right: 12px;
      top: 12px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      padding: 10px 12px;
      border-radius: 10px;
      box-shadow: 0 6px 14px var(--shadow);
      user-select: none;
      font-size: 14px;
      max-width: 360px;
    }
    #help kbd {
      background: #1a1f29;
      border: 1px solid #293140;
      border-bottom-width: 2px;
      padding: 2px 6px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
    }
    #optionsPanel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent 0%,
        transparent 30%,
        rgba(90, 242, 199, 0.4) 50%,
        transparent 70%,
        transparent 100%
      );
      opacity: 0;
      animation: topShimmer 6s infinite;
    }
    #optionsPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background:
        radial-gradient(1200px 700px at 40% 35%, rgba(78,233,196,0.06), transparent),
        linear-gradient(135deg, rgba(14, 18, 24, 0.35), rgba(11, 15, 21, 0.25)),
        var(--glass-noise);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      border: 1px solid var(--glass-border);
      padding: 28px 36px;
      border-radius: 24px;
      box-shadow:
        0 16px 64px var(--shadow-elevated),
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 var(--glass-highlight),
        inset 0 -1px 0 rgba(0, 0, 0, 0.15);
      z-index: 1000;
      /* Match banner sizing for consistency */
      width: min(90vw, 750px);
      height: min(90vh, 650px);
      overflow-y: auto;
      overflow-x: hidden;
      opacity: 0;
      animation: optionsFadeIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
                 glassUnderglow 8s ease-in-out infinite;
    }
    #optionsPanel .tab-container {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
      border-bottom: 1px solid rgba(90, 242, 199, 0.15);
      padding-bottom: 12px;
      opacity: 0;
      transform: translateY(-20px);
      animation: titleSlideIn 0.6s ease-out 0.3s forwards;
    }
    #optionsPanel .tab-button {
      background: linear-gradient(135deg, rgba(78, 233, 196, 0.1), rgba(78, 233, 196, 0.05)), var(--glass-noise);
      border: 1px solid rgba(78, 233, 196, 0.2);
      color: var(--muted);
      padding: 12px 24px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.01em;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      border-radius: 14px;
      box-shadow:
        0 4px 12px rgba(0, 0, 0, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      /* Staggered fade-in animations */
      opacity: 0;
      transform: translateY(10px) scale(0.95);
    }
    /* Staggered animations for options menu tab buttons */
    #optionsPanel .tab-button:nth-child(1) {
      animation: menuTabFadeIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) 0.4s forwards;
    }
    #optionsPanel .tab-button:nth-child(2) {
      animation: menuTabFadeIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) 0.5s forwards;
    }
    #optionsPanel .tab-button:nth-child(3) {
      animation: menuTabFadeIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) 0.6s forwards;
    }
    #optionsPanel .tab-button:hover {
      color: var(--fg);
      background: linear-gradient(135deg, rgba(78, 233, 196, 0.18), rgba(78, 233, 196, 0.12)), var(--glass-noise);
      border-color: rgba(78, 233, 196, 0.35);
      transform: translateY(-2px) scale(1.03);
      box-shadow:
        0 8px 20px rgba(78, 233, 196, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }
    #optionsPanel .tab-button.active {
      color: #001a14;
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      border-color: var(--accent);
      box-shadow:
        0 8px 24px rgba(78, 233, 196, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
    }
    #optionsPanel .tab-button.active:hover {
      filter: brightness(1.1);
    }
    #optionsPanel .tab-content {
      display: none;
    }
    #optionsPanel .tab-content.active {
      display: block;
      opacity: 0;
      transform: translateY(20px);
      animation: contentFadeIn 0.5s ease-out 0.5s forwards;
    }
    /* Override controls-panel opacity for options menu */
    #optionsPanel .controls-panel {
      opacity: 1 !important;
      transform: translateY(0) !important;
      animation: none !important;
      background: radial-gradient(ellipse at top, rgba(90, 242, 199, 0.03), transparent),
                  linear-gradient(135deg, rgba(26, 31, 41, 0.6), rgba(18, 22, 29, 0.5));
      border: 1px solid rgba(90, 242, 199, 0.15);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2),
                  inset 0 1px 0 rgba(255, 255, 255, 0.03);
    }
    @keyframes contentFadeIn {
      from { 
        opacity: 0; 
        transform: translateY(20px);
        filter: blur(4px);
      }
      to { 
        opacity: 1; 
        transform: translateY(0);
        filter: blur(0);
      }
    }
    @keyframes optionsFadeIn {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.8) rotate(-1deg); 
        filter: blur(8px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1) rotate(0deg); 
        filter: blur(0px); 
      }
    }
    @keyframes optionsFadeOut {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1) rotate(0deg); 
        filter: blur(0px); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.9) rotate(1deg); 
        filter: blur(4px); 
      }
    }
    #optionsPanel button#optionsBackBtn {
      margin-top: 24px;
      width: 100%;
      background: linear-gradient(135deg, rgba(90, 242, 199, 0.1), rgba(90, 242, 199, 0.05));
      color: var(--accent);
      border: 1px solid rgba(90, 242, 199, 0.3);
      padding: 12px 20px;
      border-radius: 10px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2),
                  inset 0 1px 0 rgba(255, 255, 255, 0.05);
      opacity: 0;
      transform: translateY(20px) scale(0.9);
      animation: buttonSlideIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.7s forwards;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      backdrop-filter: blur(8px);
    }
    #optionsPanel button#optionsBackBtn:hover {
      background: linear-gradient(135deg, rgba(90, 242, 199, 0.2), rgba(90, 242, 199, 0.1));
      border-color: var(--accent);
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 10px 30px rgba(90, 242, 199, 0.3),
                  inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    #optionsPanel button#optionsBackBtn:active {
      transform: translateY(0) scale(0.98);
    }
    
    /* Custom scrollbar styling for Options panel */
    #optionsPanel::-webkit-scrollbar {
      width: 12px;
    }
    #optionsPanel::-webkit-scrollbar-track {
      background: rgba(18, 22, 29, 0.6);
      border-radius: 6px;
      border: 1px solid rgba(90, 242, 199, 0.1);
    }
    #optionsPanel::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.3), rgba(90, 242, 199, 0.15));
      border-radius: 6px;
      border: 1px solid rgba(90, 242, 199, 0.2);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    #optionsPanel::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.4), rgba(90, 242, 199, 0.25));
      border-color: rgba(90, 242, 199, 0.3);
    }
    #optionsPanel::-webkit-scrollbar-thumb:active {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.5), rgba(90, 242, 199, 0.35));
    }
    
    /* Firefox scrollbar */
    #optionsPanel {
      scrollbar-width: thin;
      scrollbar-color: rgba(90, 242, 199, 0.3) rgba(18, 22, 29, 0.6);
    }
    
    /* Also style banner scrollbar for pause menu */
    #banner::-webkit-scrollbar {
      width: 12px;
    }
    #banner::-webkit-scrollbar-track {
      background: rgba(18, 22, 29, 0.6);
      border-radius: 6px;
      border: 1px solid rgba(90, 242, 199, 0.1);
    }
    #banner::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.3), rgba(90, 242, 199, 0.15));
      border-radius: 6px;
      border: 1px solid rgba(90, 242, 199, 0.2);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    #banner::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.4), rgba(90, 242, 199, 0.25));
      border-color: rgba(90, 242, 199, 0.3);
    }
    #banner::-webkit-scrollbar-thumb:active {
      background: linear-gradient(180deg, rgba(90, 242, 199, 0.5), rgba(90, 242, 199, 0.35));
    }
    #banner {
      scrollbar-width: thin;
      scrollbar-color: rgba(90, 242, 199, 0.3) rgba(18, 22, 29, 0.6);
    }
    /* Crystal and Enemy Legend Styling */
    #optionsPanel .crystal-legend,
    #optionsPanel .enemy-legend {
      padding: 20px !important;
      background: radial-gradient(ellipse at center, rgba(90, 242, 199, 0.02), transparent);
    }
    #optionsPanel .crystal-category,
    #optionsPanel .enemy-category {
      margin-bottom: 16px !important;
      padding: 12px;
      background: linear-gradient(135deg, rgba(18, 22, 29, 0.4), rgba(15, 19, 25, 0.3));
      border-radius: 8px;
      border: 1px solid rgba(90, 242, 199, 0.1);
      opacity: 0;
      transform: translateY(8px);
    }
    /* Staggered fade-in for section headers in options menu */
    #optionsPanel .tab-content.active .enemy-category,
    #optionsPanel .tab-content.active .crystal-category {
      animation: menuSectionFadeIn 0.4s ease-out forwards;
    }
    #optionsPanel .tab-content.active .enemy-category:nth-child(2),
    #optionsPanel .tab-content.active .crystal-category:nth-child(2) {
      animation-delay: 0.6s;
    }
    #optionsPanel .tab-content.active .enemy-category:nth-child(3),
    #optionsPanel .tab-content.active .crystal-category:nth-child(3) {
      animation-delay: 0.65s;
    }
    #optionsPanel .tab-content.active .enemy-category:nth-child(4),
    #optionsPanel .tab-content.active .crystal-category:nth-child(4) {
      animation-delay: 0.7s;
    }
    #optionsPanel .tab-content.active .enemy-category:nth-child(5),
    #optionsPanel .tab-content.active .crystal-category:nth-child(5) {
      animation-delay: 0.75s;
    }
    #optionsPanel .crystal-category h4,
    #optionsPanel .enemy-category h4 {
      margin: 0 0 12px 0 !important;
      font-size: 14px !important;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    #optionsPanel .crystal-item,
    #optionsPanel .enemy-item {
      padding: 6px 8px;
      margin: 6px 0 !important;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 6px;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }
    #optionsPanel .crystal-item:hover,
    #optionsPanel .enemy-item:hover {
      background: rgba(90, 242, 199, 0.05);
      border-color: rgba(90, 242, 199, 0.2);
      transform: translateX(4px);
    }
    .crystal-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
    }
    .crystal-color {
      width: 16px;
      height: 16px;
      border-radius: 2px;
      border: 1px solid rgba(255,255,255,0.3);
      flex-shrink: 0;
    }
    .crystal-name {
      color: var(--fg);
      font-weight: 500;
      min-width: 80px;
    }
    .crystal-desc {
      color: var(--muted);
      font-size: 12px;
      flex-grow: 1;
    }
    #banner::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent 0%,
        transparent 30%,
        rgba(90, 242, 199, 0.4) 50%,
        transparent 70%,
        transparent 100%
      );
      opacity: 0;
      animation: topShimmer 6s infinite;
    }
    
    /* Unified responsive menu system */
    #banner {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background:
        radial-gradient(1200px 700px at 40% 35%, rgba(78,233,196,0.06), transparent),
        linear-gradient(135deg, rgba(14, 18, 24, 0.35), rgba(11, 15, 21, 0.25)),
        var(--glass-noise);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      border: 1px solid var(--glass-border);
      padding: 24px 28px;
      border-radius: 24px;
      box-shadow:
        0 16px 64px var(--shadow-elevated),
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 var(--glass-highlight),
        inset 0 -1px 0 rgba(0, 0, 0, 0.15);
      text-align: center;
      /* Responsive sizing - all menus same size */
      width: min(90vw, 750px);
      height: min(90vh, 650px);
      line-height: 1.5;
      opacity: 0;
      overflow-y: auto;
      overflow-x: hidden;
      animation: menuFadeIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
                 glassUnderglow 8s ease-in-out infinite;
    }
    #banner h1 {
      margin: 0 0 10px 0; 
      letter-spacing: 0.3px;
      opacity: 0;
      transform: translateY(-20px);
      animation: titleSlideIn 0.6s ease-out 0.3s forwards;
      white-space: nowrap;
      overflow: visible;
    }
    #banner .sub { 
      color: var(--muted); 
      margin-bottom: 16px;
      opacity: 0;
      transform: translateY(-15px);
      animation: subtitleSlideIn 0.5s ease-out 0.5s forwards;
    }
    #banner button {
      display: block;
      width: 100%;
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      color: #001a14;
      border: none;
      padding: 12px 32px;
      border-radius: 16px;
      font-weight: 600;
      font-size: 16px;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow:
        0 8px 24px rgba(78, 233, 196, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
      opacity: 0;
      transform: translateY(20px) scale(0.9);
      animation: buttonSlideIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.7s forwards;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      position: relative;
      overflow: hidden;
    }
    #banner button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }
    #banner button:hover::before {
      left: 100%;
    }
    #banner button:hover {
      filter: brightness(1.1);
      transform: translateY(-3px) scale(1.03);
      box-shadow:
        0 12px 36px rgba(78, 233, 196, 0.4),
        0 6px 18px rgba(78, 233, 196, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.4),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
    }
    #banner button:active {
      transform: translateY(-1px) scale(0.98);
    }
    #banner button + button {
      margin-top: 12px;
      background: linear-gradient(135deg, rgba(78, 233, 196, 0.12), rgba(78, 233, 196, 0.06)), var(--glass-noise);
      color: var(--accent);
      border: 1px solid rgba(78, 233, 196, 0.25);
      box-shadow:
        0 6px 20px rgba(0, 0, 0, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.08),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(8px);
      /* Staggered animation for Options button */
      animation-delay: 0.85s;
    }
    #banner button + button:hover {
      background: linear-gradient(135deg, rgba(78, 233, 196, 0.2), rgba(78, 233, 196, 0.12)), var(--glass-noise);
      border-color: var(--accent);
      filter: none;
      transform: translateY(-3px) scale(1.03);
      box-shadow:
        0 10px 28px rgba(78, 233, 196, 0.25),
        0 6px 14px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.12);
    }
    /* Pause menu action button animations */
    #banner button#startBtn {
      opacity: 0;
      transform: translateY(15px) scale(0.9);
      animation: menuButtonFadeIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.6s forwards;
    }
    #banner button#mainMenuBtn {
      opacity: 0;
      transform: translateY(15px) scale(0.9);
      animation: menuButtonFadeIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.7s forwards;
    }
    .controls-panel {
      margin: 16px 0;
      padding: 16px 20px;
      background: linear-gradient(135deg, rgba(14, 18, 24, 0.5), rgba(11, 15, 21, 0.4)), var(--glass-noise);
      border-radius: 16px;
      border: 1px solid rgba(78, 233, 196, 0.15);
      font-size: 14px;
      box-shadow:
        0 6px 20px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(12px);
      opacity: 0;
      transform: translateY(30px);
      animation: controlsSlideIn 0.6s ease-out 0.9s forwards;
    }
    .controls-panel .controls-title {
      margin-bottom: 12px;
      color: var(--accent);
      font-size: 16px;
      text-align: center;
    }
    .controls-panel .control-row {
      display: flex;
      align-items: center;
      margin: 8px 0;
      padding: 6px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .controls-panel .control-row:last-child {
      border-bottom: none;
    }
    .controls-panel .control-keys {
      display: inline-flex;
      gap: 4px;
      min-width: 120px;
    }
    .controls-panel .control-desc {
      color: var(--fg);
      font-weight: 500;
    }
    .controls-panel kbd {
      background: linear-gradient(135deg, #2a3441, #1f2733);
      border: 1px solid rgba(90, 242, 199, 0.3);
      border-bottom: 2px solid rgba(90, 242, 199, 0.4);
      padding: 4px 8px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      font-weight: 600;
      color: var(--accent);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    .controls-panel .mobile-note {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 12px;
      text-align: center;
      color: var(--muted);
    }
    /* Tab system for pause menu */
    .tab-container {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      justify-content: center;
    }
    .tab-button {
      padding: 8px 16px;
      background: rgba(26, 31, 41, 0.7);
      border: 1px solid rgba(90, 242, 199, 0.3);
      border-radius: 6px;
      color: var(--muted);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
      line-height: 1;
      display: inline-block;
      vertical-align: middle;
      box-sizing: border-box;
      height: auto;
    }
    .tab-button.active {
      background: rgba(90, 242, 199, 0.2);
      color: var(--accent);
      border-color: var(--accent);
    }
    .tab-button:hover:not(.active) {
      background: rgba(90, 242, 199, 0.15);
      color: var(--fg);
    }

    /* CRITICAL FIX: Pause menu specific button styles with HIGHER SPECIFICITY */
    #banner .tab-button {
      background: rgba(0, 0, 0, 0.5) !important;
      color: var(--muted) !important;
      border: 1px solid var(--border) !important;
      transition: all 0.2s !important;
      padding: 8px 16px !important;
      margin: 0 !important;
      font-weight: 400 !important;
      font-style: normal !important;
      text-decoration: none !important;
      border-radius: 6px !important;
      box-shadow: none !important;
      box-sizing: border-box !important;
      font-size: 14px !important;
      line-height: 1 !important;
      height: 34px !important;
      min-height: 34px !important;
      max-height: 34px !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
      vertical-align: middle !important;
      /* Allow animations for staggered fade-ins */
      opacity: 0;
      transform: translateY(10px) scale(0.95);
    }
    /* Staggered fade-in animations for pause menu tab buttons */
    #banner .tab-button:nth-child(1) {
      animation: menuTabFadeIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s forwards !important;
    }
    #banner .tab-button:nth-child(2) {
      animation: menuTabFadeIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s forwards !important;
    }
    #banner .tab-button:nth-child(3) {
      animation: menuTabFadeIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) 0.4s forwards !important;
    }
    #banner .tab-button:nth-child(4) {
      animation: menuTabFadeIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) 0.5s forwards !important;
    }
    #banner .tab-button.active {
      background: rgba(90, 242, 199, 0.3) !important;
      color: var(--accent) !important;
      border-color: var(--accent) !important;
      box-shadow: 0 0 20px rgba(90, 242, 199, 0.4),
                  inset 0 0 10px rgba(90, 242, 199, 0.2) !important;
      height: 34px !important;
      min-height: 34px !important;
      max-height: 34px !important;
    }
    #banner .tab-button:hover:not(.active) {
      background: rgba(90, 242, 199, 0.15);
      color: var(--text);
      transform: translateY(-1px);
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    /* Enemy and Crystal legend styles */
    .enemy-legend,
    .crystal-legend {
      max-height: 400px;
      overflow-y: auto;
      padding-right: 8px;
    }
    .enemy-legend::-webkit-scrollbar,
    .crystal-legend::-webkit-scrollbar {
      width: 6px;
    }
    .enemy-legend::-webkit-scrollbar-track,
    .crystal-legend::-webkit-scrollbar-track {
      background: rgba(26, 31, 41, 0.5);
      border-radius: 3px;
    }
    .enemy-legend::-webkit-scrollbar-thumb,
    .crystal-legend::-webkit-scrollbar-thumb {
      background: rgba(90, 242, 199, 0.5);
      border-radius: 3px;
    }
    .enemy-category {
      margin-bottom: 16px;
      opacity: 0;
      transform: translateY(8px);
    }
    /* Staggered fade-in for section headers in pause menu */
    #banner .tab-content.active .enemy-category,
    #banner .tab-content.active .crystal-category {
      animation: menuSectionFadeIn 0.4s ease-out forwards;
    }
    #banner .tab-content.active .enemy-category:nth-child(2),
    #banner .tab-content.active .crystal-category:nth-child(2) {
      animation-delay: 0.1s;
    }
    #banner .tab-content.active .enemy-category:nth-child(3),
    #banner .tab-content.active .crystal-category:nth-child(3) {
      animation-delay: 0.15s;
    }
    #banner .tab-content.active .enemy-category:nth-child(4),
    #banner .tab-content.active .crystal-category:nth-child(4) {
      animation-delay: 0.2s;
    }
    #banner .tab-content.active .enemy-category:nth-child(5),
    #banner .tab-content.active .crystal-category:nth-child(5) {
      animation-delay: 0.25s;
    }
    .enemy-category h4 {
      color: var(--accent);
      margin: 0 0 8px 0;
      font-size: 14px;
      border-bottom: 1px solid rgba(90, 242, 199, 0.3);
      padding-bottom: 4px;
    }
    .enemy-entry {
      display: flex;
      align-items: center;
      margin: 6px 0;
      padding: 4px;
      background: rgba(18, 22, 29, 0.4);
      border-radius: 4px;
    }
    .enemy-icon {
      width: 30px;
      height: 30px;
      margin-right: 12px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      font-size: 16px;
    }
    .enemy-preview-canvas {
      margin-right: 12px;
      border-radius: 4px;
      background: #222;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
      width: 80px;
      height: 80px;
      flex-shrink: 0;
    }
    .enemy-info {
      flex: 1;
    }
    .enemy-name {
      font-weight: 600;
      color: var(--fg);
      font-size: 13px;
    }
    .enemy-desc {
      font-size: 11px;
      color: var(--muted);
      margin-top: 2px;
    }
    .stat-value {
      margin-left: 4px;
    }
    #gameOver::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, 
        transparent 0%,
        transparent 30%,
        rgba(255, 91, 110, 0.4) 50%,
        transparent 70%,
        transparent 100%
      );
      opacity: 0;
      animation: topShimmer 6s infinite;
    }
    
    #gameOver {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: none;
      background:
        radial-gradient(800px 500px at 50% 30%, rgba(78,233,196,0.04), transparent),
        linear-gradient(135deg, rgba(14, 18, 24, 0.35), rgba(11, 15, 21, 0.25)),
        var(--glass-noise);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      border: 1px solid var(--glass-border);
      padding: 30px 36px;
      border-radius: 24px;
      box-shadow:
        0 16px 64px var(--shadow-elevated),
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 var(--glass-highlight),
        inset 0 -1px 0 rgba(0, 0, 0, 0.15);
      text-align: center;
      /* Expanded to fit enhanced stats with scroll support */
      width: min(90vw, 540px);
      max-height: 85vh;
      line-height: 1.5;
      opacity: 0;
      overflow-y: auto;
      overflow-x: hidden;
    }
    #gameOver.active {
      animation: glassUnderglow 8s ease-in-out infinite;
    }
    #gameOver h2 {
      margin: 0 0 20px 0;
      font-size: 48px;
      color: var(--danger);
    }
    #gameOver > div {
      font-size: 20px;
      margin-bottom: 30px;
      color: var(--fg);
    }
    #gameOver button {
      margin-top: 24px;
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      color: #001a14;
      border: none;
      padding: 16px 48px;
      border-radius: 18px;
      font-weight: 700;
      font-size: 20px;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      box-shadow:
        0 8px 24px rgba(78, 233, 196, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
    }
    #gameOver button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }
    #gameOver button:hover::before {
      left: 100%;
    }
    #gameOver button:hover {
      filter: brightness(1.1);
      transform: translateY(-3px) scale(1.03);
      box-shadow:
        0 12px 36px rgba(78, 233, 196, 0.4),
        0 6px 18px rgba(78, 233, 196, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    #gameOver button:active {
      transform: translateY(-1px) scale(0.98);
    }
    #fps {
      position: fixed;
      bottom: 10px; right: 12px;
      font-size: 11px;
      color: var(--muted);
      background: #0f1319ee;
      padding: 6px 10px;
      border-radius: 6px;
      user-select: none;
      font-family: 'Courier New', monospace;
      line-height: 1.4;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      backdrop-filter: blur(4px);
    }
    #powerupNotification {
      position: fixed;
      top: 180px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(18, 22, 29, 0.25), rgba(15, 19, 25, 0.25));
      border: 2px solid rgba(90, 242, 199, 0.3);
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 
        0 8px 24px rgba(0,0,0,0.2),
        0 0 30px rgba(90,242,199,0.5),
        0 0 60px rgba(255,91,110,0.3),
        0 0 90px rgba(52,209,255,0.2),
        0 0 120px rgba(255,209,102,0.15);
      font-size: 24px;
      font-weight: 700;
      text-align: center;
      color: var(--accent);
      text-shadow: 0 0 8px rgba(90,242,199,0.6);
      letter-spacing: 1px;
      display: none;
      z-index: 1000;
      animation: powerupPulse 3s ease-out forwards, crystalRainbowGlow 2s ease-in-out infinite;
      pointer-events: none;
      user-select: none;
    }
    
    @keyframes crystalRainbowGlow {
      0%, 100% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(90,242,199,0.6),
          0 0 80px rgba(255,91,110,0.4),
          0 0 120px rgba(52,209,255,0.3);
      }
      25% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(255,91,110,0.6),
          0 0 80px rgba(52,209,255,0.4),
          0 0 120px rgba(255,209,102,0.3);
      }
      50% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(52,209,255,0.6),
          0 0 80px rgba(255,209,102,0.4),
          0 0 120px rgba(90,242,199,0.3);
      }
      75% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(255,209,102,0.6),
          0 0 80px rgba(90,242,199,0.4),
          0 0 120px rgba(255,91,110,0.3);
      }
    }
    #waveAnnouncement {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%) scale(1);
      background: linear-gradient(135deg, rgba(18, 22, 29, 0.25), rgba(15, 19, 25, 0.25));
      border: 2px solid rgba(90, 242, 199, 0.3);
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 
        0 8px 24px rgba(0,0,0,0.2), 
        0 0 30px rgba(90,242,199,0.4),
        0 0 60px rgba(255,91,110,0.3),
        0 0 90px rgba(52,209,255,0.2),
        0 0 120px rgba(255,209,102,0.15);
      text-align: center;
      color: var(--accent);
      display: none;
      z-index: 1001;
      /* opacity handled by animation, not default CSS */
      backdrop-filter: blur(4px);
      pointer-events: none;
      user-select: none;
      min-width: 180px;
      animation: rainbowGlow 3s ease-in-out infinite;
    }
    
    @keyframes rainbowGlow {
      0%, 100% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 30px rgba(90,242,199,0.5),
          0 0 60px rgba(255,91,110,0.3),
          0 0 90px rgba(52,209,255,0.2);
      }
      25% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 30px rgba(255,91,110,0.5),
          0 0 60px rgba(52,209,255,0.3),
          0 0 90px rgba(255,209,102,0.2);
      }
      50% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 30px rgba(52,209,255,0.5),
          0 0 60px rgba(255,209,102,0.3),
          0 0 90px rgba(90,242,199,0.2);
      }
      75% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 30px rgba(255,209,102,0.5),
          0 0 60px rgba(90,242,199,0.3),
          0 0 90px rgba(255,91,110,0.2);
      }
    }
    #waveAnnouncement .wave-number {
      font-size: 24px;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(90,242,199,0.8);
      margin-bottom: 4px;
      letter-spacing: 1px;
      line-height: 1;
    }
    #waveAnnouncement .wave-subtitle {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-shadow: 0 0 4px rgba(90,242,199,0.4);
      margin-top: 2px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    #waveAnnouncement.boss-wave {
      border-color: rgba(255, 68, 68, 0.3);
      background: linear-gradient(135deg, rgba(18, 22, 29, 0.25), rgba(25, 15, 15, 0.25));
      animation: bossRainbowGlow 2s ease-in-out infinite;
    }
    
    @keyframes bossRainbowGlow {
      0%, 100% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(255,68,68,0.6),
          0 0 80px rgba(255,91,110,0.4),
          0 0 120px rgba(255,209,102,0.2);
      }
      50% {
        box-shadow: 
          0 8px 24px rgba(0,0,0,0.2),
          0 0 40px rgba(255,91,110,0.6),
          0 0 80px rgba(255,68,68,0.4),
          0 0 120px rgba(52,209,255,0.2);
      }
    }
    #waveAnnouncement.boss-wave .wave-number {
      color: #ff4444;
      text-shadow: 0 0 8px rgba(255,68,68,0.8);
    }
    #powerupDialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background:
        linear-gradient(135deg, rgba(14, 18, 24, 0.4), rgba(11, 15, 21, 0.3)),
        var(--glass-noise);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      border: 3px solid rgba(78, 233, 196, 0.4);
      padding: 28px 36px;
      border-radius: 20px;
      box-shadow:
        0 16px 48px rgba(0,0,0,0.4),
        0 0 40px rgba(78,233,196,0.5),
        0 0 80px rgba(255,91,110,0.3),
        0 0 120px rgba(52,209,255,0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.08);
      display: none;
      z-index: 2000;
      max-width: 620px;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      user-select: none;
      animation: upgradeRainbowGlow 2.5s ease-in-out infinite;
    }
    
    @keyframes upgradeRainbowGlow {
      0%, 100% {
        box-shadow: 
          0 16px 48px rgba(0,0,0,0.3),
          0 0 50px rgba(90,242,199,0.6),
          0 0 100px rgba(255,91,110,0.4),
          0 0 150px rgba(52,209,255,0.3),
          0 0 200px rgba(255,209,102,0.2);
        border-color: rgba(90, 242, 199, 0.5);
      }
      25% {
        box-shadow: 
          0 16px 48px rgba(0,0,0,0.3),
          0 0 50px rgba(255,91,110,0.6),
          0 0 100px rgba(52,209,255,0.4),
          0 0 150px rgba(255,209,102,0.3),
          0 0 200px rgba(90,242,199,0.2);
        border-color: rgba(255, 91, 110, 0.5);
      }
      50% {
        box-shadow: 
          0 16px 48px rgba(0,0,0,0.3),
          0 0 50px rgba(52,209,255,0.6),
          0 0 100px rgba(255,209,102,0.4),
          0 0 150px rgba(90,242,199,0.3),
          0 0 200px rgba(255,91,110,0.2);
        border-color: rgba(52, 209, 255, 0.5);
      }
      75% {
        box-shadow: 
          0 16px 48px rgba(0,0,0,0.3),
          0 0 50px rgba(255,209,102,0.6),
          0 0 100px rgba(90,242,199,0.4),
          0 0 150px rgba(255,91,110,0.3),
          0 0 200px rgba(52,209,255,0.2);
        border-color: rgba(255, 209, 102, 0.5);
      }
    }
    #powerupDialog h2 {
      margin: 0 0 16px 0;
      color: var(--accent);
      font-size: 24px;
      text-shadow: 0 0 8px rgba(90,242,199,0.6);
    }
    .powerup-options {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 20px;
    }
    .powerup-option {
      background: linear-gradient(180deg, #1a1f29, #0f1319);
      border: 2px solid #293140;
      border-radius: 12px;
      padding: 16px 12px;
      cursor: pointer;
      min-width: 160px;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      opacity: 0;
      transform: translateY(20px) scale(0.9);
      pointer-events: auto;
    }
    .powerup-option.animate-in {
      opacity: 1;
      transform: translateY(0px) scale(1);
    }
    .powerup-option:hover {
      border-color: var(--accent);
      box-shadow: 0 8px 24px rgba(90,242,199,0.4);
      transform: translateY(-4px) scale(1.05);
    }
    .powerup-option:active {
      transform: translateY(-2px) scale(0.98);
    }
    .powerup-option.selected {
      animation: powerupSelected 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
      border-color: #FFD700;
      box-shadow: 0 8px 32px rgba(255, 215, 0, 0.6);
    }
    .powerup-option h3 {
      margin: 0 0 8px 0;
      color: var(--accent);
      font-size: 16px;
    }
    .powerup-option p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.3;
    }
    @keyframes powerupPulse {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.5) rotate(-3deg); 
        filter: blur(6px);
      }
      8% { 
        opacity: 0.9; 
        transform: translateX(-50%) scale(1.2) rotate(1deg); 
        filter: blur(1px);
      }
      15% { 
        opacity: 1; 
        transform: translateX(-50%) scale(0.95) rotate(-0.5deg); 
        filter: blur(0px);
      }
      25% { 
        transform: translateX(-50%) scale(1.05) rotate(0deg); 
      }
      35% { 
        transform: translateX(-50%) scale(1) rotate(0deg); 
      }
      90% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1) rotate(0deg); 
      }
      100% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.8) rotate(1deg); 
        filter: blur(3px);
      }
    }
    canvas { display: block; }
    .edge-warning {
      position: fixed;
      background: rgba(255, 91, 110, 0.5);
      pointer-events: none;
      z-index: 100;
      animation: pulse 0.5s ease-in-out infinite alternate;
    }
    .edge-warning.top {
      top: 0; left: 0; right: 0; height: 16px;
      clip-path: polygon(0 0, 100% 0, calc(100% - 16px) 100%, 16px 100%);
    }
    .edge-warning.bottom {
      bottom: 0; left: 0; right: 0; height: 16px;
      clip-path: polygon(16px 0, calc(100% - 16px) 0, 100% 100%, 0 100%);
    }
    .edge-warning.left {
      left: 0; top: 0; bottom: 0; width: 16px;
      clip-path: polygon(0 0, 100% 16px, 100% calc(100% - 16px), 0 100%);
    }
    .edge-warning.right {
      right: 0; top: 0; bottom: 0; width: 16px;
      clip-path: polygon(0 16px, 100% 0, 100% 100%, 0 calc(100% - 16px));
    }
    
    /* Main Menu Animations */
    @keyframes menuFadeIn {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.8) rotate(-1deg); 
        filter: blur(8px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1) rotate(0deg); 
        filter: blur(0px); 
      }
    }
    @keyframes titleSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(-20px); 
        filter: blur(4px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px); 
        filter: blur(0px); 
      }
    }
    @keyframes subtitleSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(-15px); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px); 
        filter: blur(0px); 
      }
    }
    @keyframes buttonSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(20px) scale(0.9); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px) scale(1); 
        filter: blur(0px); 
      }
    }
    @keyframes controlsSlideIn {
      0% { 
        opacity: 0; 
        transform: translateY(30px); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translateY(0px); 
        filter: blur(0px); 
      }
    }
    
    /* Pause Menu Animations */
    @keyframes pauseSlideIn {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.9); 
        filter: blur(6px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
    }
    @keyframes pauseSlideOut {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(1.1); 
        filter: blur(4px); 
      }
    }

    /* Menu Element Staggered Fade-In Animations */
    @keyframes menuTabFadeIn {
      0% {
        opacity: 0;
        transform: translateY(10px) scale(0.95);
        filter: blur(3px);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
        filter: blur(0);
      }
    }
    @keyframes menuButtonFadeIn {
      0% {
        opacity: 0;
        transform: translateY(15px) scale(0.9);
        filter: blur(3px);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
        filter: blur(0);
      }
    }
    @keyframes menuSectionFadeIn {
      0% {
        opacity: 0;
        transform: translateY(8px);
        filter: blur(2px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
        filter: blur(0);
      }
    }

    /* Game Over Animations */
    @keyframes gameOverDramaticEntry {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.5) rotate(-5deg); 
        filter: blur(10px); 
      }
      50% { 
        opacity: 0.8; 
        transform: translate(-50%, -50%) scale(1.1) rotate(2deg); 
        filter: blur(2px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1) rotate(0deg); 
        filter: blur(0px); 
      }
    }
    @keyframes gameOverSlideOut {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.8); 
        filter: blur(6px); 
      }
    }
    
    /* Modern Game Start Animation - Inspired by Valorant/Destiny */

    @keyframes startVignette {
      0% {
        opacity: 0;
        transform: scale(1.2);
      }
      30% {
        opacity: 1;
        transform: scale(1);
      }
      70% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(0.95);
      }
    }

    @keyframes startEnergyBurst {
      0% {
        transform: translate3d(-50%, -50%, 0) scale(0);
        opacity: 0;
      }
      20% {
        transform: translate3d(-50%, -50%, 0) scale(0.3);
        opacity: 1;
      }
      50% {
        transform: translate3d(-50%, -50%, 0) scale(1.5);
        opacity: 0.8;
      }
      100% {
        transform: translate3d(-50%, -50%, 0) scale(3);
        opacity: 0;
      }
    }

    @keyframes startRays {
      0% {
        transform: translate3d(-50%, -50%, 0) scale(0) rotate(0deg);
        opacity: 0;
      }
      30% {
        transform: translate3d(-50%, -50%, 0) scale(1) rotate(90deg);
        opacity: 0.6;
      }
      70% {
        transform: translate3d(-50%, -50%, 0) scale(1.5) rotate(180deg);
        opacity: 0.3;
      }
      100% {
        transform: translate3d(-50%, -50%, 0) scale(2) rotate(270deg);
        opacity: 0;
      }
    }

    @keyframes startParticles {
      0% {
        opacity: 0;
        transform: scale(2);
      }
      30% {
        opacity: 1;
        transform: scale(1);
      }
      70% {
        opacity: 0.5;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(0.5);
      }
    }

    @keyframes startImpactFlash {
      0% {
        opacity: 1;
      }
      100% {
        opacity: 0;
      }
    }

    @keyframes startEnergyBurstChromaOffset {
      0% {
        transform: translate3d(-48%, -48%, 0) scale(0);
        opacity: 0;
      }
      20% {
        transform: translate3d(-48%, -48%, 0) scale(0.3);
        opacity: 1;
      }
      50% {
        transform: translate3d(-48%, -48%, 0) scale(1.5);
        opacity: 0.8;
      }
      100% {
        transform: translate3d(-48%, -48%, 0) scale(3);
        opacity: 0;
      }
    }

    @keyframes startRingExpansion {
      0% {
        transform: translate3d(-50%, -50%, 0) scale(0);
        opacity: 1;
        border-width: 8px;
      }
      30% {
        transform: translate3d(-50%, -50%, 0) scale(8);
        opacity: 0.8;
        border-width: 4px;
      }
      70% {
        transform: translate3d(-50%, -50%, 0) scale(16);
        opacity: 0.3;
        border-width: 2px;
      }
      100% {
        transform: translate3d(-50%, -50%, 0) scale(24);
        opacity: 0;
        border-width: 1px;
      }
    }

    @keyframes startEnergyBurstCorner {
      0% {
        transform: translate3d(-50%, -50%, 0) scale(0);
        opacity: 0;
      }
      20% {
        transform: translate3d(-50%, -50%, 0) scale(0.5);
        opacity: 0.8;
      }
      50% {
        transform: translate3d(-50%, -50%, 0) scale(1.2);
        opacity: 0.6;
      }
      100% {
        transform: translate3d(-50%, -50%, 0) scale(2.5);
        opacity: 0;
      }
    }

    @keyframes startRaysCornerReverse {
      0% {
        transform: translate3d(-50%, -50%, 0) scale(0) rotate(0deg);
        opacity: 0;
      }
      30% {
        transform: translate3d(-50%, -50%, 0) scale(1) rotate(-90deg);
        opacity: 0.5;
      }
      70% {
        transform: translate3d(-50%, -50%, 0) scale(1.5) rotate(-180deg);
        opacity: 0.2;
      }
      100% {
        transform: translate3d(-50%, -50%, 0) scale(2) rotate(-270deg);
        opacity: 0;
      }
    }

    @keyframes chromaShift {
      0%, 100% { filter: hue-rotate(0deg) saturate(3); }
      25% { filter: hue-rotate(90deg) saturate(4); }
      50% { filter: hue-rotate(180deg) saturate(5); }
      75% { filter: hue-rotate(270deg) saturate(4); }
    }
    
    @keyframes screenShake {
      0%, 100% { transform: translate(0, 0); }
      10% { transform: translate(-5px, 4px); }
      20% { transform: translate(4px, -5px); }
      30% { transform: translate(-4px, -4px); }
      40% { transform: translate(5px, 5px); }
      50% { transform: translate(-3px, 3px); }
      60% { transform: translate(3px, -3px); }
      70% { transform: translate(-2px, -2px); }
      80% { transform: translate(2px, 2px); }
      90% { transform: translate(0, 0); }
    }

    .game-start-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 999;
      opacity: 0;
      overflow: hidden;
      background: radial-gradient(ellipse at center, transparent 0%, rgba(11,13,16,0.4) 100%);
      will-change: opacity;
      transform: translateZ(0);
    }
    
    /* Modern Start Animation Layers */

    .start-impact-flash {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(90,242,199,0.4) 0%, transparent 60%);
      animation: startImpactFlash 0.2s ease-out;
      pointer-events: none;
      z-index: 10;
    }

    .start-vignette {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(ellipse at center,
        transparent 0%,
        transparent 40%,
        rgba(90,242,199,0.1) 70%,
        rgba(90,242,199,0.3) 100%);
      animation: startVignette 1.8s ease-out;
      pointer-events: none;
      will-change: transform, opacity;
    }

    .start-energy-burst {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 800px;
      height: 800px;
      background: radial-gradient(circle,
        rgba(255,255,255,0.5) 0%,
        rgba(90,242,199,0.6) 10%,
        rgba(90,242,199,0.4) 25%,
        rgba(90,242,199,0.2) 45%,
        transparent 70%);
      border-radius: 50%;
      animation: startEnergyBurst 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      pointer-events: none;
      will-change: transform, opacity;
      box-shadow: 0 0 100px rgba(90,242,199,0.6), 0 0 50px rgba(90,242,199,0.7);
    }

    .start-energy-burst-chroma-r {
      width: 820px;
      height: 820px;
      background: radial-gradient(circle,
        rgba(255,100,100,0.15) 0%,
        rgba(255,100,100,0.1) 20%,
        transparent 40%);
      box-shadow: none;
      mix-blend-mode: screen;
      animation: startEnergyBurst 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .start-energy-burst-chroma-b {
      width: 820px;
      height: 820px;
      background: radial-gradient(circle,
        rgba(100,150,255,0.15) 0%,
        rgba(100,150,255,0.1) 20%,
        transparent 40%);
      box-shadow: none;
      mix-blend-mode: screen;
      animation: startEnergyBurstChromaOffset 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .start-energy-burst-tl {
      top: 0;
      left: 0;
      width: 500px;
      height: 500px;
      background: radial-gradient(circle,
        rgba(255,255,255,0.4) 0%,
        rgba(150,100,255,0.5) 12%,
        rgba(90,242,199,0.3) 28%,
        transparent 60%);
      box-shadow: 0 0 80px rgba(150,100,255,0.5);
      animation: startEnergyBurstCorner 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .start-energy-burst-tr {
      top: 0;
      left: 100%;
      width: 500px;
      height: 500px;
      background: radial-gradient(circle,
        rgba(255,255,255,0.4) 0%,
        rgba(100,200,255,0.5) 12%,
        rgba(90,242,199,0.3) 28%,
        transparent 60%);
      box-shadow: 0 0 80px rgba(100,200,255,0.5);
      animation: startEnergyBurstCorner 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.1s;
    }

    .start-energy-burst-bl {
      top: 100%;
      left: 0;
      width: 500px;
      height: 500px;
      background: radial-gradient(circle,
        rgba(255,255,255,0.4) 0%,
        rgba(100,200,255,0.5) 12%,
        rgba(90,242,199,0.3) 28%,
        transparent 60%);
      box-shadow: 0 0 80px rgba(100,200,255,0.5);
      animation: startEnergyBurstCorner 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.2s;
    }

    .start-energy-burst-br {
      top: 100%;
      left: 100%;
      width: 500px;
      height: 500px;
      background: radial-gradient(circle,
        rgba(255,255,255,0.4) 0%,
        rgba(150,100,255,0.5) 12%,
        rgba(90,242,199,0.3) 28%,
        transparent 60%);
      box-shadow: 0 0 80px rgba(150,100,255,0.5);
      animation: startEnergyBurstCorner 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.3s;
    }

    .start-rays {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 200vw;
      height: 200vw;
      background: conic-gradient(
        from 0deg,
        transparent 0deg,
        rgba(90,242,199,0.4) 10deg,
        transparent 20deg,
        transparent 30deg,
        rgba(90,242,199,0.3) 40deg,
        transparent 50deg,
        transparent 60deg,
        rgba(90,242,199,0.4) 70deg,
        transparent 80deg,
        transparent 90deg,
        rgba(90,242,199,0.3) 100deg,
        transparent 110deg,
        transparent 120deg,
        rgba(90,242,199,0.4) 130deg,
        transparent 140deg,
        transparent 150deg,
        rgba(90,242,199,0.3) 160deg,
        transparent 170deg,
        transparent 180deg
      );
      animation: startRays 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      pointer-events: none;
      will-change: transform, opacity;
      mix-blend-mode: screen;
    }

    .start-rays-tl {
      top: 0;
      left: 0;
      width: 150vw;
      height: 150vw;
      animation: startRaysCornerReverse 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .start-rays-tr {
      top: 0;
      left: 100%;
      width: 150vw;
      height: 150vw;
      animation: startRaysCornerReverse 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.1s;
    }

    .start-rays-bl {
      top: 100%;
      left: 0;
      width: 150vw;
      height: 150vw;
      animation: startRaysCornerReverse 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.2s;
    }

    .start-rays-br {
      top: 100%;
      left: 100%;
      width: 150vw;
      height: 150vw;
      animation: startRaysCornerReverse 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.3s;
    }

    .start-particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image:
        radial-gradient(circle at 20% 30%, rgba(90,242,199,0.6) 2px, transparent 2px),
        radial-gradient(circle at 80% 20%, rgba(90,242,199,0.5) 3px, transparent 3px),
        radial-gradient(circle at 40% 70%, rgba(90,242,199,0.7) 2px, transparent 2px),
        radial-gradient(circle at 90% 80%, rgba(90,242,199,0.4) 2px, transparent 2px),
        radial-gradient(circle at 10% 90%, rgba(90,242,199,0.6) 3px, transparent 3px),
        radial-gradient(circle at 70% 50%, rgba(90,242,199,0.5) 2px, transparent 2px),
        radial-gradient(circle at 30% 40%, rgba(90,242,199,0.6) 2px, transparent 2px),
        radial-gradient(circle at 60% 85%, rgba(90,242,199,0.5) 3px, transparent 3px);
      background-size: 100% 100%;
      background-repeat: no-repeat;
      animation: startParticles 1.8s ease-out;
      pointer-events: none;
      will-change: transform, opacity;
    }

    .start-particles-mirror {
      background-image:
        radial-gradient(circle at 80% 70%, rgba(90,242,199,0.6) 2px, transparent 2px),
        radial-gradient(circle at 20% 80%, rgba(90,242,199,0.5) 3px, transparent 3px),
        radial-gradient(circle at 60% 30%, rgba(90,242,199,0.7) 2px, transparent 2px),
        radial-gradient(circle at 10% 20%, rgba(90,242,199,0.4) 2px, transparent 2px),
        radial-gradient(circle at 90% 10%, rgba(90,242,199,0.6) 3px, transparent 3px),
        radial-gradient(circle at 30% 50%, rgba(90,242,199,0.5) 2px, transparent 2px),
        radial-gradient(circle at 70% 60%, rgba(90,242,199,0.6) 2px, transparent 2px),
        radial-gradient(circle at 40% 15%, rgba(90,242,199,0.5) 3px, transparent 3px);
      animation: startParticles 1.8s ease-out 0.15s;
    }

    .start-ring-wave {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100px;
      height: 100px;
      border: 3px solid rgba(90,242,199,0.9);
      border-radius: 50%;
      animation: startRingExpansion 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      pointer-events: none;
      will-change: transform, opacity;
      box-shadow: 0 0 40px rgba(90,242,199,0.8), inset 0 0 40px rgba(90,242,199,0.6);
    }

    /* Powerup Selection Animations */
    @keyframes powerupSelected {
      0% { 
        transform: translateY(-4px) scale(1.05);
      }
      20% { 
        transform: translateY(-12px) scale(1.15) rotate(2deg);
        filter: brightness(1.3);
      }
      50% { 
        transform: translateY(-8px) scale(1.2) rotate(-1deg);
        filter: brightness(1.5);
      }
      80% { 
        transform: translateY(-4px) scale(1.1) rotate(0deg);
        filter: brightness(1.2);
      }
      100% { 
        transform: translateY(-4px) scale(1.05);
        filter: brightness(1);
      }
    }
    
    @keyframes powerupDialogEntry {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.8); 
        filter: blur(6px); 
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
    }
    @keyframes powerupDialogExit {
      0% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
        filter: blur(0px); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(1.1); 
        filter: blur(4px); 
      }
    }
    
    /* Wave Card Animations */
    @keyframes waveCardEntry {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) translateY(-30px) scale(0.5);
        filter: blur(4px);
      }
      10% { 
        opacity: 0.7; 
        transform: translateX(-50%) translateY(-5px) scale(1.1);
        filter: blur(1px);
      }
      25% { 
        opacity: 1; 
        transform: translateX(-50%) translateY(2px) scale(0.95);
        filter: blur(0px);
      }
      40% { 
        transform: translateX(-50%) translateY(-1px) scale(1.02);
      }
      60% { 
        transform: translateX(-50%) translateY(1px) scale(0.99);
      }
      100% { 
        transform: translateX(-50%) translateY(0) scale(1);
      }
    }
    
    @keyframes waveCardExit {
      0% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1);
      }
      100% { 
        opacity: 0; 
        transform: translateX(-50%) translateY(-20px) scale(0.8);
        filter: blur(4px);
      }
    }
    
    /* Enhanced Wave Announcements */
    @keyframes waveDramaticEntry {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.3) rotateY(90deg); 
        filter: blur(10px);
      }
      30% { 
        opacity: 0.8; 
        transform: translateX(-50%) scale(1.3) rotateY(-10deg); 
        filter: blur(2px);
      }
      60% { 
        opacity: 1; 
        transform: translateX(-50%) scale(0.9) rotateY(5deg); 
        filter: blur(0px);
      }
      80% { 
        transform: translateX(-50%) scale(1.1) rotateY(-2deg); 
      }
      90% { 
        transform: translateX(-50%) scale(1) rotateY(0deg); 
      }
      95% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1) rotateY(0deg); 
      }
      100% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.7) rotateY(-5deg); 
        filter: blur(4px);
      }
    }
    
    @keyframes bossWaveEntry {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.2); 
        filter: blur(15px) hue-rotate(0deg);
        background: linear-gradient(180deg, rgba(255, 0, 0, 0.9), rgba(139, 0, 0, 0.8));
      }
      15% { 
        opacity: 0.9; 
        transform: translateX(-50%) scale(1.5); 
        filter: blur(3px) hue-rotate(180deg);
      }
      30% { 
        opacity: 1; 
        transform: translateX(-50%) scale(0.8); 
        filter: blur(0px) hue-rotate(360deg);
      }
      50% { 
        transform: translateX(-50%) scale(1.2); 
      }
      70% { 
        transform: translateX(-50%) scale(1); 
      }
      90% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1); 
      }
      100% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.5); 
        filter: blur(8px);
      }
    }

    /* Flashy Game Title Animations */
    .game-title {
      font-size: 42px !important;
      font-weight: 900;
      margin-bottom: 12px !important;
      text-transform: uppercase;
      position: relative;
      display: block;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      text-align: center;
      transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .title-letter {
      display: inline-block;
      background: linear-gradient(90deg, #ff00ff, #00ffff, #ffff00, #ff00ff);
      background-size: 300% 300%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: 
        epicRainbow 2s linear infinite,
        letterFloat 3s ease-in-out infinite,
        letterGlow 2s ease-in-out infinite alternate;
      position: relative;
      transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .title-space {
      display: inline-block;
      width: 0.3em;
    }
    
    /* Individual letter animations with delays */
    .title-letter:nth-child(1) { animation-delay: 0s; }
    .title-letter:nth-child(2) { animation-delay: 0.1s; }
    .title-letter:nth-child(3) { animation-delay: 0.2s; }
    .title-letter:nth-child(4) { animation-delay: 0.3s; }
    .title-letter:nth-child(5) { animation-delay: 0.4s; }
    .title-letter:nth-child(6) { animation-delay: 0.5s; }
    .title-letter:nth-child(7) { animation-delay: 0.6s; }
    .title-letter:nth-child(8) { animation-delay: 0.7s; }
    .title-letter:nth-child(10) { animation-delay: 0.8s; }
    .title-letter:nth-child(11) { animation-delay: 0.9s; }
    .title-letter:nth-child(12) { animation-delay: 1.0s; }
    .title-letter:nth-child(13) { animation-delay: 1.1s; }
    .title-letter:nth-child(14) { animation-delay: 1.2s; }
    .title-letter:nth-child(15) { animation-delay: 1.3s; }
    
    /* Hover effects */
    .game-title:hover {
      transform: scale(1.1);
    }
    
    .game-title:hover .title-letter {
      animation: 
        epicRainbow 0.3s linear infinite,
        letterDance 0.5s ease-in-out infinite,
        letterGlowIntense 0.3s ease-in-out infinite alternate;
      filter: drop-shadow(0 0 15px currentColor);
    }
    
    .game-title:hover .title-letter:nth-child(odd) {
      animation-direction: reverse;
    }

    @keyframes epicRainbow {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }
    
    @keyframes titleBounce {
      0%, 100% { transform: translateY(-20px) scale(1) rotateZ(0deg); }
      25% { transform: translateY(-25px) scale(1.02) rotateZ(1deg); }
      50% { transform: translateY(-20px) scale(1) rotateZ(0deg); }
      75% { transform: translateY(-15px) scale(1.02) rotateZ(-1deg); }
    }
    
    @keyframes glowPulse {
      0% { 
        filter: drop-shadow(0 0 10px rgba(255, 0, 255, 0.6))
                drop-shadow(0 0 20px rgba(0, 255, 255, 0.4));
      }
      100% { 
        filter: drop-shadow(0 0 25px rgba(255, 255, 0, 0.8))
                drop-shadow(0 0 40px rgba(255, 0, 255, 0.6))
                drop-shadow(0 0 60px rgba(0, 255, 255, 0.4));
      }
    }
    
    @keyframes letterFloat {
      0%, 100% { 
        transform: translateY(0px) rotateZ(0deg);
      }
      25% { 
        transform: translateY(-5px) rotateZ(-2deg);
      }
      50% { 
        transform: translateY(0px) rotateZ(0deg);
      }
      75% { 
        transform: translateY(-3px) rotateZ(2deg);
      }
    }
    
    @keyframes letterGlow {
      0% { 
        filter: drop-shadow(0 0 5px rgba(255, 0, 255, 0.6));
        transform: scale(1);
      }
      100% { 
        filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.9));
        transform: scale(1.05);
      }
    }
    
    @keyframes letterDance {
      0%, 100% { 
        transform: translateY(0px) rotateZ(0deg) scale(1);
      }
      25% { 
        transform: translateY(-10px) rotateZ(-5deg) scale(1.2);
      }
      50% { 
        transform: translateY(5px) rotateZ(5deg) scale(0.9);
      }
      75% { 
        transform: translateY(-5px) rotateZ(-3deg) scale(1.1);
      }
    }
    
    @keyframes letterGlowIntense {
      0% { 
        filter: drop-shadow(0 0 10px rgba(255, 0, 255, 0.9))
                drop-shadow(0 0 20px rgba(255, 255, 0, 0.7));
      }
      100% { 
        filter: drop-shadow(0 0 25px rgba(0, 255, 255, 1))
                drop-shadow(0 0 40px rgba(255, 0, 255, 0.8));
      }
    }

    .game-subtitle {
      font-size: 16px;
      color: #5af2c7;
      font-weight: 600;
      text-shadow: 0 0 10px rgba(90, 242, 199, 0.5);
      animation: subtitleGlow 2.5s ease-in-out infinite alternate;
      letter-spacing: 1px;
    }

    @keyframes subtitleGlow {
      0% { 
        opacity: 0.8;
        text-shadow: 0 0 10px rgba(90, 242, 199, 0.5);
      }
      100% { 
        opacity: 1;
        text-shadow: 0 0 20px rgba(90, 242, 199, 0.8), 0 0 30px rgba(90, 242, 199, 0.4);
      }
    }
    
    /* Mobile Touch Zones Visual Indicators */
    #touchZones {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 450;
      display: none;
    }
    
    .touch-zone {
      position: absolute;
      border: 2px dashed rgba(90, 242, 199, 0.3);
      background: rgba(90, 242, 199, 0.05);
      pointer-events: none;
    }
    
    .touch-zone.left {
      left: 0;
      top: 0;
      width: 50%;
      height: 100%;
      border-right: 2px solid rgba(90, 242, 199, 0.3);
    }
    
    .touch-zone.right {
      right: 0;
      top: 0;
      width: 50%;
      height: 100%;
    }
    
    .touch-indicator {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 3px solid rgba(90, 242, 199, 0.6);
      background: radial-gradient(circle, rgba(90, 242, 199, 0.3), transparent);
      pointer-events: none;
      display: none;
      transform: translate(-50%, -50%);
    }
    
    .touch-indicator.active {
      display: block;
      animation: touchPulse 0.3s ease-out;
    }
    
    @keyframes touchPulse {
      0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
    }
    
    /* Landscape Orientation Lock Message */
    #orientationWarning {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #0b0d10 0%, #12161d 100%);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      flex-direction: column;
      gap: 30px;
      padding: 40px;
      text-align: center;
    }
    
    #orientationWarning.show {
      display: flex !important;
    }
    
    .rotate-icon {
      width: 120px;
      height: 80px;
      border: 3px solid var(--accent);
      border-radius: 15px;
      position: relative;
      animation: rotatePhone 2s ease-in-out infinite;
      background: rgba(90, 242, 199, 0.1);
    }
    
    .rotate-icon::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
    }
    
    .rotate-icon::after {
      content: '';
      position: absolute;
      bottom: -35px;
      right: -35px;
      font-size: 32px;
      color: var(--accent);
      animation: spin 2s linear infinite;
    }
    
    @keyframes rotatePhone {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }
    
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .orientation-message {
      font-size: 28px;
      color: var(--fg);
      font-weight: 600;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .orientation-submessage {
      font-size: 18px;
      color: var(--muted);
      margin-top: 10px;
    }
    
    /* Force landscape on mobile - show warning in portrait */
    @media screen and (orientation: portrait) and (max-width: 1024px) {
      #orientationWarning {
        display: flex !important;
      }
      
      #c, #gameStartOverlay, #hud, #mobileControls, #touchZones, #virtualJoystick, #banner, #gameOver {
        visibility: hidden !important;
      }
    }
    
    /* Optimize UI for landscape mobile */
    @media screen and (orientation: landscape) and (max-height: 600px) {
      #hud {
        top: 5px;
        left: 10px;
        padding: 8px 12px;
        font-size: 14px;
        min-width: 240px;
      }

      #hud .bar {
        --w: 180px;
        height: 8px;
      }
      
      .mobile-btn {
        width: 65px;
        height: 65px;
        font-size: 24px;
      }
      
      .sprint-btn {
        bottom: 15px;
        left: 15px;
        width: 75px;
        height: 75px;
      }
      
      .leap-btn {
        bottom: 15px;
        right: 15px;
        width: 75px;
        height: 75px;
      }
      
      .pause-btn {
        top: 5px;
        right: 10px;
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
      
      #virtualJoystick {
        width: 100px;
        height: 100px;
      }
      
      .joystick-knob {
        width: 35px;
        height: 35px;
      }
    }
    
    /* Mobile Virtual Joystick */
    #virtualJoystick {
      position: fixed;
      width: 120px;
      height: 120px;
      display: none;
      pointer-events: none;
      z-index: 460;
    }
    
    .joystick-base {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px solid rgba(90, 242, 199, 0.4);
      background: radial-gradient(circle, rgba(18, 22, 29, 0.8), rgba(15, 19, 25, 0.6));
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }
    
    .joystick-knob {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), #34d1ff);
      border: 2px solid rgba(255, 255, 255, 0.3);
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 8px rgba(90, 242, 199, 0.5);
      transition: none;
    }
    
    /* Mobile Control Buttons */
    .mobile-btn {
      position: fixed;
      background: linear-gradient(135deg, rgba(18, 22, 29, 0.9), rgba(15, 19, 25, 0.8));
      border: 2px solid rgba(90, 242, 199, 0.5);
      border-radius: 50%;
      color: var(--accent);
      font-size: 28px;
      cursor: pointer;
      user-select: none;
      touch-action: none;
      z-index: 500;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      -webkit-tap-highlight-color: transparent;
    }
    
    .mobile-btn:active {
      transform: scale(0.95);
      background: linear-gradient(135deg, rgba(90, 242, 199, 0.3), rgba(90, 242, 199, 0.2));
      border-color: var(--accent);
      box-shadow: 0 0 20px rgba(90, 242, 199, 0.5);
    }
    
    .mobile-btn.active {
      background: linear-gradient(135deg, rgba(90, 242, 199, 0.4), rgba(90, 242, 199, 0.3));
      border-color: var(--accent);
      box-shadow: 0 0 25px rgba(90, 242, 199, 0.6);
    }
    
    /* Sprint Button - Bottom Left */
    .sprint-btn {
      width: 80px;
      height: 80px;
      left: 20px;
      bottom: 120px;
    }
    
    .sprint-btn.sprinting {
      animation: sprintPulse 0.5s ease-in-out infinite;
    }
    
    /* Leap Button - Bottom Right */
    .leap-btn {
      width: 80px;
      height: 80px;
      right: 20px;
      bottom: 120px;
      position: relative;
    }
    
    .leap-btn.ready {
      border-color: #00ffff;
      animation: leapReady 1s ease-in-out infinite;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
    }
    
    .leap-btn.cooldown {
      opacity: 0.5;
      border-color: rgba(90, 242, 199, 0.2);
    }
    
    .leap-cooldown {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top-color: var(--accent);
      display: none;
    }
    
    .leap-btn.cooldown .leap-cooldown {
      display: block;
      animation: rotateCooldown 3s linear;
    }
    
    /* Pause Button - Top Right */
    .pause-btn {
      width: 50px;
      height: 50px;
      right: 20px;
      top: 20px;
      font-size: 20px;
      opacity: 0.7;
    }
    
    .pause-btn:hover {
      opacity: 1;
    }
    
    /* Mobile Button Animations */
    @keyframes sprintPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    @keyframes leapReady {
      0% { 
        transform: scale(1);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
      }
      50% { 
        transform: scale(1.05);
        box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
      }
      100% { 
        transform: scale(1);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
      }
    }
    
    @keyframes rotateCooldown {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes hudFadeIn {
      0% {
        opacity: 0;
        visibility: hidden;
        transform: translateY(-10px) scale(0.95);
        filter: blur(4px);
      }
      50% {
        filter: blur(2px);
      }
      100% {
        opacity: 1;
        visibility: visible;
        transform: translateY(0) scale(1);
        filter: blur(0);
      }
    }
    
    @keyframes topShimmer {
      0%, 100% {
        opacity: 0;
        transform: translateX(-100%);
      }
      40% {
        opacity: 0;
      }
      50% {
        opacity: 0.8;
        transform: translateX(0%);
      }
      60% {
        opacity: 0;
      }
    }
    
    @keyframes glassUnderglow {
      0%, 100% {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.1),
                    0 20px 60px -10px rgba(90, 242, 199, 0.15),
                    0 10px 40px -5px rgba(90, 242, 199, 0.2);
      }
      25% {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.1),
                    0 25px 70px -10px rgba(90, 242, 199, 0.25),
                    0 15px 50px -5px rgba(52, 209, 255, 0.15);
      }
      50% {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.1),
                    0 30px 80px -10px rgba(52, 209, 255, 0.2),
                    0 20px 60px -5px rgba(90, 242, 199, 0.25);
      }
      75% {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25),
                    inset 0 1px 0 rgba(255, 255, 255, 0.05),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.1),
                    0 25px 70px -10px rgba(52, 209, 255, 0.15),
                    0 15px 50px -5px rgba(90, 242, 199, 0.2);
      }
    }
    
    /* Hide mobile controls on desktop */
    @media (hover: hover) and (pointer: fine) {
      #mobileControls {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="game-start-overlay" id="gameStartOverlay">
    <div class="start-impact-flash"></div>
    <div class="start-vignette"></div>
    <div class="start-energy-burst"></div>
    <div class="start-energy-burst start-energy-burst-chroma-r"></div>
    <div class="start-energy-burst start-energy-burst-chroma-b"></div>
    <div class="start-energy-burst start-energy-burst-tl"></div>
    <div class="start-energy-burst start-energy-burst-tr"></div>
    <div class="start-energy-burst start-energy-burst-bl"></div>
    <div class="start-energy-burst start-energy-burst-br"></div>
    <div class="start-ring-wave"></div>
    <div class="start-rays"></div>
    <div class="start-rays start-rays-tl"></div>
    <div class="start-rays start-rays-tr"></div>
    <div class="start-rays start-rays-bl"></div>
    <div class="start-rays start-rays-br"></div>
    <div class="start-particles"></div>
    <div class="start-particles start-particles-mirror"></div>
  </div>
  <div id="hud">
    <div class="row">Health
      <span class="bar health"><i id="healthBar" style="width:100%"></i></span>
      <span id="hpTxt">100</span>
    </div>
    <div class="row">Stamina
      <span class="bar stamina"><i id="staminaBar" style="width:100%"></i></span>
      <span id="staminaTxt">100</span>
    </div>
    <div class="row">Heat
      <span class="bar heat"><i id="heatBar" style="width:0%"></i></span>
      <span id="heatTxt">0</span>
    </div>
    <div class="row">Wave <span id="wave" class="stat-value">1</span>  Kills <span id="kills" class="stat-value">0</span></div>
  </div>
  <div id="banner">
    <h1 class="game-title">
      <span class="title-letter"></span>
      <span class="title-letter">C</span>
      <span class="title-letter">R</span>
      <span class="title-letter">Y</span>
      <span class="title-letter">S</span>
      <span class="title-letter">T</span>
      <span class="title-letter">A</span>
      <span class="title-letter">L</span>
      <span class="title-space"> </span>
      <span class="title-letter">B</span>
      <span class="title-letter">L</span>
      <span class="title-letter">I</span>
      <span class="title-letter">T</span>
      <span class="title-letter">Z</span>
      <span class="title-letter"></span>
    </h1>
    <div class="game-subtitle">SURVIVE THE ENDLESS WAVES</div>
    <div class="controls-panel">
      <div class="controls-title"><strong>Controls</strong></div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd>
        </div>
        <div class="control-desc">Move around the arena</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>Mouse</kbd>
        </div>
        <div class="control-desc">Aim and shoot</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>Shift</kbd>
        </div>
        <div class="control-desc">Dash through enemies</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>Space</kbd>
        </div>
        <div class="control-desc">Emergency leap</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>P</kbd> or <kbd>ESC</kbd>
        </div>
        <div class="control-desc">Pause / Resume game</div>
      </div>
      <div class="control-row">
        <div class="control-keys">
          <kbd>F11</kbd>
        </div>
        <div class="control-desc">Toggle fullscreen</div>
      </div>
      <div class="mobile-note">Mobile: Touch left side to move, right side to aim/shoot<br>
         Sprint (bottom left) |  Leap (bottom right) |  Pause (top right)</div>
    </div>
    <button id="startBtn">PLAY</button>
    <button id="optionsBtn">Options</button>
  </div>
  <div id="optionsPanel" class="panel" style="display:none;">
    <!-- Options content will be dynamically created -->
  </div>
  <div id="gameOver">
    <h2>Game Over</h2>
    <div style="margin: 20px 0; font-size: 18px;">
      <div style="margin: 8px 0;">Wave: <span id="goWave" style="color: #5af2c7; font-weight: bold;">1</span></div>
      <div style="margin: 8px 0;">Kills: <span id="goKills" style="color: #5af2c7; font-weight: bold;">0</span></div>
      <div style="margin: 8px 0;">Time: <span id="goTime" style="color: #5af2c7; font-weight: bold;">0:00</span></div>
      <div style="margin: 8px 0;">Best Combo: <span id="goCombo" style="color: #FFD700; font-weight: bold;">0x</span></div>
      <div style="margin: 8px 0;">Accuracy: <span id="goAccuracy" style="color: #5af2c7; font-weight: bold;">0%</span></div>
    </div>
    <div id="newRecordBanner" style="display:none; margin: 15px 0; padding: 12px; background: linear-gradient(90deg, rgba(255,215,0,0.2), rgba(90,242,199,0.2)); border-radius: 8px; border: 2px solid #FFD700;">
      <div style="font-size: 20px; color: #FFD700; font-weight: bold;"> NEW RECORDS! </div>
      <div id="recordsList" style="margin-top: 8px; font-size: 14px; color: #e3e7ef;"></div>
    </div>
    <div style="margin: 20px 0; padding: 15px; background: rgba(18,22,29,0.6); border-radius: 8px; font-size: 14px;">
      <div style="margin-bottom: 10px; color: #99a2b2; font-weight: bold;">CAREER STATS</div>
      <div style="margin: 5px 0;">Best Wave: <span id="statsBestWave" style="color: #e3e7ef;">0</span></div>
      <div style="margin: 5px 0;">Best Kills: <span id="statsBestKills" style="color: #e3e7ef;">0</span></div>
      <div style="margin: 5px 0;">Best Combo: <span id="statsBestCombo" style="color: #e3e7ef;">0x</span></div>
      <div style="margin: 5px 0;">Total Kills: <span id="statsTotalKills" style="color: #e3e7ef;">0</span></div>
      <div style="margin: 5px 0;">Games Played: <span id="statsGamesPlayed" style="color: #e3e7ef;">0</span></div>
      <div style="margin: 5px 0;">Total Playtime: <span id="statsTotalTime" style="color: #e3e7ef;">0h 0m</span></div>
    </div>
    <button id="restartBtn">Restart</button>
  </div>
  <div id="fps">FPS: </div>
  <div id="powerupNotification"></div>
  <div id="waveAnnouncement">
    <div class="wave-number"></div>
    <div class="wave-subtitle"></div>
  </div>
  <div class="edge-warning top" id="edgeTop" style="display:none"></div>
  <div class="edge-warning bottom" id="edgeBottom" style="display:none"></div>
  <div class="edge-warning left" id="edgeLeft" style="display:none"></div>
  <div class="edge-warning right" id="edgeRight" style="display:none"></div>
  <div id="powerupDialog">
    <h2>Choose Your Upgrade</h2>
    <div class="powerup-options">
      <div class="powerup-option" id="powerupOption1">
        <h3 id="powerupTitle1">Title</h3>
        <p id="powerupDesc1">Description</p>
      </div>
      <div class="powerup-option" id="powerupOption2">
        <h3 id="powerupTitle2">Title</h3>
        <p id="powerupDesc2">Description</p>
      </div>
      <div class="powerup-option" id="powerupOption3">
        <h3 id="powerupTitle3">Title</h3>
        <p id="powerupDesc3">Description</p>
      </div>
    </div>
  </div>

  <!-- Mobile Touch Zones -->
  <div id="touchZones">
    <div class="touch-zone left">
      <div style="position: absolute; top: 20px; left: 20px; color: rgba(90, 242, 199, 0.5); font-size: 14px;">MOVE</div>
    </div>
    <div class="touch-zone right">
      <div style="position: absolute; top: 20px; right: 20px; color: rgba(90, 242, 199, 0.5); font-size: 14px;">AIM & SHOOT</div>
    </div>
    <div id="touchIndicatorLeft" class="touch-indicator"></div>
    <div id="touchIndicatorRight" class="touch-indicator"></div>
  </div>
  
  <!-- Virtual Joystick -->
  <div id="virtualJoystick">
    <div class="joystick-base"></div>
    <div id="joystickKnob" class="joystick-knob"></div>
  </div>
  
  <!-- Orientation Warning -->
  <div id="orientationWarning">
    <div class="rotate-icon"></div>
    <div class="orientation-message">Please Rotate Your Device</div>
    <div class="orientation-submessage">Crystal Blitz requires landscape orientation for the best experience</div>
  </div>
  
  <!-- Mobile Control Buttons (only visible on touch devices) -->
  <div id="mobileControls" style="display:none">
    <button id="sprintBtn" class="mobile-btn sprint-btn"></button>
    <button id="leapBtn" class="mobile-btn leap-btn">
      <span class="leap-icon"></span>
      <span class="leap-cooldown"></span>
    </button>
    <button id="pauseBtn" class="mobile-btn pause-btn"></button>
  </div>

  <script>
  'use strict';

  // ===== Canvas & Resize =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  
  // Offscreen canvas for static background grid (draw once, reuse forever)
  let bgCanvas = null;
  let bgCtx = null;
  let bgNeedsRedraw = true;
  
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    bgNeedsRedraw = true; // Redraw background on resize
  }
  window.addEventListener('resize', resize);
  resize();

  // ===== UI Elements =====
  // Helper function to get elements by ID
  const getElement = (id) => document.getElementById(id);

  // Single elements
  const startBtn = getElement('startBtn');
  const banner = getElement('banner');
  const hudHpBar = getElement('healthBar');
  const hudStaminaBar = getElement('staminaBar');
  const hudHeatBar = getElement('heatBar');
  const hpTxt = getElement('hpTxt');
  const staminaTxt = getElement('staminaTxt');
  const heatTxt = getElement('heatTxt');
  const waveTxt = getElement('wave');
  const killsTxt = getElement('kills');
  const fpsTxt = getElement('fps');
  const gameOverPanel = getElement('gameOver');
  const goWave = getElement('goWave');
  const goKills = getElement('goKills');
  const gameStartOverlay = getElement('gameStartOverlay');
  const restartBtn = getElement('restartBtn');
  const powerupNotification = getElement('powerupNotification');
  const waveAnnouncement = getElement('waveAnnouncement');
  const powerupDialog = getElement('powerupDialog');
  const optionsPanel = getElement('optionsPanel');
  const optionsBtn = getElement('optionsBtn');

  // Grouped elements (powerup options, titles, descriptions)
  const powerupOptions = [1, 2, 3].map(i => getElement(`powerupOption${i}`));
  const powerupTitles = [1, 2, 3].map(i => getElement(`powerupTitle${i}`));
  const powerupDescs = [1, 2, 3].map(i => getElement(`powerupDesc${i}`));
  const edgeWarnings = {
    top: getElement('edgeTop'),
    bottom: getElement('edgeBottom'),
    left: getElement('edgeLeft'),
    right: getElement('edgeRight')
  };
  
  // Mobile control buttons
  const mobileControls = getElement('mobileControls');
  const sprintBtn = getElement('sprintBtn');
  const leapBtn = getElement('leapBtn');
  const pauseBtn = getElement('pauseBtn');

  // ============================================================
  // SECTION: MATH UTILITIES
  // ============================================================

  /** Mathematical constant for 2 (full circle in radians) */
  const TAU = Math.PI * 2;

  /**
   * Clamps a value between a minimum and maximum
   * @param {number} v - Value to clamp
   * @param {number} lo - Minimum value
   * @param {number} hi - Maximum value
   * @returns {number} Clamped value
   */
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  /**
   * Returns the squared length of a 2D vector (avoids expensive sqrt)
   * @param {number} x - X component
   * @param {number} y - Y component
   * @returns {number} Squared length (x + y)
   */
  function len2(x,y){ return x*x + y*y; }

  /** Reusable vector objects to eliminate array allocations during gameplay */
  const vecPool = {
    temp1: {x: 0, y: 0},
    temp2: {x: 0, y: 0},
    temp3: {x: 0, y: 0},
    temp4: {x: 0, y: 0}
  };

  /**
   * Fast length calculation for 2D vectors
   * @param {number} x - X component
   * @param {number} y - Y component
   * @returns {number} Vector length
   */
  function fastLength(x, y) {
    return Math.sqrt(x * x + y * y);
  }

  /**
   * Normalizes a 2D vector (legacy version with array allocation)
   * @param {number} x - X component
   * @param {number} y - Y component
   * @returns {Array<number>} Normalized vector as [x, y]
   * @deprecated Use normInPlace() to avoid allocations
   */
  function norm(x,y) {
    const L = fastLength(x,y); return [x/L, y/L];
  }

  /**
   * Normalizes a 2D vector in-place (no allocations)
   * @param {number} x - X component
   * @param {number} y - Y component
   * @param {Object} out - Output object with x, y properties
   * @returns {Object} The output object with normalized components
   */
  function normInPlace(x, y, out) {
    const L = fastLength(x, y);
    out.x = x / L;
    out.y = y / L;
    return out;
  }

  /**
   * Returns a random value in the range [a, b]
   * @param {number} a - Minimum value
   * @param {number} b - Maximum value
   * @returns {number} Random value
   */
  function randRange(a,b){ return a + Math.random()*(b-a); }

  /**
   * Returns the sign of a number (-1, 0, or 1)
   * @param {number} v - Input value
   * @returns {number} -1 if negative, 1 if positive or zero
   */
  function sign(v){ return v < 0 ? -1 : 1; }

  // ============================================================
  // SECTION: SAVE SYSTEM & STATS TRACKING
  // ============================================================

  const SAVE_KEY = 'crystalBlitz_save_v1';

  function getDefaultSave() {
    return {
      // High scores
      highestWave: 0,
      bestKills: 0,
      longestSurvivalTime: 0,
      bestCombo: 0,
      bestAccuracy: 0,

      // Career stats
      totalKills: 0,
      totalShots: 0,
      totalHits: 0,
      totalDeaths: 0,
      gamesPlayed: 0,
      totalPlayTime: 0,
    };
  }

  /**
   * Loads save data from localStorage with error handling
   * @returns {Object} Save data object with high scores and stats
   */
  function loadSaveData() {
    try {
      const data = localStorage.getItem(SAVE_KEY);
      if (!data) return getDefaultSave();
      return {...getDefaultSave(), ...JSON.parse(data)};
    } catch (e) {
      console.warn('Failed to load save data:', e);
      return getDefaultSave();
    }
  }

  /**
   * Saves current save data to localStorage
   * Includes error handling for quota exceeded and other failures
   */
  function saveSaveData() {
    try {
      localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
      return true; // Save successful
    } catch (e) {
      // Handle specific error types
      if (e.name === 'QuotaExceededError') {
        // localStorage quota exceeded
        showNotification('Save failed: Storage quota exceeded. Clear browser data to continue saving.', 5000);
      } else if (e.name === 'SecurityError') {
        // localStorage blocked (private browsing, etc.)
        showNotification('Save failed: Storage blocked. Check browser privacy settings.', 5000);
      } else {
        // Other storage errors
        showNotification('Save failed: Unable to save game progress.', 3000);
      }
      return false; // Save failed
    }
  }

  /**
   * Displays a temporary notification message to the user
   * @param {string} message - Message to display
   * @param {number} duration - Display duration in milliseconds
   */
  function showNotification(message, duration = 3000) {
    // Create notification element if it doesn't exist
    let notification = document.getElementById('save-notification');
    if (!notification) {
      notification = document.createElement('div');
      notification.id = 'save-notification';
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 100, 100, 0.9);
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-family: monospace;
        font-size: 14px;
        z-index: 10000;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
      `;
      document.body.appendChild(notification);
    }

    // Show notification
    notification.textContent = message;
    notification.style.opacity = '1';

    // Hide after duration
    setTimeout(() => {
      notification.style.opacity = '0';
    }, duration);
  }

  let saveData = loadSaveData();

  /**
   * Updates high scores and returns list of new records achieved
   * @param {Object} game - Game state object containing wave, kills, time, etc.
   * @returns {string[]} Array of record names (e.g., "Highest Wave", "Best Combo")
   */
  function updateHighScores(game) {
    let newRecords = [];

    // Calculate accuracy
    const accuracy = game.shotsFired > 0 ? (game.shotsHit / game.shotsFired) * 100 : 0;

    // Check for new records
    if (game.wave > saveData.highestWave) {
      saveData.highestWave = game.wave;
      newRecords.push('Highest Wave');
    }

    if (game.kills > saveData.bestKills) {
      saveData.bestKills = game.kills;
      newRecords.push('Most Kills');
    }

    if (game.t > saveData.longestSurvivalTime) {
      saveData.longestSurvivalTime = game.t;
      newRecords.push('Longest Survival');
    }

    if (game.highestCombo > saveData.bestCombo) {
      saveData.bestCombo = game.highestCombo;
      newRecords.push('Best Combo');
    }

    if (accuracy > saveData.bestAccuracy) {
      saveData.bestAccuracy = accuracy;
      newRecords.push('Best Accuracy');
    }

    // Update career stats
    saveData.totalKills += game.kills;
    saveData.totalShots += game.shotsFired || 0;
    saveData.totalHits += game.shotsHit || 0;
    saveData.totalDeaths += 1;
    saveData.gamesPlayed += 1;
    saveData.totalPlayTime += game.t;

    saveSaveData();

    return newRecords;
  }

  // ============================================================
  // SECTION: GAME CONSTANTS & CONFIGURATION
  // ============================================================

  /**
   * AI Behavior Constants - Centralized tuning values for enemy movement
   */
  const AI_CONSTANTS = {
    // Serpent (zigzag) behavior
    SERPENT_ZIGZAG_STRENGTH_X: 300,
    SERPENT_ZIGZAG_STRENGTH_Y: 250,
    SERPENT_SPEED_MULTIPLIER: 1.5,

    // Prowler (flanking) behavior
    PROWLER_FLANK_SPEED: 2.0,
    PROWLER_DIRECT_ATTRACTION: 0.2,

    // Berserker (dash) behavior
    BERSERKER_PROWL_SPEED: 1.2,
    BERSERKER_TELEGRAPH_SPEED: 0.2,
    BERSERKER_TELEGRAPH_DURATION: 1.0,
    BERSERKER_DASH_DURATION: 0.4,
    BERSERKER_DASH_MULTIPLIER: 3,
    BERSERKER_DASH_IMPULSE: 8,
    BERSERKER_COOLDOWN_MIN: 3,
    BERSERKER_COOLDOWN_MAX: 5,

    // Maniac (chaotic) behavior
    MANIAC_CHAOS_FACTOR: 800,
    MANIAC_SPEED_MULTIPLIER: 1.5,

    // Leaper (rush) behavior
    LEAPER_RUSH_MULTIPLIER: 4,
    LEAPER_RUSH_IMPULSE: 10,
    LEAPER_BETWEEN_RUSH_SPEED: 1.8,
    LEAPER_COOLDOWN_MIN: 1.0,
    LEAPER_COOLDOWN_MAX: 2.5,

    // Volatile (suicide crawler) behavior
    VOLATILE_ORBIT_RADIUS: 120,
    VOLATILE_ORBIT_SPEED: 1.2,
    VOLATILE_ORBIT_MOVE_SPEED: 1.5,
    VOLATILE_ORBIT_ATTRACTION: 0.2,
    VOLATILE_TELEGRAPH_DURATION: 1.0,
    VOLATILE_CHARGE_MULTIPLIER: 4,
    VOLATILE_CHARGE_IMPULSE: 15,

    // Boss behavior
    BOSS_SPEED_MULTIPLIER: 1.2,
    SUPERBOSS_PHASE_DURATION: 20,
    SUPERBOSS_ORBIT_SPEED: 1.8,
    SUPERBOSS_CHAOS_FACTOR: 400,
    SUPERBOSS_RUSH_POWER: 3.0,
    SUPERBOSS_RUSH_DURATION: 1.5,
    SUPERBOSS_STALK_SPEED: 0.3,

    // Basic movement
    BASIC_SPEED_MULTIPLIER: 2.6,
    WALK_SWAY_STRENGTH: 8,
  };

  /**
   * Performance Optimization Constants
   */
  const PERF_CONSTANTS = {
    TRIG_CACHE_SIZE: 1000,
    GRADIENT_CACHE_SIZE: 100,
    MAX_PARTICLES: 500,
    MAX_BLOOD_STAINS: 200,
    MAX_FOOTSTEPS: 300,
    MAX_BULLETS_PER_SHOT: 16,
  };

  /**
   * Gameplay Balance Constants
   */
  const GAME_CONSTANTS = {
    PLAYER_BULLET_BASE_SPEED: 720,
    PLAYER_BULLET_BASE_SIZE: 4,
    ENEMY_BULLET_BASE_SPEED: 200,
    ENEMY_BULLET_MAX_SPEED: 350,

    // Player Movement
    PLAYER_MAX_SPEED: 500,
    PLAYER_SPRINT_MULTIPLIER: 1.6,
    PLAYER_ADRENALINE_MULTIPLIER: 1.2,
    PLAYER_ACCELERATION: 4,
    PLAYER_FRICTION: 6,
    PLAYER_WAVE_SPEED_BONUS: 0.4,
    PLAYER_FOOTSTEP_SPEED_THRESHOLD: 30,
    PLAYER_FOOTSTEP_INTERVAL: 0.25,
    PLAYER_FOOTSTEP_SPRINT_INTERVAL: 0.15,

    // Weapon Heat System
    HEAT_THRESHOLD_LOW: 0.5,
    HEAT_THRESHOLD_MED: 0.75,
    HEAT_THRESHOLD_HIGH: 0.9,
    HEAT_SPREAD_LOW: 0.03,
    HEAT_SPREAD_MED: 0.06,
    HEAT_SPREAD_HIGH: 0.10,
    HEAT_FIRERATE_MED: 1.15,
    HEAT_FIRERATE_HIGH: 1.3,

    // Mine System
    MINE_MAX_PER_ENEMY: 8,
    MINE_TRIGGER_RADIUS: 35,
    MINE_EXPLOSION_RADIUS: 70,
    MINE_BASE_DAMAGE: 8,
    MINE_FUSE_TIME: 30.0,
    MINE_DROP_INTERVAL: 12.0,
  };

  /**
   * Animation & Visual Effect Timing Constants
   */
  const ANIMATION_CONSTANTS = {
    GAME_START_DURATION: 1800,        // Game start animation duration (ms)
    GAME_START_FADEOUT: 300,          // Game start fadeout duration (ms)
    SCREEN_SHAKE_DURATION: 300,       // Screen shake effect duration (ms)
    PAUSE_SLIDE_DURATION: 300,        // Pause menu slide animation (ms)
    POWERUP_NOTIFICATION_DURATION: 2000, // Powerup notification display time (ms)
    WAVE_ANNOUNCEMENT_DURATION: 3000, // Wave announcement display time (ms)
  };

  /**
   * Difficulty Scaling Constants - Controls wave progression
   */
  const DIFFICULTY_CONSTANTS = {
    BASE_ENEMY_COUNT: 15,             // Starting enemy count (wave 1)
    ENEMY_COUNT_INCREMENT: 1.5,       // Enemies added per wave
    MAX_ENEMY_COUNT: 90,              // Maximum enemies per wave
    ENEMY_SPEED_INCREMENT: 4,         // Speed increase per wave
    ENEMY_DAMAGE_INCREMENT_WAVES: 5,  // Waves between damage increases
    BOSS_WAVE_INTERVAL: 5,            // Mini-boss every N waves
    SUPER_BOSS_WAVE_INTERVAL: 10,    // Super-boss every N waves
    MINI_BOSS_HP_MULTIPLIER: 2,       // Mini-boss health multiplier
    SUPER_BOSS_HP_MULTIPLIER: 9,      // Super-boss health multiplier
  };

  /**
   * Color Palette Constants - Theme colors for consistency
   */
  const THEME_CONSTANTS = {
    PRIMARY_TEAL: 'rgba(90,242,199',     // Main accent color (without closing paren for opacity flexibility)
    PLAYER_COLOR: '#5af2c7',              // Player character color
    BACKGROUND_COLOR: '#0b0d10',          // Arena background
    HUD_COLOR: 'rgba(200,200,200,0.8)',  // HUD text color
    WARNING_COLOR: 'rgba(255,100,100',    // Danger/warning color
    CRYSTAL_COMMON: 'rgba(90,242,199',    // Common crystal drops
    CRYSTAL_RARE: 'rgba(255,215,0',       // Rare crystal drops (gold)
  };

  // ============================================================
  // SECTION: INPUT & CONTROLS
  // ============================================================
  // ===== Input =====
  const keys = new Set();
  let mouseX = 0, mouseY = 0, mouseDown = false;
  
  // Mobile touch support with improved handling
  let touchMove = {x: 0, y: 0, startX: 0, startY: 0, active: false, id: null};
  let touchShoot = {x: 0, y: 0, active: false, id: null};
  let touchZonesElement = null;
  let virtualJoystick = null;
  let joystickKnob = null;
  let touchIndicatorLeft = null;
  let touchIndicatorRight = null;
  window.addEventListener('keydown', e => {
    if (e.code === 'KeyP' || e.code === 'Escape'){ togglePause(); return; }
    if (e.code === 'F11'){ 
      e.preventDefault();
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
      return; 
    }
    keys.add(e.code);
  });
  window.addEventListener('keyup', e => keys.delete(e.code));
  canvas.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
  canvas.addEventListener('mousedown', () => { mouseDown = true; initAudio(); });
  window.addEventListener('mouseup', () => mouseDown = false);
  canvas.addEventListener('contextmenu', e => e.preventDefault());
  
  // Improved touch controls for mobile
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    initAudio();
    
    // Handle multiple touches
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];
      // Use canvas bounds for more accurate detection
      const rect = canvas.getBoundingClientRect();
      const screenMidpoint = rect.width / 2;
      
      if (touch.clientX < screenMidpoint && !touchMove.active) {
        // Left side - movement
        touchMove.active = true;
        touchMove.id = touch.identifier;
        touchMove.startX = touch.clientX;
        touchMove.startY = touch.clientY;
        touchMove.x = touch.clientX;
        touchMove.y = touch.clientY;
        
        // Show virtual joystick at touch position
        if (virtualJoystick) {
          virtualJoystick.style.display = 'block';
          virtualJoystick.style.left = touch.clientX + 'px';
          virtualJoystick.style.top = touch.clientY + 'px';
          virtualJoystick.style.transform = 'translate(-50%, -50%)';
          virtualJoystick.style.bottom = 'auto'; // Reset bottom positioning
        }
        
        // Show touch indicator
        if (touchIndicatorLeft) {
          touchIndicatorLeft.style.left = touch.clientX + 'px';
          touchIndicatorLeft.style.top = touch.clientY + 'px';
          touchIndicatorLeft.classList.add('active');
        }
      } else if (touch.clientX >= screenMidpoint && !touchShoot.active) {
        // Right side - shooting/aiming
        touchShoot.active = true;
        touchShoot.id = touch.identifier;
        touchShoot.x = touch.clientX;
        touchShoot.y = touch.clientY;
        // Convert to canvas coordinates
        mouseX = (touch.clientX - rect.left) * (canvas.width / rect.width);
        mouseY = (touch.clientY - rect.top) * (canvas.height / rect.height);
        mouseDown = true;
        
        // Show touch indicator
        if (touchIndicatorRight) {
          touchIndicatorRight.style.left = touch.clientX + 'px';
          touchIndicatorRight.style.top = touch.clientY + 'px';
          touchIndicatorRight.classList.add('active');
        }
      }
    }
  });
  
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];
      
      if (touchMove.active && touch.identifier === touchMove.id) {
        touchMove.x = touch.clientX;
        touchMove.y = touch.clientY;
        
        // Update joystick knob position
        if (joystickKnob && virtualJoystick) {
          const dx = touch.clientX - touchMove.startX;
          const dy = touch.clientY - touchMove.startY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const maxDistance = 40; // Max joystick movement
          
          if (distance > maxDistance) {
            const angle = Math.atan2(dy, dx);
            joystickKnob.style.left = (50 + (Math.cos(angle) * maxDistance * 100 / 120)) + '%';
            joystickKnob.style.top = (50 + (Math.sin(angle) * maxDistance * 100 / 120)) + '%';
          } else {
            joystickKnob.style.left = (50 + (dx * 100 / 120)) + '%';
            joystickKnob.style.top = (50 + (dy * 100 / 120)) + '%';
          }
        }
        
        // Update touch indicator
        if (touchIndicatorLeft) {
          touchIndicatorLeft.style.left = touch.clientX + 'px';
          touchIndicatorLeft.style.top = touch.clientY + 'px';
        }
      } else if (touchShoot.active && touch.identifier === touchShoot.id) {
        touchShoot.x = touch.clientX;
        touchShoot.y = touch.clientY;
        // Convert to canvas coordinates
        mouseX = (touch.clientX - rect.left) * (canvas.width / rect.width);
        mouseY = (touch.clientY - rect.top) * (canvas.height / rect.height);
        
        // Update touch indicator
        if (touchIndicatorRight) {
          touchIndicatorRight.style.left = touch.clientX + 'px';
          touchIndicatorRight.style.top = touch.clientY + 'px';
        }
      }
    }
  });
  
  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    
    // Check which touch ended
    let moveEnded = true;
    let shootEnded = true;
    
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];
      if (touch.identifier === touchMove.id) moveEnded = false;
      if (touch.identifier === touchShoot.id) shootEnded = false;
    }
    
    if (moveEnded && touchMove.active) {
      touchMove.active = false;
      touchMove.id = null;
      
      // Hide virtual joystick and reset knob
      if (virtualJoystick) {
        virtualJoystick.style.display = 'none';
      }
      if (joystickKnob) {
        joystickKnob.style.left = '50%';
        joystickKnob.style.top = '50%';
      }
      if (touchIndicatorLeft) {
        touchIndicatorLeft.classList.remove('active');
      }
    }
    
    if (shootEnded && touchShoot.active) {
      touchShoot.active = false;
      touchShoot.id = null;
      mouseDown = false;
      
      if (touchIndicatorRight) {
        touchIndicatorRight.classList.remove('active');
      }
    }
  });
  
  // Prevent default touch behavior on canvas
  canvas.addEventListener('touchcancel', e => {
    e.preventDefault();
    touchMove.active = false;
    touchMove.id = null;
    touchShoot.active = false;
    touchShoot.id = null;
    mouseDown = false;
    
    // Hide all indicators
    if (virtualJoystick) virtualJoystick.style.display = 'none';
    if (joystickKnob) {
      joystickKnob.style.left = '50%';
      joystickKnob.style.top = '50%';
    }
    if (touchIndicatorLeft) touchIndicatorLeft.classList.remove('active');
    if (touchIndicatorRight) touchIndicatorRight.classList.remove('active');
  });
  
  // ===== Mobile Controls Detection & Setup =====
  const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
  
  // Initialize mobile UI elements
  touchZonesElement = document.getElementById('touchZones');
  virtualJoystick = document.getElementById('virtualJoystick');
  joystickKnob = document.getElementById('joystickKnob');
  touchIndicatorLeft = document.getElementById('touchIndicatorLeft');
  touchIndicatorRight = document.getElementById('touchIndicatorRight');
  const orientationWarning = document.getElementById('orientationWarning');
  
  if (isMobile) {
    // Show mobile controls and touch zones
    if (mobileControls) mobileControls.style.display = 'block';
    if (touchZonesElement) touchZonesElement.style.display = 'block';
    
    // Add mobile-specific styles and prevent scrolling
    document.body.style.overflow = 'hidden';
    document.body.style.touchAction = 'none';
    document.body.style.position = 'fixed';
    document.body.style.width = '100%';
    document.body.style.height = '100%';
    canvas.style.touchAction = 'none';
    
    // Prevent iOS bounce scrolling
    document.addEventListener('touchmove', function(e) {
      e.preventDefault();
    }, { passive: false });
    
    // Handle orientation changes
    function checkOrientation() {
      const isPortrait = window.innerHeight > window.innerWidth;
      
      if (isPortrait && isMobile) {
        // Show warning and pause game
        if (orientationWarning) {
          orientationWarning.classList.add('show');
        }
        if (game && game.state === STATE.RUN) {
          setState(game, STATE.PAUSE);
        }
        return false; // Not in correct orientation
      } else {
        // Hide warning and allow game
        if (orientationWarning) {
          orientationWarning.classList.remove('show');
        }
        // Update canvas size on orientation change
        if (game) {
          resize();
        }
        return true; // In correct orientation
      }
    }
    
    // Check orientation on load and changes
    window.addEventListener('orientationchange', () => {
      setTimeout(checkOrientation, 100); // Delay to let orientation settle
    });
    window.addEventListener('resize', () => {
      if (isMobile) checkOrientation();
    });
    
    // Initial orientation check
    setTimeout(() => {
      checkOrientation();
    }, 100);
    
    // Try to lock orientation if API is available (works on some Android devices)
    if (screen.orientation && screen.orientation.lock) {
      document.addEventListener('fullscreenchange', () => {
        if (document.fullscreenElement) {
          screen.orientation.lock('landscape').catch(() => {
            // Orientation lock not supported (expected on most browsers)
          });
        }
      });
    }
    
    // Show mobile controls
    if (mobileControls) mobileControls.style.display = 'block';
    
    // Sprint button - toggle or hold behavior
    let sprintActive = false;
    sprintBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      sprintActive = true;
      keys.add('ShiftLeft');
      sprintBtn.classList.add('active', 'sprinting');
      initAudio();
    });
    
    sprintBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      e.stopPropagation();
      sprintActive = false;
      keys.delete('ShiftLeft');
      keys.delete('ShiftRight');
      sprintBtn.classList.remove('active', 'sprinting');
    });
    
    // Leap button
    leapBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (game && game.player && game.player.leapReady) {
        keys.add('Space');
        setTimeout(() => keys.delete('Space'), 100); // Quick tap
        initAudio();
      }
    });
    
    // Pause button
    pauseBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (game && (game.state === STATE.RUN || game.state === STATE.PAUSE)) {
        togglePause();
        initAudio();
      }
    });
    
    // Prevent accidental touches from bubbling
    mobileControls.addEventListener('touchstart', (e) => {
      if (e.target.classList.contains('mobile-btn')) {
        e.stopPropagation();
      }
    });
  }

  // ===== Security & Utility Functions =====

  /**
   * Sanitizes text for safe HTML insertion by escaping special characters
   * Prevents XSS attacks by converting <, >, ", ' to HTML entities
   * @param {string} text - Text to sanitize
   * @returns {string} Sanitized text safe for innerHTML
   */
  function sanitizeText(text) {
    if (typeof text !== 'string') return '';
    return text.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;');
  }

  /**
   * Safely parses integer with fallback default value
   * @param {any} value - Value to parse
   * @param {number} defaultValue - Default value if parsing fails (default: 0)
   * @returns {number} Parsed integer or default value
   */
  function safeParseInt(value, defaultValue = 0) {
    const parsed = parseInt(value, 10);
    return isNaN(parsed) ? defaultValue : parsed;
  }

  /**
   * Safely parses float with fallback default value
   * @param {any} value - Value to parse
   * @param {number} defaultValue - Default value if parsing fails (default: 0.0)
   * @returns {number} Parsed float or default value
   */
  function safeParseFloat(value, defaultValue = 0.0) {
    const parsed = parseFloat(value);
    return isNaN(parsed) ? defaultValue : parsed;
  }

  // ============================================================
  // SECTION: PERFORMANCE OPTIMIZATIONS
  // ============================================================

  /** LRU cache for sine calculations (reduces Math.sin calls by ~90%) */
  const sinCache = new Map();
  /** LRU cache for cosine calculations (reduces Math.cos calls by ~90%) */
  const cosCache = new Map();
  /** Maximum cache size before LRU eviction */
  const TRIG_CACHE_SIZE = 1000;

  /**
   * Fast sine calculation with LRU caching
   * @param {number} angle - Angle in radians
   * @returns {number} Sine value
   */
  function fastSin(angle) {
    const key = Math.round(angle * 1000);
    if (!sinCache.has(key)) {
      if (sinCache.size > TRIG_CACHE_SIZE) {
        // LRU eviction - remove oldest entry
        const firstKey = sinCache.keys().next().value;
        sinCache.delete(firstKey);
      }
      sinCache.set(key, Math.sin(key / 1000));
    }
    return sinCache.get(key);
  }

  /**
   * Fast cosine calculation with LRU caching
   * @param {number} angle - Angle in radians
   * @returns {number} Cosine value
   */
  function fastCos(angle) {
    const key = Math.round(angle * 1000);
    if (!cosCache.has(key)) {
      if (cosCache.size > TRIG_CACHE_SIZE) {
        // LRU eviction - remove oldest entry
        const firstKey = cosCache.keys().next().value;
        cosCache.delete(firstKey);
      }
      cosCache.set(key, Math.cos(key / 1000));
    }
    return cosCache.get(key);
  }

  /**
   * Fast distance comparison using squared distance (avoids sqrt)
   * @param {number} x1 - First point X
   * @param {number} y1 - First point Y
   * @param {number} x2 - Second point X
   * @param {number} y2 - Second point Y
   * @param {number} maxDist - Maximum distance threshold
   * @returns {boolean} True if distance is less than or equal to maxDist
   */
  function fastDistanceCheck(x1, y1, x2, y2, maxDist) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const distSq = dx * dx + dy * dy;
    return distSq <= maxDist * maxDist;
  }

  /** Queue for batched DOM updates */
  let domUpdateQueue = [];
  /** Flag to track if DOM update is scheduled */
  let domUpdateScheduled = false;

  /**
   * Queues a DOM update to be executed in the next animation frame
   * Batches multiple updates to reduce reflows
   * @param {Function} fn - Function to execute for DOM update
   */
  function queueDOMUpdate(fn) {
    domUpdateQueue.push(fn);
    if (!domUpdateScheduled) {
      domUpdateScheduled = true;
      requestAnimationFrame(() => {
        for (const update of domUpdateQueue) {
          update();
        }
        domUpdateQueue = [];
        domUpdateScheduled = false;
      });
    }
  }

  /** Canvas state caching to avoid redundant context calls */
  let lastFillStyle = '';
  let lastStrokeStyle = '';
  let lastGlobalAlpha = 1;
  let lastLineWidth = 1;

  /**
   * Sets canvas fill style with caching to avoid redundant calls
   * @param {string} style - CSS color string
   */
  function setFillStyle(style) {
    // Validate style to prevent crashes
    let validStyle = '#ff0000'; // Default fallback
    if (style && style !== '' && style !== 'undefined' && style !== 'null' && style !== 'transparent' && style !== 'none') {
      validStyle = style;
    }

    if (lastFillStyle !== validStyle) {
      ctx.fillStyle = validStyle;
      lastFillStyle = validStyle;
    }
  }

  /**
   * Sets canvas stroke style with caching
   * @param {string} style - CSS color string
   */
  function setStrokeStyle(style) {
    if (lastStrokeStyle !== style) {
      ctx.strokeStyle = style;
      lastStrokeStyle = style;
    }
  }

  /**
   * Sets canvas global alpha with caching
   * @param {number} alpha - Alpha value (0-1)
   */
  function setGlobalAlpha(alpha) {
    if (lastGlobalAlpha !== alpha) {
      ctx.globalAlpha = alpha;
      lastGlobalAlpha = alpha;
    }
  }

  /**
   * Sets canvas line width with caching
   * @param {number} width - Line width in pixels
   */
  function setLineWidth(width) {
    if (lastLineWidth !== width) {
      ctx.lineWidth = width;
      lastLineWidth = width;
    }
  }

  /**
   * Resets canvas rendering state cache and actual canvas context
   * Call at start of each frame to prevent state accumulation bugs
   */
  function resetRenderState() {
    lastFillStyle = '';
    lastStrokeStyle = '';
    lastGlobalAlpha = 1;
    lastLineWidth = 1;
    // Also reset actual canvas state to ensure no bad state persists
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#ffffff';
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
  }

  // Performance monitoring and adaptive quality
  let frameTimeHistory = [];
  let performanceLevel = 1.0; // 1.0 = full quality, 0.5 = reduced quality

  /**
   * Updates adaptive performance level based on frame time history
   * Reduces particle quality if frame time exceeds 25ms (40 FPS)
   * Increases quality if frame time is under 18ms (55+ FPS)
   * @param {number} frameTime - Frame time in milliseconds
   */
  function updatePerformanceLevel(frameTime) {
    frameTimeHistory.push(frameTime);
    if (frameTimeHistory.length > 10) {
      frameTimeHistory.shift();
      const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b) / frameTimeHistory.length;
      const targetFrameTime = 16.67; // 60 FPS

      if (avgFrameTime > targetFrameTime * 1.5) {
        performanceLevel = Math.max(0.3, performanceLevel - 0.1);
      } else if (avgFrameTime < targetFrameTime * 1.1) {
        performanceLevel = Math.min(1.0, performanceLevel + 0.05);
      }
    }
  }

  /**
   * Determines whether to spawn a new particle based on performance budget
   * Returns false if particle limit reached or performance is degraded
   * @returns {boolean} True if particle should be spawned
   */
  function shouldSpawnParticle() {
    // Use the counter for O(1) performance instead of O(n)
    if (activeParticleCount >= MAX_PARTICLES) return false;
    return Math.random() < performanceLevel;
  }

  /**
   * Transitions game to OVER state and displays game over screen with stats
   * Calculates session statistics, updates high scores, and shows new records
   * @param {Object} g - Game state object
   */
  function triggerGameOver(g) {
    g.state = STATE.OVER;

    // Calculate session stats
    const minutes = Math.floor(g.t / 60);
    const seconds = Math.floor(g.t % 60);
    const accuracy = g.shotsFired > 0 ? Math.round((g.shotsHit / g.shotsFired) * 100) : 0;

    // Update high scores and get list of new records
    const newRecords = updateHighScores(g);

    // Update session stats display
    document.getElementById('goWave').textContent = g.wave.toString();
    document.getElementById('goKills').textContent = g.kills.toString();
    document.getElementById('goTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    document.getElementById('goCombo').textContent = g.highestCombo + 'x';
    document.getElementById('goAccuracy').textContent = accuracy + '%';

    // Show/hide new record banner
    const recordBanner = document.getElementById('newRecordBanner');
    const recordsList = document.getElementById('recordsList');
    if (newRecords.length > 0) {
      recordBanner.style.display = 'block';
      // Use safe DOM manipulation instead of innerHTML
      recordsList.replaceChildren(...newRecords.map(r => {
        const div = document.createElement('div');
        div.textContent = ` ${r}`;
        return div;
      }));
    } else {
      recordBanner.style.display = 'none';
    }

    // Update career stats display
    const totalMinutes = Math.floor(saveData.totalPlayTime / 60);
    const totalHours = Math.floor(totalMinutes / 60);
    const remainingMinutes = totalMinutes % 60;

    document.getElementById('statsBestWave').textContent = saveData.highestWave.toString();
    document.getElementById('statsBestKills').textContent = saveData.bestKills.toString();
    document.getElementById('statsBestCombo').textContent = saveData.bestCombo + 'x';
    document.getElementById('statsTotalKills').textContent = saveData.totalKills.toString();
    document.getElementById('statsGamesPlayed').textContent = saveData.gamesPlayed.toString();
    document.getElementById('statsTotalTime').textContent = `${totalHours}h ${remainingMinutes}m`;

    gameOverPanel.style.display = 'block';
    gameOverPanel.classList.add('active');
    gameOverPanel.style.animation = 'gameOverDramaticEntry 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards, glassUnderglow 8s ease-in-out infinite';

    // Hide HUD when game over
    const hud = document.getElementById('hud');
    hud.style.animation = 'hudFadeIn 0.3s ease-out reverse forwards';

    // Hide mobile controls during game over
    if (isMobile && mobileControls) {
      mobileControls.style.display = 'none';
    }
  }
  
  /**
   * Generates formatted list of active upgrades for pause menu display
   * @returns {Array<string>} Array of upgrade names with stack counts
   */
  function createUpgradesDisplay() {
    if (!game || !game.player) return '';

    const upgrades = [];
    const player = game.player;
    
    // Check static powerup upgrades
    for (const [upgradeId, count] of player.upgradeCounts) {
      const powerup = staticPowerups.find(p => p.id === upgradeId);
      if (powerup && count > 0) {
        const stackText = count > 1 ? ` (${count})` : '';
        upgrades.push(`${powerup.name}${stackText}`);
      }
    }
    
    // Check temporary effects
    if (player.activeEffects && player.activeEffects.size > 0) {
      for (const [effect, shots] of player.activeEffects) {
        if (shots > 0) {
          const effectName = effect.charAt(0).toUpperCase() + effect.slice(1);
          upgrades.push(`${effectName} (${shots} shots)`);
        }
      }
    }
    
    // Check pattern multipliers  
    if (player.patternMultipliers && player.patternMultipliers.size > 0) {
      for (const [pattern, shots] of player.patternMultipliers) {
        if (shots > 0) {
          const patternName = pattern.charAt(0).toUpperCase() + pattern.slice(1);
          upgrades.push(`${patternName} Pattern (${shots} shots)`);
        }
      }
    }
    
    // Check legacy upgrades
    if (player.upgradeShots > 0) {
      upgrades.push(`Dual Shot (${player.upgradeShots} shots)`);
    }
    
    return upgrades.length > 0 ? upgrades : ['No upgrades acquired'];
  }

  // ===== Audio (procedural, no assets) =====
  let audioCtx = null;
  let audioAvailable = true;
  let audioFailureNotified = false;

  /**
   * Initializes Web Audio API context with graceful degradation
   * Handles browser compatibility (webkit prefix) and mobile resume requirements
   * Sets audioAvailable flag to false on failure for graceful degradation
   */
  function initAudio(){
    try {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // Resume on iOS Safari
        audioCtx.resume && audioCtx.resume();
        audioAvailable = true;
      }
    } catch (audioError) {
      // Audio initialization failed - graceful degradation
      audioAvailable = false;
      audioCtx = null;

      // Notify user once (don't spam)
      if (!audioFailureNotified) {
        audioFailureNotified = true;
        // Note: User will still see this in browser console if they check,
        // but won't interrupt gameplay with alerts
      }
    }
  }

  /**
   * Plays a procedural synthesized sound effect using Web Audio API
   * @param {number} freq - Frequency in Hz (default: 440)
   * @param {number} duration - Duration in seconds (default: 0.05)
   * @param {string} type - Oscillator type: 'square', 'sine', 'sawtooth', 'triangle' (default: 'square')
   * @param {number} gain - Volume level 0.0-1.0 (default: 0.02)
   */
  function beep(freq=440, duration=0.05, type='square', gain=0.02){
    // Early return if audio not available or failed to initialize
    if (!audioCtx || !audioAvailable) return;

    try {
      // Resume audio context if suspended (common on mobile after page load)
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      g.gain.value = gain;
      osc.connect(g).connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      osc.start(now);
      osc.stop(now + duration);
    } catch (beepError) {
      // Audio playback failed - mark audio as unavailable to prevent future attempts
      audioAvailable = false;
      // Game continues without audio (graceful degradation)
    }
  }

  /** Plays player weapon fire sound effect (680Hz square wave) */
  function shootSound(){ beep(680, 0.04, 'square', 0.1); }

  /** Plays enemy hit sound effect (220Hz sawtooth) */
  function hitSound(){ beep(220, 0.07, 'sawtooth', 0.15); }

  /** Plays critical hit sound effect (400Hz triangle wave) */
  function criticalHitSound(){ beep(400, 0.05, 'triangle', 0.18); }

  /** Plays double-pulse sound when stamina depletes (300Hz + 280Hz triangle) */
  function staminaDepletedSound(){
    beep(300, 0.06, 'triangle', 0.12);
    setTimeout(() => beep(280, 0.06, 'triangle', 0.10), 100); // Second pulse after 100ms
  }

  /** Plays player damage sound effect (120Hz sine wave) */
  function hurtSound(){ beep(120, 0.1, 'sine', 0.2); }

  /** Plays wave completion/start sound (440Hz triangle) */
  function waveSound(){ beep(440, 0.12, 'triangle', 0.1); }

  /**
   * Plays procedurally-generated enemy death sound based on enemy size
   * Larger enemies produce deeper, longer sounds with higher volume
   * @param {Object} enemy - Enemy entity with radius property
   */
  function enemyDeathSound(enemy) {
    // Different death sounds based on enemy type and size
    const baseFreq = enemy.r > 20 ? 60 :   // Super bosses - very deep
                     enemy.r > 16 ? 90 :   // Large enemies (tanks, bosses) - deep
                     enemy.r < 12 ? 200 :  // Small enemies (fast, zerglings) - high  
                     160;                  // Normal enemies - medium
    
    const variation = (Math.random() - 0.5) * 30; // 15 Hz variation for more character
    const freq = baseFreq + variation;
    const duration = enemy.r > 16 ? 0.18 : enemy.r < 12 ? 0.06 : 0.1; // Size-based duration
    const volume = Math.min(0.15, 0.08 + enemy.r * 0.003); // Volume scales with size
    
    beep(freq, duration, 'sawtooth', volume);
  }

  // ===== Static Powerups =====
  const staticPowerups = [
    {id: 'speedBoost', name: 'Speed Boost', desc: '+12.5% movement speed', apply: (p) => p.speed *= 1.125},
    {id: 'healthRegen', name: 'Health Regen', desc: '+0.5 HP/sec regeneration', apply: (p) => p.healthRegenRate = (p.healthRegenRate || 0) + 0.5},
    {id: 'maxHealth', name: 'Max Health', desc: '+30 maximum health', apply: (p) => { p.maxHp += 30; p.hp = Math.min(p.hp + 30, p.maxHp); }},
    {id: 'staminaBoost', name: 'Stamina Boost', desc: '+25% stamina regeneration', apply: (p) => p.staminaRegen *= 1.25},
    {id: 'rapidFire', name: 'Rapid Fire', desc: '12.5% faster shooting', apply: (p) => p.fireDelay *= 0.875},
    {id: 'bulletSize', name: 'Bullet Size', desc: '25% larger bullets', apply: (p) => p.bulletSize = 1.25},
    {id: 'bulletSpeed', name: 'Bullet Speed', desc: '25% faster bullets', apply: (p) => p.bulletSpeed = 1.25},
    {id: 'piercingShot', name: 'Piercing Shot', desc: '+1 bullet piercing', apply: (p) => p.piercingCount = (p.piercingCount || 0) + 1},
    {id: 'shield', name: 'Shield', desc: '+25% damage reduction', apply: (p) => p.damageReduction = Math.min(0.9, p.damageReduction + 0.25)},
    {id: 'knockbackImmune', name: 'Knockback Resistance', desc: '+50% knockback reduction', apply: (p) => p.knockbackResistance = (p.knockbackResistance || 0) + 0.5},
    {id: 'magneticCrystals', name: 'Magnetic Crystals', desc: '+80px attraction range', apply: (p) => p.magneticRange = (p.magneticRange || 0) + 80},
    {id: 'lucky', name: 'Lucky', desc: '+20% crystal drop rate', apply: (p) => p.luckyBonus = (p.luckyBonus || 0) + 0.20},
    {id: 'dashCooldown', name: 'Dash Cooldown', desc: '-15% dash cooldown', apply: (p) => p.dashCooldownReduction = (p.dashCooldownReduction || 0) + 0.15},
    {id: 'criticalChance', name: 'Critical Strike', desc: '+10% critical hit chance', apply: (p) => p.criticalChance = Math.min(0.5, (p.criticalChance || 0) + 0.1)},
    {id: 'vampire', name: 'Vampire', desc: '+0.5 HP per enemy killed', apply: (p) => p.vampiricHealing = (p.vampiricHealing || 0) + 0.5},
    {id: 'adrenaline', name: 'Adrenaline', desc: '+20% speed for 3s after damage', apply: (p) => p.adrenalineBoost = true},
    {id: 'efficient', name: 'Efficient', desc: '+5% chance shots don\'t consume ammo', apply: (p) => p.ammoEfficiency = Math.min(0.50, (p.ammoEfficiency || 0) + 0.05)},
    {id: 'heatSink', name: 'Heat Sink', desc: '+25% heat dissipation', apply: (p) => p.heatDissipation *= 1.25},
    {id: 'coolantSystem', name: 'Coolant System', desc: '-20% heat per shot', apply: (p) => p.heatEfficiencyMod *= 0.8},
    {id: 'extendedMagazine', name: 'Extended Magazine', desc: '+25% max heat capacity', apply: (p) => { p.maxHeat *= 1.25; }}
  ];

  // ===== Powerup Notification =====
  function showPowerupNotification(powerupName) {
    powerupNotification.textContent = powerupName.toUpperCase();
    powerupNotification.style.display = 'block';
    powerupNotification.style.animation = 'none';
    
    // Choose animation based on content type
    let animationName = 'powerupPulse';
    let duration = 3000;
    
    if (powerupName.includes('BOSS')) {
      animationName = 'bossWaveEntry';
      duration = 4000;
    } else if (powerupName.includes('WAVE')) {
      animationName = 'waveDramaticEntry';
      duration = 3500;
    }
    
    // Force reflow to restart animation
    powerupNotification.offsetHeight;
    powerupNotification.style.animation = `${animationName} ${duration/1000}s cubic-bezier(0.34, 1.56, 0.64, 1) forwards`;
    
    // Hide after animation completes
    setTimeout(() => {
      powerupNotification.style.display = 'none';
    }, duration);
  }

  // ===== Wave Announcement =====
  let waveAnnouncementTimeouts = [];
  let nextWaveTimeoutId = null; // Track wave transition timeout
  let waveTransitionInProgress = false; // Prevent duplicate wave transitions
  
  function showWaveAnnouncement(waveNumber, isBossWave = false) {
    // Don't show if game is paused or in powerup selection
    if (game && (game.state === STATE.POWERUP || game.state === STATE.PAUSE || game.state === STATE.OVER)) {
      return;
    }
    
    // CRITICAL: If already showing, don't restart animation
    if (waveAnnouncement.dataset.active === 'true' || waveAnnouncement.style.display !== 'none') {
      // Wave announcement already active, skipping
      return;
    }
    
    // Clear any existing timeouts to prevent overlapping animations
    waveAnnouncementTimeouts.forEach(timeout => clearTimeout(timeout));
    waveAnnouncementTimeouts = [];
    
    // Force clean the element state first
    waveAnnouncement.style.animation = '';
    waveAnnouncement.style.display = 'none';
    waveAnnouncement.style.opacity = '0';
    waveAnnouncement.dataset.active = 'false';
    void waveAnnouncement.offsetHeight; // Force reflow to clear animation state
    
    const waveNumberEl = waveAnnouncement.querySelector('.wave-number');
    const subtitleEl = waveAnnouncement.querySelector('.wave-subtitle');
    
    waveNumberEl.textContent = `WAVE ${waveNumber}`;
    
    // Set subtitle based on wave number and type
    if (isBossWave) {
      subtitleEl.textContent = 'SUPER BOSS INCOMING!';
    } else if (waveNumber === 3) {
      subtitleEl.textContent = 'HEAVY ENEMIES UNLOCKED!';
    } else {
      subtitleEl.textContent = 'GET READY';
    }
    
    // Apply boss wave styling
    if (isBossWave) {
      waveAnnouncement.classList.add('boss-wave');
    } else {
      waveAnnouncement.classList.remove('boss-wave');
    }
    
    // Use requestAnimationFrame for clean start
    requestAnimationFrame(() => {
      // Final state check
      if (game && (game.state === STATE.POWERUP || game.state === STATE.PAUSE || game.state === STATE.OVER)) {
        return;
      }
      
      waveAnnouncement.style.display = 'block';
      waveAnnouncement.style.opacity = '0'; // Start from 0 opacity
      waveAnnouncement.dataset.active = 'true';
      
      // Apply animation on next frame
      requestAnimationFrame(() => {
        // Include both the entry animation and the continuous rainbow glow
        const glowAnimation = isBossWave ? 'bossRainbowGlow 2s ease-in-out infinite' : 'rainbowGlow 3s ease-in-out infinite';
        waveAnnouncement.style.animation = `waveCardEntry 1.2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards, ${glowAnimation}`;
        waveAnnouncement.style.opacity = ''; // Let animation control opacity
      });
    });
    
    // Hide after showing
    const hideTimeout = setTimeout(() => {
      // Only hide if still active and showing
      if (waveAnnouncement.dataset.active === 'true' && waveAnnouncement.style.display !== 'none') {
        if (game && game.state === STATE.RUN) {
          waveAnnouncement.style.animation = 'waveCardExit 0.4s ease-out forwards';
          const removeTimeout = setTimeout(() => {
            waveAnnouncement.style.display = 'none';
            waveAnnouncement.style.opacity = '';
            waveAnnouncement.dataset.active = 'false';
            waveAnnouncement.style.animation = '';
          }, 400);
          waveAnnouncementTimeouts.push(removeTimeout);
        } else {
          // If not in RUN state, hide immediately
          waveAnnouncement.style.display = 'none';
          waveAnnouncement.style.opacity = '';
          waveAnnouncement.dataset.active = 'false';
          waveAnnouncement.style.animation = '';
        }
      }
    }, 2500);
    waveAnnouncementTimeouts.push(hideTimeout);
  }

  // ===== Starting Loadout Selection =====
  function showStartingLoadoutDialog() {
    // Set game to POWERUP state to prevent game loop updates
    if (game && game.state === STATE.RUN) {
      setState(game, STATE.POWERUP);
    }

    // Use the SAME powerup system as level-ups (staticPowerups array)
    const p = game.player;
    const availablePowerups = staticPowerups.filter(powerup => {
      // Exclude maxed upgrades
      if (powerup.id === 'shield' && (p.damageReduction || 0) >= 0.9) return false;
      if (powerup.id === 'knockbackImmune' && (p.knockbackResistance || 0) >= 1.0) return false;
      if (powerup.id === 'criticalChance' && (p.criticalChance || 0) >= 0.5) return false;
      if (powerup.id === 'efficient' && (p.ammoEfficiency || 0) >= 0.50) return false;
      return true;
    });

    // Select 3 unique random powerups (same as level-up system)
    const selected = [];
    const availableIndices = [...Array(availablePowerups.length).keys()];

    while (selected.length < 3 && availableIndices.length > 0) {
      const randomIndex = Math.floor(Math.random() * availableIndices.length);
      const powerupIndex = availableIndices.splice(randomIndex, 1)[0];
      selected.push(availablePowerups[powerupIndex]);
    }

    // Populate dialog
    selected.forEach((powerup, i) => {
      powerupTitles[i].textContent = powerup?.name || 'None';
      powerupDescs[i].textContent = powerup?.desc || 'No more powerups';
    });

    // Show dialog
    setTimeout(() => {
      powerupDialog.style.display = 'block';
      powerupDialog.style.animation = 'powerupDialogEntry 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';

      // Animate in powerup options with staggered delays
      const powerupOptionsElements = powerupDialog.querySelectorAll('.powerup-option');
      powerupOptionsElements.forEach((option, index) => {
        option.classList.remove('animate-in');
        setTimeout(() => {
          option.classList.add('animate-in');
        }, 200 + index * 100);
      });
    }, 50);

    // Add click handlers
    const handleChoice = (choice) => {
      const powerup = selected[choice];
      if (powerup) {
        // Add selection animation
        const selectedOption = powerupOptions[choice];
        selectedOption.classList.add('selected');

        // Apply powerup (same as level-up)
        powerup.apply(game.player);

        // Track upgrade count
        const currentCount = game.player.upgradeCounts.get(powerup.id) || 0;
        game.player.upgradeCounts.set(powerup.id, currentCount + 1);

        // Delay dialog close to show selection animation
        setTimeout(() => {
          // Hide dialog with animation and resume game
          powerupDialog.style.animation = 'powerupDialogExit 0.3s ease-out forwards';
          setTimeout(() => {
            powerupDialog.style.display = 'none';
            selectedOption.classList.remove('selected');
            if (game && game.state === STATE.POWERUP) {
              setState(game, STATE.RUN);
            }
            // Show notification
            showPowerupNotification(powerup.name);
          }, 300);
        }, 200);
      }
    };

    // Set up click handlers
    powerupOptions.forEach((option, i) => {
      option.onclick = () => handleChoice(i);
    });
  }

  // ===== Powerup Selection =====
  function showPowerupDialog() {
    // Pause game for powerup selection (different from manual pause)
    if (game && game.state === STATE.RUN) {
      setState(game, STATE.POWERUP);
    }
    
    // Cleanly hide wave announcement if it's showing
    if (waveAnnouncement.dataset.active === 'true' || waveAnnouncement.style.display !== 'none') {
      waveAnnouncementTimeouts.forEach(timeout => clearTimeout(timeout));
      waveAnnouncementTimeouts = [];
      waveAnnouncement.dataset.active = 'false';
      waveAnnouncement.style.animation = 'waveCardExit 0.2s ease-out forwards';
      setTimeout(() => {
        waveAnnouncement.style.display = 'none';
        waveAnnouncement.style.animation = ''; // Clear animation
      }, 200);
    }
    
    // Also ensure game start overlay is hidden
    gameStartOverlay.style.animation = 'none';
    gameStartOverlay.style.opacity = '0';
    
    // Hide powerup notification if it's showing
    powerupNotification.style.animation = 'none';
    powerupNotification.style.display = 'none';
    
    // Filter out maxed upgrades
    const p = game.player;
    const availablePowerups = staticPowerups.filter(powerup => {
      // Shield maxed at 90%
      if (powerup.id === 'shield' && (p.damageReduction || 0) >= 0.9) {
        return false;
      }
      // Knockback resistance maxed at 100%
      if (powerup.id === 'knockbackImmune' && (p.knockbackResistance || 0) >= 1.0) {
        return false;
      }
      // Critical chance maxed at 50%
      if (powerup.id === 'criticalChance' && (p.criticalChance || 0) >= 0.5) {
        return false;
      }
      // Ammo efficiency maxed at 50% (15 stacks of 5% - reasonable cap)
      if (powerup.id === 'efficient' && (p.ammoEfficiency || 0) >= 0.50) {
        return false;
      }
      return true;
    });
    
    // Select 3 unique random powerups (no duplicates in same selection)
    const selected = [];
    const availableIndices = [...Array(availablePowerups.length).keys()]; // [0,1,2,3,4,...]
    
    while (selected.length < 3 && availableIndices.length > 0) {
      const randomIndex = Math.floor(Math.random() * availableIndices.length);
      const powerupIndex = availableIndices.splice(randomIndex, 1)[0];
      selected.push(availablePowerups[powerupIndex]);
    }
    
    // Populate dialog
    // Update powerup options using arrays
    selected.forEach((powerup, i) => {
      powerupTitles[i].textContent = powerup?.name || 'None';
      powerupDescs[i].textContent = powerup?.desc || 'No more powerups';
    });
    
    // Small delay to ensure all other UI is hidden before showing dialog
    setTimeout(() => {
      powerupDialog.style.display = 'block';
      powerupDialog.style.animation = 'powerupDialogEntry 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
      
      // Animate in powerup options with staggered delays
      const powerupOptions = powerupDialog.querySelectorAll('.powerup-option');
      powerupOptions.forEach((option, index) => {
        option.classList.remove('animate-in');
        setTimeout(() => {
          option.classList.add('animate-in');
        }, 200 + index * 100);
      });
    }, 50); // 50ms delay to ensure UI cleanup
    
    // Add click handlers
    const handleChoice = (choice) => {
      const powerup = selected[choice];
      if (powerup) {
        // Add selection animation to clicked option
        const selectedOption = powerupOptions[choice];
        selectedOption.classList.add('selected');
        
        // Apply powerup (stackable)
        powerup.apply(game.player);
        
        // Track upgrade count for pause menu display
        const currentCount = game.player.upgradeCounts.get(powerup.id) || 0;
        game.player.upgradeCounts.set(powerup.id, currentCount + 1);
        
        // Delay dialog close to show selection animation
        setTimeout(() => {
          // Hide dialog with animation and resume game
          powerupDialog.style.animation = 'powerupDialogExit 0.3s ease-out forwards';
          setTimeout(() => {
            powerupDialog.style.display = 'none';
            selectedOption.classList.remove('selected');
            if (game && game.state === STATE.POWERUP) {
              setState(game, STATE.RUN);
            }
            // Show notification after dialog is fully closed
            showPowerupNotification(powerup.name);
          }, 300);
        }, 200);
      }
    };
    
    // Set up click handlers using array
    powerupOptions.forEach((option, i) => {
      option.onclick = () => handleChoice(i);
    });
  }

  // ===== Random Seeded? (not needed here) =====

  // ===== Game State =====
  const STATE = { MENU:0, RUN:1, PAUSE:2, OVER:3, POWERUP:4 };
  let game = null;

  // State transition validation
  function setState(game, newState) {
    if (!game) return false;
    const validTransitions = {
      [STATE.MENU]: [STATE.RUN],
      [STATE.RUN]: [STATE.PAUSE, STATE.POWERUP, STATE.OVER],
      [STATE.PAUSE]: [STATE.RUN, STATE.MENU, STATE.OVER],
      [STATE.POWERUP]: [STATE.RUN],
      [STATE.OVER]: [STATE.MENU]
    };
    if (validTransitions[game.state] && validTransitions[game.state].includes(newState)) {
      game.state = newState;
      return true;
    }
    return false;
  }

  /**
   * Creates a new game state object with all initial values
   * @returns {Object} Complete game state including player, grid, stats, and wave tracking
   */
  function newGame(){
    return {
      state: STATE.MENU,
      width: () => canvas.width,
      height: () => canvas.height,
      t: 0,
      wave: 1,
      kills: 0,
      player: makePlayer(canvas.width/2, canvas.height/2),
      spawnTimer: 0,
      waveActive: false, // Wave in progress
      waveEnemiesSpawned: 0, // Enemies spawned this wave
      waveEnemiesTarget: 15, // Total enemies for current wave
      waveBossesSpawned: 0, // Bosses spawned this wave
      waveBossesTarget: 0, // Target bosses for this wave
      maxEnemies: 30, // Base cap, dynamically scaled
      grid: makeSpatialHash(64),
      difficulty: 1,
      paused: false,
      fpsSamples: [],
      fpsSum: 0, // Running sum for efficient FPS calculation
      invulTime: 0,
      damageFlash: 0, // Red vignette flash timer
      // Juice effects
      timeScale: 1.0, // Time dilation multiplier (1.0 = normal, 0.3 = slow-mo)
      timeScaleTarget: 1.0, // Target timeScale for smooth transitions
      slowMoTimeout: null, // Timeout ID for slow-mo reset
      screenShake: 0, // Screen shake intensity
      screenShakeX: 0, // Screen shake offset X
      screenShakeY: 0, // Screen shake offset Y
      // Stats tracking
      shotsFired: 0,
      shotsHit: 0,
      currentCombo: 0,
      highestCombo: 0,
      comboTimer: 0,
      // Starting loadout
      startingPowerup: null, // Selected starting powerup
    };
  }

  /**
   * Creates a spatial hash grid for O(n) collision detection
   * Divides play area into cells for efficient neighbor queries
   * @param {number} cell - Cell size in pixels (typically 64px)
   * @returns {Object} Spatial hash data structure with insert/query methods
   */
  function makeSpatialHash(cell){
    return {
      cell: cell,
      map: new Map(),
      key(ix,iy){ return (ix << 16) | (iy & 0xFFFF); }, // Numeric key instead of string
      reset(){ this.map.clear(); },
      insert(e){
        const ix = Math.floor(e.x / this.cell);
        const iy = Math.floor(e.y / this.cell);
        const k = this.key(ix,iy);
        let arr = this.map.get(k);
        if (!arr){ arr = []; this.map.set(k, arr); }
        arr.push(e);
        e._cellX = ix; e._cellY = iy;
      },
      near(x,y){
        const ix = Math.floor(x / this.cell);
        const iy = Math.floor(y / this.cell);
        const out = [];
        for (let dx = -1; dx <= 1; dx++){
          for (let dy = -1; dy <= 1; dy++){
            const k = this.key(ix+dx, iy+dy);
            const arr = this.map.get(k);
            if (arr) out.push(...arr);
          }
        }
        return out;
      }
    };
  }

  // ===== Object Pools =====
  // Performance limits defined in PERF_CONSTANTS above
  const MAX_PARTICLES = PERF_CONSTANTS.MAX_PARTICLES;
  const MAX_BLOOD_STAINS = PERF_CONSTANTS.MAX_BLOOD_STAINS;
  const MAX_FOOTSTEPS = PERF_CONSTANTS.MAX_FOOTSTEPS;
  let activeParticleCount = 0; // Used for efficient particle limit checking

  /**
   * Creates an object pool for zero-GC entity management
   * @param {Function} createFn - Factory function to create new pool objects
   * @param {number} initial - Initial pool size (default: 0)
   * @param {number} maxSize - Maximum pool size (default: 1000)
   * @returns {Object} Object pool with spawn/forEach methods
   */
  function makePool(createFn, initial=0, maxSize=1000){
    const items = [];
    for (let i=0;i<initial;i++) items.push(createFn());
    return {
      items,
      spawn(initFn){
        for (let i=0;i<items.length;i++){
          const it = items[i];
          if (!it.alive){
            initFn(it); it.alive = true;
            return it;
          }
        }
        // Check pool size limit
        if (items.length >= maxSize) {
          // Try to reuse any dead item one more time
          const deadItem = items.find(it => !it.alive);
          if (deadItem) {
            initFn(deadItem); deadItem.alive = true;
            return deadItem;
          }
          return null; // Pool is full, cannot spawn
        }
        const it = createFn();
        initFn(it); it.alive = true;
        items.push(it);
        return it;
      }
    };
  }

  // ===== Entities =====
  function makePlayer(x,y){
    return {
      x, y,
      vx:0, vy:0,
      speed: 260,
      radius: 12,
      color: '#00ff00',
      hp: 100,
      maxHp: 100,
      stamina: 100,
      exhausted: 0, // Exhaustion cooldown timer
      ammo: Infinity,
      upgradeShots: 0, // V-formation upgrade shots remaining
      bulletType: 'normal', // Legacy - kept for compatibility 
      bulletTimer: 0, // Legacy - kept for compatibility
      bulletPattern: 'single', // Legacy - kept for compatibility
      patternTimer: 0, // Legacy - kept for compatibility
      // New modular effects system
      activeEffects: new Map(), // Map of effect type -> remaining shots
      // New multiplicative pattern system
      patternMultipliers: new Map(), // Map of pattern type -> remaining shots
      fireDelay: 0.12,
      fireTimer: 0,
      // Weapon overheat system
      heat: 0,
      maxHeat: 100,
      overheated: false,
      heatPerShot: 2, // Base heat per shot (50 shots to overheat)
      heatDissipation: 25, // Heat dissipated per second when not firing
      overheatCooldown: 40, // Heat level to recover to after overheating
      heatEfficiencyMod: 1.0, // Modifier from upgrades
      dashCd: 0, dashReady: true,
      // Emergency leap system
      leapCd: 0, leapReady: true,
      leapDistance: 120, // Distance of leap
      leapSpeed: 1200, // Speed during leap
      // Static powerups
      staticPowerups: [],
      // Upgrade tracking for pause menu display
      upgradeCounts: new Map(),
      healthRegen: false,
      staminaRegen: 1.0,
      bulletSize: 1.0,
      bulletSpeed: 1.0,
      piercingShot: false,
      damageReduction: 0,
      knockbackImmune: false,
      magneticCrystals: false,
      lucky: false,
      healthRegenTimer: 0,
    };
  }

  const bullets = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, r:4, life:0, maxLife: 1.0, 
    type:'normal', pierces:0, bounces:0, homingTarget:null, 
    hitEnemies: new Set(),
    effectSet: new Set() // O(1) effect lookups instead of O(n) array.includes()
  }));

  const enemies = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, r:14, hp:2, speed: 90, touchDmg: 12, color:'#ff5b6e',
    deathTimer: 0, dying: false, originalColor: '#ff5b6e', behavior: 'stalker', isShooter: false
  }));

  const particles = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, life:0, maxLife:0.3, size:2, color:'#ffffff'
  }));

  const pickups = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, type:'upgrade', bounceTimer:0, collected:false
  }));

  const bloodStains = makePool(() => ({
    alive:false, x:0, y:0, life:0, maxLife:6.0, size:2, alpha:1.0, vx:0, vy:0, settled:false
  }));

  const footsteps = makePool(() => ({
    alive:false, x:0, y:0, life:0, maxLife:3.0, size:6, alpha:0.3, angle:0, isPlayer:false, isLeft:false
  }));

  const enemyBullets = makePool(() => ({
    alive:false, x:0, y:0, vx:0, vy:0, r:3, life:0, maxLife:3.0
  }));

  const mines = makePool(() => ({
    alive:false, x:0, y:0, r:8, fuseTime:0, maxFuseTime:30.0, isArmed:false,
    triggerRadius:35, explosionRadius:70, explosionDamage:8, flashTimer:0, 
    isTriggered:false, owner:null
  }));

  // Bullet powerup types
  const bulletPowerups = [
    {type: 'upgrade', color: '#32CD32', shots: 50, name: 'Dual Shot'},
    {type: 'triple', color: '#00BFFF', shots: 50, name: 'Triple Shot'},
    {type: 'quad', color: '#FF1493', shots: 50, name: 'Quad Shot'},
    {type: 'homing', color: '#FFD700', shots: 25, name: 'Homing'},
    {type: 'explosive', color: '#FF4500', shots: 50, name: 'Explosive'},
    {type: 'ricochet', color: '#FF69B4', shots: 50, name: 'Ricochet'},
    {type: 'lightning', color: '#00BFFF', shots: 50, name: 'Lightning'},
    {type: 'freeze', color: '#00CED1', shots: 50, name: 'Freeze Shot'},
    {type: 'shotgun', color: '#8B4513', shots: 50, name: 'Shrapnel'},
    {type: 'cluster', color: '#FFA500', shots: 50, name: 'Cluster'},
    {type: 'seeking', color: '#DC143C', shots: 50, name: 'Seeking'}
  ];

  // Create O(1) lookup map to replace O(n) Array.find() calls
  const bulletPowerupMap = new Map();
  for (const powerup of bulletPowerups) {
    bulletPowerupMap.set(powerup.type, powerup);
  }

  // Pre-compute filtered arrays to eliminate O(n) filter operations
  const nonHomingPowerups = bulletPowerups.filter(bp => bp.type !== 'homing');
  const nonHomingLength = nonHomingPowerups.length;

  // Enemy types for variety
  const enemyTypes = [
    {r:14, hp:1, speed:120, dmg:5, color:'#AAFF00', name:'stalker'}, // yellow-green (medium speed)
    {r:12, hp:1, speed:180, dmg:5, color:'#FF8800', name:'wraith'}, // bright orange (very fast) - increased from 10
    {r:18, hp:3, speed:80, dmg:8, color:'#00CCFF', name:'brute'}, // sky blue (slow)
    {r:14, hp:2, speed:220, dmg:5, color:'#FF2200', name:'swarm'}, // red-orange (blazing fast) - increased from 12
  ];

  // Behavior pools - unlock new behaviors every 2 waves (earlier unlocks for fun)
  const behaviorPools = [
    // Wave 1: Basic behaviors with volatiles (NO bombers)
    ['stalker', 'serpent', 'leaper', 'volatile'],
    // Waves 2-3: Add bombers and more behaviors (2x prowler weight)
    ['stalker', 'serpent', 'prowler', 'prowler', 'berserker', 'leaper', 'volatile', 'bomber'],
    // Waves 4-5: Add juggernauts and dividers (2x prowler weight)
    ['stalker', 'serpent', 'prowler', 'prowler', 'berserker', 'leaper', 'volatile', 'juggernaut', 'divider', 'trapper', 'bomber'],
    // Waves 5-6: Add maniac behavior (2x prowler weight)
    ['stalker', 'serpent', 'prowler', 'prowler', 'berserker', 'maniac', 'leaper', 'volatile', 'juggernaut', 'vortex', 'divider', 'trapper', 'bomber'],
    // Waves 7+: All behaviors (2x prowler weight)
    ['stalker', 'serpent', 'prowler', 'prowler', 'berserker', 'maniac', 'leaper', 'volatile', 'juggernaut', 'vortex', 'divider', 'trapper', 'bomber']
  ];

  // ============================================================
  // ENEMY AI NAMESPACE MODULE
  // ============================================================
  /**
   * Centralized enemy AI system handling spawning, behavior, and rendering
   * Extracted to reduce god-function complexity and improve maintainability
   */
  const EnemyAI = {
    /**
     * Spawns enemy bullets with directional targeting
     * @param {number} x - Starting X position
     * @param {number} y - Starting Y position
     * @param {number} targetX - Target X position
     * @param {number} targetY - Target Y position
     * @param {number} angleOffset - Angle offset in radians (default: 0)
     * @param {number} speedMult - Speed multiplier (default: 1.0)
     */
    spawnBullet(x, y, targetX, targetY, angleOffset = 0, speedMult = 1.0) {
      const baseAngle = Math.atan2(targetY - y, targetX - x) + angleOffset;
      const dx = fastCos(baseAngle), dy = fastSin(baseAngle);
      const speed = Math.min(GAME_CONSTANTS.ENEMY_BULLET_MAX_SPEED, GAME_CONSTANTS.ENEMY_BULLET_BASE_SPEED + game.wave) * speedMult;

      enemyBullets.spawn(b => {
        b.x = x;
        b.y = y;
        b.vx = dx * speed;
        b.vy = dy * speed;
        b.r = 3;
        b.life = 0;
        b.maxLife = 3.0;
        b.alive = true;
      });
    },

    /**
     * Spawns a burst of enemy bullets in rapid succession
     * @param {number} x - Starting X position
     * @param {number} y - Starting Y position
     * @param {number} targetX - Target X position
     * @param {number} targetY - Target Y position
     * @param {number} burstCount - Number of bullets in burst (default: 3)
     */
    spawnBurstFire(x, y, targetX, targetY, burstCount = 3) {
      for (let i = 0; i < burstCount; i++) {
        this.spawnBullet(x, y, targetX, targetY);
      }
    },

    /**
     * Spawns a spread pattern of enemy bullets
     * @param {number} x - Starting X position
     * @param {number} y - Starting Y position
     * @param {number} targetX - Target X position
     * @param {number} targetY - Target Y position
     * @param {number} bulletCount - Number of bullets in spread (default: 3)
     * @param {number} spreadAngle - Total spread angle in radians (default: Math.PI/4)
     */
    spawnSpreadShot(x, y, targetX, targetY, bulletCount = 3, spreadAngle = Math.PI/4) {
      const halfSpread = spreadAngle / 2;
      for (let i = 0; i < bulletCount; i++) {
        const angleOffset = bulletCount === 1 ? 0 :
          -halfSpread + (i / (bulletCount - 1)) * spreadAngle;
        this.spawnBullet(x, y, targetX, targetY, angleOffset);
      }
    },

    /**
     * Draws behavior-specific symbol overlay on enemy
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {Object} e - Enemy entity
     * @param {number} x - Screen X coordinate
     * @param {number} y - Screen Y coordinate
     * @param {number} r - Enemy radius
     */
    drawSymbol(ctx, e, x, y, r) {
      ctx.save();
      ctx.strokeStyle = '#000000';
      ctx.fillStyle = '#000000';
      ctx.lineWidth = Math.max(1, r * 0.15);
      ctx.globalAlpha = 0.9;

      const symbolSize = r * 0.6;

      // Shooters get priority for crosshair symbol
      if (e.isShooter) {
        ctx.lineWidth = Math.max(2, r * 0.15);
        ctx.beginPath();
        ctx.arc(x, y, symbolSize * 0.4, 0, TAU);
        ctx.moveTo(x - symbolSize * 0.6, y);
        ctx.lineTo(x + symbolSize * 0.6, y);
        ctx.moveTo(x, y - symbolSize * 0.6);
        ctx.lineTo(x, y + symbolSize * 0.6);
        ctx.stroke();
        ctx.restore();
        return;
      }

      // Draw based on behavior type
      switch(e.behavior) {
        case 'stalker':
          ctx.beginPath();
          ctx.arc(x, y, symbolSize * 0.25, 0, TAU);
          ctx.fill();
          break;

        case 'volatile':
          ctx.fillStyle = '#000000';
          ctx.lineWidth = Math.max(2, r * 0.15);
          ctx.beginPath();
          ctx.moveTo(x, y - symbolSize * 0.5);
          ctx.lineTo(x, y + symbolSize * 0.1);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(x, y + symbolSize * 0.35, symbolSize * 0.12, 0, TAU);
          ctx.fill();
          break;

        case 'berserker':
          ctx.lineWidth = Math.max(2, r * 0.15);
          for(let i = 0; i < 3; i++) {
            const offset = (i - 1) * symbolSize * 0.3;
            ctx.beginPath();
            ctx.moveTo(x + offset - symbolSize * 0.2, y - symbolSize * 0.3);
            ctx.lineTo(x + offset + symbolSize * 0.2, y);
            ctx.lineTo(x + offset - symbolSize * 0.2, y + symbolSize * 0.3);
            ctx.stroke();
          }
          break;

        case 'vortex':
          ctx.lineWidth = Math.max(1.5, r * 0.12);
          for(let i = 0; i < 3; i++) {
            const angle = (i / 3) * TAU;
            ctx.beginPath();
            ctx.arc(x, y, symbolSize * 0.6, angle, angle + Math.PI * 0.6);
            ctx.stroke();
          }
          break;

        case 'bomber':
          ctx.beginPath();
          ctx.arc(x, y, symbolSize * 0.4, 0, TAU);
          ctx.fill();
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = Math.max(1, r * 0.1);
          ctx.beginPath();
          ctx.moveTo(x + symbolSize * 0.3, y - symbolSize * 0.3);
          ctx.lineTo(x + symbolSize * 0.6, y - symbolSize * 0.6);
          ctx.stroke();
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.arc(x + symbolSize * 0.6, y - symbolSize * 0.6, symbolSize * 0.15, 0, TAU);
          ctx.fill();
          break;

        case 'juggernaut':
          ctx.lineWidth = Math.max(2, r * 0.2);
          ctx.beginPath();
          ctx.moveTo(x, y - symbolSize * 0.6);
          ctx.lineTo(x - symbolSize * 0.5, y - symbolSize * 0.3);
          ctx.lineTo(x - symbolSize * 0.5, y + symbolSize * 0.3);
          ctx.lineTo(x, y + symbolSize * 0.6);
          ctx.lineTo(x + symbolSize * 0.5, y + symbolSize * 0.3);
          ctx.lineTo(x + symbolSize * 0.5, y - symbolSize * 0.3);
          ctx.closePath();
          ctx.stroke();
          break;

        case 'divider':
          ctx.lineWidth = Math.max(2, r * 0.15);
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x - symbolSize * 0.4, y - symbolSize * 0.5);
          ctx.moveTo(x, y);
          ctx.lineTo(x + symbolSize * 0.4, y - symbolSize * 0.5);
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + symbolSize * 0.5);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(x - symbolSize * 0.4, y - symbolSize * 0.5, symbolSize * 0.12, 0, TAU);
          ctx.arc(x + symbolSize * 0.4, y - symbolSize * 0.5, symbolSize * 0.12, 0, TAU);
          ctx.arc(x, y + symbolSize * 0.5, symbolSize * 0.12, 0, TAU);
          ctx.fill();
          break;

        case 'trapper':
          ctx.lineWidth = Math.max(1.5, r * 0.15);
          ctx.beginPath();
          for(let i = 0; i < 6; i++) {
            const angle = (i / 6) * TAU;
            const px = x + Math.cos(angle) * symbolSize * 0.5;
            const py = y + Math.sin(angle) * symbolSize * 0.5;
            if(i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(x, y, symbolSize * 0.15, 0, TAU);
          ctx.fill();
          break;

        case 'serpent':
          ctx.lineWidth = Math.max(2, r * 0.15);
          ctx.beginPath();
          ctx.moveTo(x - symbolSize * 0.6, y);
          ctx.quadraticCurveTo(x - symbolSize * 0.3, y - symbolSize * 0.4, x, y);
          ctx.quadraticCurveTo(x + symbolSize * 0.3, y + symbolSize * 0.4, x + symbolSize * 0.6, y);
          ctx.stroke();
          break;

        case 'prowler':
          ctx.lineWidth = Math.max(2, r * 0.15);
          ctx.beginPath();
          ctx.arc(x - symbolSize * 0.25, y, symbolSize * 0.4, -Math.PI * 0.4, Math.PI * 0.4);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(x + symbolSize * 0.25, y, symbolSize * 0.4, Math.PI * 0.6, Math.PI * 1.4);
          ctx.stroke();
          break;

        case 'leaper':
          ctx.lineWidth = Math.max(2, r * 0.15);
          ctx.beginPath();
          ctx.moveTo(x, y - symbolSize * 0.5);
          ctx.lineTo(x - symbolSize * 0.3, y);
          ctx.moveTo(x, y - symbolSize * 0.5);
          ctx.lineTo(x + symbolSize * 0.3, y);
          ctx.moveTo(x, y - symbolSize * 0.5);
          ctx.lineTo(x, y + symbolSize * 0.5);
          ctx.stroke();
          break;

        case 'maniac':
          ctx.lineWidth = Math.max(2, r * 0.15);
          ctx.strokeStyle = '#000000';
          ctx.beginPath();
          ctx.moveTo(x - symbolSize * 0.4, y - symbolSize * 0.4);
          ctx.lineTo(x + symbolSize * 0.4, y + symbolSize * 0.4);
          ctx.moveTo(x + symbolSize * 0.4, y - symbolSize * 0.4);
          ctx.lineTo(x - symbolSize * 0.4, y + symbolSize * 0.4);
          ctx.stroke();
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.arc(x, y + symbolSize * 0.6, symbolSize * 0.1, 0, TAU);
          ctx.fill();
          break;

        case 'boss':
          ctx.lineWidth = Math.max(2, r * 0.15);
          ctx.strokeStyle = '#000000';
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.moveTo(x, y - symbolSize * 0.6);
          ctx.lineTo(x + symbolSize * 0.5, y);
          ctx.lineTo(x, y + symbolSize * 0.6);
          ctx.lineTo(x - symbolSize * 0.5, y);
          ctx.closePath();
          ctx.stroke();
          break;

        case 'superboss':
          ctx.lineWidth = Math.max(2, r * 0.15);
          ctx.strokeStyle = '#000000';
          ctx.fillStyle = '#000000';
          ctx.beginPath();
          const triRadius = symbolSize * 0.6;
          for(let i = 0; i < 3; i++) {
            const angle = (i / 3) * TAU - Math.PI/2;
            const px = x + Math.cos(angle) * triRadius;
            const py = y + Math.sin(angle) * triRadius;
            if(i === 0) {
              ctx.moveTo(px, py);
            } else {
              ctx.lineTo(px, py);
            }
          }
          ctx.closePath();
          ctx.stroke();
          break;

        default:
          // No symbol for other behaviors
          break;
      }

      ctx.restore();
    },

    // TODO: Extract spawnEnemy() function here (~238 lines)
    // spawn(g, clusterX = null, clusterY = null) { ... }

    // TODO: Extract handleEnemyDeath() function here (~30 lines)
    // handleDeath(enemy, game) { ... }

    // TODO: Extract enemy update loop here (~553 lines from main update())
    // updateAll(enemies, game, player, dt, grid) { ... }
  };

  /**
   * Spawns a new enemy at the edge of the screen or in a cluster
   * @param {Object} g - Game state object
   * @param {number|null} clusterX - X coordinate for cluster spawn, or null for edge spawn
   * @param {number|null} clusterY - Y coordinate for cluster spawn, or null for edge spawn
   */
  function spawnEnemy(g, clusterX = null, clusterY = null){
    const w = g.width(), h = g.height();
    const margin = 20;
    let x=0,y=0;
    
    if (clusterX !== null && clusterY !== null) {
      // Spawn in cluster near the provided coordinates
      const spread = 40;
      x = clusterX + (Math.random() - 0.5) * spread;
      y = clusterY + (Math.random() - 0.5) * spread;
    } else {
      // Normal edge spawn
      const side = (Math.random() * 4) | 0; // Faster than Math.floor
      if (side===0){ x=randRange(margin, w-margin); y=-margin; }
      else if (side===1){ x=randRange(margin, w-margin); y=h+margin; }
      else if (side===2){ x=-margin; y=randRange(margin, h-margin); }
      else { x=w+margin; y=randRange(margin, h-margin); }
    }
    enemies.spawn(e => {
      e.x = x; e.y = y;
      e.vx = 0; e.vy = 0;
      
      // Reset shooter status to defaults (behavior will be set later)
      e.isShooter = false;
      e.shootTimer = 0;
      
      // Select enemy type based on wave with swarm replacement logic
      let type;
      if (Math.random() < 0.3) {
        // 30% chance for swarm throughout the game
        type = enemyTypes.find(t => t.name === 'swarm');
      } else {
        // Normal enemy type selection (excluding swarm)
        const baseTypes = enemyTypes.filter(t => t.name !== 'swarm');
        const availableTypes = Math.min(baseTypes.length, 1 + Math.floor(g.wave/3));
        type = baseTypes[(Math.random() * availableTypes) | 0];
      }
      
      // Apply type stats with difficulty scaling (reduced by 30%)
      const diff = 1 + g.wave * 0.06; // Gentler scaling (was 0.084)
      // Add 10% size variance for visual variety
      const sizeVariance = 0.9 + Math.random() * 0.2; // 0.9 to 1.1
      e.r = type.r * sizeVariance;
      e.hp = Math.ceil(type.hp * diff);
      e.speed = Math.min(500, type.speed * diff * (0.85 + Math.random() * 0.3)); // 15% speed variance, capped at 500
      e.touchDmg = Math.ceil(type.dmg * diff * 0.7); // Additional 30% reduction for damage
      // Add slight color variation for each speed-based color
      const colorVariations = {
        '#AAFF00': ['#99FF00', '#BBFF00', '#AAFF00', '#88FF00'], // Stalker - yellow-green
        '#FF8800': ['#FF7700', '#FF9900', '#FF8800', '#FFAA00'], // Wraith - bright orange  
        '#00CCFF': ['#00BBFF', '#00DDFF', '#00CCFF', '#00AAFF'], // Brute - sky blue
        '#FF2200': ['#FF1100', '#FF3300', '#FF2200', '#FF4400'], // Swarm - red-orange
        '#FF0000': ['#FF0000', '#FF2222', '#EE0000', '#CC0000'], // Overlord - pure red
        '#FFCC00': ['#FFBB00', '#FFDD00', '#FFCC00', '#FFAA00'], // Elite - golden
        '#00FF88': ['#00FF77', '#00FF99', '#00FF88', '#00FFAA'], // Gunners - cyan-green
        '#FF4400': ['#FF3300', '#FF5500', '#FF4400', '#FF6600'], // Volatile - orange-red
        '#CC44FF': ['#BB33FF', '#DD55FF', '#CC44FF', '#AA22FF'], // Juggernaut - magenta
        '#00FFCC': ['#00FFBB', '#00FFDD', '#00FFCC', '#00FFAA'], // Vortex - cyan
        '#FF6600': ['#FF5500', '#FF7700', '#FF6600', '#FF8800'], // Berserker - orange
        '#0088FF': ['#0077FF', '#0099FF', '#0088FF', '#00AAFF'], // Divider - blue
        '#4444FF': ['#3333FF', '#5555FF', '#4444FF', '#6666FF'], // Trapper - blue-purple
        '#8844FF': ['#7733FF', '#9955FF', '#8844FF', '#AA66FF'], // Bomber - purple
        '#FFAA00': ['#FF9900', '#FFBB00', '#FFAA00', '#FFCC00'], // Maniac - yellow-orange
        '#88FF00': ['#77FF00', '#99FF00', '#88FF00', '#AAFF00']  // Prowler/Serpent - lime
      };
      // ENSURE EVERY ENEMY STARTS WITH A VALID COLOR
      const baseColor = type.color || '#ff4444'; // Default to red if no color
      const variations = colorVariations[baseColor] || ['#ff4444']; // Fallback array
      const selectedColor = variations[(Math.random() * variations.length) | 0] || '#ff4444';
      
      // SET ALL THREE COLOR PROPERTIES TO THE SAME VALID COLOR
      e.color = selectedColor;
      e.originalColor = selectedColor;
      e.baseColor = selectedColor;
      e.deathTimer = 0;
      e.dying = false;
      
      // Boss spawning logic - limited per wave
      if (g.wave % 10 === 0 && g.waveBossesSpawned < g.waveBossesTarget) {
        // Super boss spawn (limited quantity per wave)
        e.r *= 3; e.hp *= 9; e.touchDmg *= 1.5;
        e.speed *= 1.5; // 1.5x speed boost for super bosses
        e.color = '#FF0000'; e.originalColor = '#FF0000'; e.behavior = 'superboss'; // Pure red (fastest)
        e.phaseTimer = 0; // Timer for behavior changes
        e.currentPhase = 0; // Current movement phase
        g.waveBossesSpawned++;
      } else if (g.wave % 5 === 0 && g.wave % 10 !== 0 && Math.random() < 0.1) {
        // Mini-boss every 5 waves (10% chance)
        e.r *= 1.3; e.hp *= 2; e.touchDmg *= 1.3;
        e.color = '#FFCC00'; e.originalColor = '#FFCC00'; e.behavior = 'boss'; // Golden yellow (fast)
      } else {
        // First select behavior from available pool based on current wave
        // Wave 1 = pool 0, Wave 2-3 = pool 1, Wave 4-5 = pool 2, etc.
        let poolIndex = 0;
        if (g.wave >= 7) poolIndex = 4;
        else if (g.wave >= 5) poolIndex = 3;
        else if (g.wave >= 4) poolIndex = 2;
        else if (g.wave >= 2) poolIndex = 1;
        const availableBehaviors = behaviorPools[poolIndex];
        e.behavior = availableBehaviors[(Math.random() * availableBehaviors.length) | 0];
        
        // THEN check if this slow/medium enemy becomes a shooter (25% chance)
        // This preserves the behavior but adds shooting capability
        // EXCEPT volatile enemies cannot be shooters (too dangerous combo)
        if (type.speed <= 120 && Math.random() < 0.25 && e.behavior !== 'volatile') {
          e.isShooter = true;
          e.shootTimer = Math.random() * 2.0; // Random initial delay
          
          // Determine shooter pattern based on wave and chance
          const rand = Math.random();
          if (g.wave >= 3 && rand < 0.3) {
            e.shootPattern = 'spread';
            e.color = '#00FF88'; 
            e.originalColor = '#00FF88';
            e.baseColor = '#00FF88'; // Cyan-green for spread shooter (slow)
          } else if (g.wave >= 5 && rand < 0.6) {
            e.shootPattern = 'burst';
            e.burstCount = 0; // Track bursts in sequence
            e.color = '#00FF88'; 
            e.originalColor = '#00FF88';
            e.baseColor = '#00FF88'; // Cyan-green for burst shooter (slow)
          } else {
            e.shootPattern = 'single';
            e.color = '#00FF88'; 
            e.originalColor = '#00FF88';
            e.baseColor = '#00FF88'; // Cyan-green for single shooter (slow)
          }
        }
      }
      
      // Set special colors and stats for specific behaviors (preserve shooter status)
      if (e.behavior === 'volatile') {
        // Only set color if not already a shooter (shooters keep their color)
        if (!e.isShooter) {
          e.color = '#FF4400'; // Orange-red for suicide crawlers (very fast)
          e.originalColor = '#FF4400';
          e.baseColor = '#FF4400'; // Used during orbiting state
        }
        // Speed cap for suicide crawlers to prevent crazy speeds
        e.speed = Math.min(e.speed, Math.min(400, 180 + g.wave * 5)); // More gradual speed increase
      } else if (e.behavior === 'juggernaut') {
        // Make them extra tanky and slow
        e.hp = Math.ceil(e.hp * 1.8); // 80% more HP
        e.speed *= 0.7; // 30% slower
        e.touchDmg = Math.ceil(e.touchDmg * 1.3); // 30% more damage
        e.color = '#CC44FF'; // Magenta for slowpush tanks (slowest)
        e.originalColor = '#CC44FF';
        e.baseColor = '#CC44FF';
        e.knockbackStrength = 250; // Knockback force
        
        // Shield system
        const baseShieldHP = 15;
        const diff = 1 + g.wave * 0.06; // Gentler scaling
        e.shieldHP = Math.ceil(baseShieldHP * diff);
        e.maxShieldHP = e.shieldHP;
        e.hasShield = true;
        
        // Shield direction tracking (90% speed for counterplay)
        e.shieldDirection = { x: 1, y: 0 }; // Initial direction
      } else if (e.behavior === 'vortex') {
        // Make them distinctive and slower
        e.speed = Math.min(500, e.speed * 0.8); // 20% slower for spiral shooters, capped at 500
        e.color = '#00FFCC'; // Cyan for spiral shooters (slow)
        e.originalColor = '#00FFCC';
        e.baseColor = '#00FFCC';
      } else if (e.behavior === 'berserker') {
        // Speed cap for dash zombies to prevent crazy dash speeds
        e.speed = Math.min(e.speed, Math.min(400, 150 + g.wave * 4)); // More gradual speed increase
        e.color = '#FF6600'; // Orange for charge enemies (very fast)
        e.originalColor = '#FF6600';
        e.baseColor = '#FF6600';
      } else if (e.behavior === 'divider') {
        // Make them slightly tankier and distinctive
        e.hp = Math.ceil(e.hp * 1.3); // 30% more HP
        e.r = Math.ceil(e.r * 1.1); // 10% bigger
        e.color = '#0088FF'; // Blue for splitters (very slow)
        e.originalColor = '#0088FF';
        e.baseColor = '#0088FF';
      } else if (e.behavior === 'trapper') {
        // Make them slower and distinctive
        e.speed *= 0.8; // 20% slower (plus 30% in behavior = 44% total reduction)
        e.color = '#4444FF'; // Blue-purple for mine layers (very slow)
        e.originalColor = '#4444FF';
        e.baseColor = '#4444FF';
      } else if (e.behavior === 'bomber') {
        // Grenadiers - throw grenades at player
        e.speed *= 0.7; // 30% slower, they rely on ranged attacks
        e.color = '#8844FF'; // Purple for grenadiers (very slow)
        e.originalColor = '#8844FF';
        e.baseColor = '#8844FF';
        e.r *= 1.1; // Slightly bigger
      } else if (e.behavior === 'maniac') {
        // Erratic enemies - use yellow-orange for medium-fast chaotic movement
        if (!e.isShooter) {
          e.color = '#FFAA00'; // Yellow-orange for erratic (fast bursts)
          e.originalColor = '#FFAA00';
          e.baseColor = '#FFAA00';
        }
        e.speed *= 1.2; // 20% speed boost for maniacs
      } else if (e.behavior === 'prowler' || e.behavior === 'serpent') {
        // Flanking and zigzag patterns with appropriate speed colors
        if (!e.isShooter) {
          if (e.behavior === 'prowler') {
            // Prowlers are fast (40% boost) - use orange color
            e.color = '#FF8800'; // Orange for fast flanking
            e.originalColor = '#FF8800';
            e.baseColor = '#FF8800';
          } else {
            // Serpents are medium-fast (30% boost) - use yellow-green
            e.color = '#AAFF00'; // Yellow-green for medium-fast zigzag
            e.originalColor = '#AAFF00';
            e.baseColor = '#AAFF00';
          }
        }
        if (e.behavior === 'prowler') {
          e.speed *= 1.4; // 40% speed boost for prowlers to flank effectively
        } else if (e.behavior === 'serpent') {
          e.speed *= 1.3; // 30% speed boost for serpents
        }
      } else if (e.behavior === 'stalker') {
        // Keep default color unless shooter
        if (e.isShooter) {
          // Ensure shooter color is preserved
          e.color = '#00FF88';
          e.originalColor = '#00FF88';
          e.baseColor = '#00FF88';
        }
      } else if (e.behavior === 'leaper') {
        // Make leapers 30% faster base speed
        e.speed *= 1.3;
      }
      
      // Random spawn animation - DISABLE FADE TO PREVENT INVISIBILITY
      e.spawnAnimation = 'scale'; // Only use scale, never fade
      e.spawnTimer = 0.5; // 0.5 second spawn animation
      
      e.alive = true;
    });
  }

  // Calculate bullet count and directions from active pattern multipliers
  // Handle enemy death and crystal drops consistently
  function handleEnemyDeath(enemy, game) {
    if (enemy.hp <= 0 && !enemy.dying) {
      // Start death animation instead of immediate removal
      enemy.dying = true;
      enemy.deathTimer = 0.2; // 0.2 second death animation

      // Boss death slow-mo effect!
      if (enemy.behavior === 'boss' || enemy.behavior === 'superboss') {
        game.timeScaleTarget = 0.3; // Slow to 30% speed
        // Clear any existing slow-mo timeout to prevent conflicts
        if (game.slowMoTimeout) {
          clearTimeout(game.slowMoTimeout);
        }
        // Return to normal after 0.8 seconds
        game.slowMoTimeout = setTimeout(() => {
          if (game) {
            game.timeScaleTarget = 1.0;
            game.slowMoTimeout = null;
          }
        }, 800);
      }

      // Enemy death sound based on type/size
      enemyDeathSound(enemy);

      // Large blood burst on death
      spawnBlood(enemy.x, enemy.y, 0, 0, 'death');
      
      // Volatile explosion - bigger and more dramatic
      if (enemy.behavior === 'volatile') {
        // Extra explosion sound
        beep(80, 0.2, 'sawtooth', 0.15); // Deep explosion boom
        
        // Large explosion particles with shockwave effect
        const explosionParticles = 35; // More particles for bigger explosion
        
        // Create expanding shockwave ring
        for (let i = 0; i < 20; i++) {
          particles.spawn(p => {
            const angle = (i / 20) * TAU;
            const speed = 250; // Uniform speed for ring effect
            p.x = enemy.x; p.y = enemy.y;
            p.vx = fastCos(angle) * speed;
            p.vy = fastSin(angle) * speed;
            p.life = 0; p.maxLife = 0.4; // Short lived for shockwave
            p.size = 6; // Medium size
            p.color = '#ff8800'; // Orange shockwave
            p.hasGravity = false;
            p.alive = true;
          });
        }
        
        // Main explosion particles
        for (let i = 0; i < explosionParticles; i++) {
          particles.spawn(p => {
            const angle = (i / explosionParticles) * TAU + Math.random() * 0.4;
            const speed = randRange(200, 450); // Faster particles
            p.x = enemy.x; p.y = enemy.y;
            p.vx = fastCos(angle) * speed;
            p.vy = fastSin(angle) * speed;
            p.life = 0; p.maxLife = randRange(0.6, 1.2); // Longer lasting
            p.size = randRange(4, 9); // Bigger particles
            // Purple-orange explosion to match enemy color
            if (Math.random() < 0.3) {
              p.color = '#8844ff'; // Some purple (enemy color)
            } else {
              // Orange explosion with variation
              const orangeBase = 0xff;
              const orangeGreen = 0x44 + Math.floor(Math.random() * 40) - 20;
              p.color = '#' + orangeBase.toString(16) + Math.max(0x20, Math.min(0x88, orangeGreen)).toString(16).padStart(2,'0') + '00';
            }
            p.hasGravity = false;
            p.alive = true;
          });
        }
        
        // Damage player if close enough (explosion radius)
        const explosionRadius = 80; // Increased from 45 for more danger
        const distToPlayer = fastLength(enemy.x - game.player.x, enemy.y - game.player.y);
        if (distToPlayer <= explosionRadius && game.invulTime <= 0) {
          // Apply damage with reduction
          const explosionDamage = 8; // Base explosion damage
          const actualDamage = Math.ceil(explosionDamage * (1 - game.player.damageReduction));
          game.player.hp -= actualDamage;

          // Set invulnerability and damage flash
          game.invulTime = 0.35;
          game.damageFlash = 0.3;
          // Screen shake on damage!
          game.screenShake = 1.0;
          
          // Knockback from explosion
          const knockbackForce = 400;
          const dx = game.player.x - enemy.x;
          const dy = game.player.y - enemy.y;
          const dist = Math.max(1, distToPlayer);
          game.player.vx += (dx / dist) * knockbackForce;
          game.player.vy += (dy / dist) * knockbackForce;
          
          // Effects
          hurtSound();
          spawnBlood(game.player.x, game.player.y, 0, 0, 'player');
          
          // Check for player death
          if (game.player.hp <= 0) {
            triggerGameOver(game);
          }
        }
        
        // Damage other enemies in explosion radius (friendly fire)
        for (const otherEnemy of enemies.items) {
          if (!otherEnemy.alive || otherEnemy.dying || otherEnemy === enemy) continue;
          
          const distToEnemy = fastLength(enemy.x - otherEnemy.x, enemy.y - otherEnemy.y);
          if (distToEnemy <= explosionRadius) {
            // Scale damage based on distance (closer = more damage)
            const damageFalloff = 1 - (distToEnemy / explosionRadius) * 0.5; // 50-100% damage
            const explosionDamage = Math.ceil(10 * damageFalloff); // 5-10 damage
            otherEnemy.hp -= explosionDamage;
            
            // Knockback from explosion center
            const knockbackForce = 150;
            const dx = otherEnemy.x - enemy.x;
            const dy = otherEnemy.y - enemy.y;
            const dist = Math.max(1, fastLength(dx, dy));
            otherEnemy.vx += (dx / dist) * knockbackForce;
            otherEnemy.vy += (dy / dist) * knockbackForce;
            
            // Handle enemy death if killed by explosion
            if (otherEnemy.hp <= 0 && !otherEnemy.dying) {
              handleEnemyDeath(otherEnemy, game);
            }
          }
        }
      }
      
      // Splitter zombie - spawns 2-3 smaller enemies on death
      if (enemy.behavior === 'divider') {
        const childCount = 2 + Math.floor(Math.random() * 2); // 2-3 children
        const spreadAngle = TAU; // Full circle spread
        
        for (let i = 0; i < childCount; i++) {
          const angle = (i / childCount) * spreadAngle + Math.random() * 0.5; // Even spread with variance
          const distance = randRange(20, 40); // Spawn distance from parent
          
          // Spawn child enemy using existing spawn system
          enemies.spawn(child => {
            child.x = enemy.x + fastCos(angle) * distance;
            child.y = enemy.y + fastSin(angle) * distance;
            child.vx = fastCos(angle) * randRange(50, 100); // Initial velocity away from parent
            child.vy = fastSin(angle) * randRange(50, 100);
            
            // Child stats - smaller and weaker than parent
            child.r = Math.max(9, enemy.r * 0.6); // 60% size, minimum 9 radius (increased from 6)
            child.hp = Math.max(1, Math.floor(enemy.hp * 0.4)); // 40% HP, minimum 1
            child.speed = enemy.speed * 1.2; // 20% faster
            child.touchDmg = Math.max(1, Math.floor(enemy.touchDmg * 0.7)); // 70% damage
            child.color = '#ff66ff'; // Pink for child splitters
            child.originalColor = '#ff66ff';
            child.baseColor = '#ff66ff'; // Ensure all color properties are set
            child.behavior = 'normal'; // Children use normal behavior
            child.deathTimer = 0;
            child.dying = false;
            child.alive = true;
            
            // Clamp to screen bounds
            child.x = clamp(child.x, child.r, game.width() - child.r);
            child.y = clamp(child.y, child.r, game.height() - child.r);
          });
        }
        
        beep(250, 0.08, 'sawtooth', 0.10); // Splitting sound
      }
      
      // Enemy pop/burst effect - satisfying explosion (DRAMATICALLY IMPROVED!)
      const isBoss = enemy.behavior === 'boss' || enemy.behavior === 'superboss';
      const popParticles = isBoss ? 40 : (enemy.behavior === 'volatile' ? 25 : 20); // More particles for bosses
      for (let i = 0; i < popParticles; i++) {
        particles.spawn(p => {
          const angle = (i / popParticles) * TAU + Math.random() * 0.3; // Even spread with variance
          const speed = randRange(isBoss ? 200 : 150, isBoss ? 400 : 300); // Faster for bosses
          p.x = enemy.x; p.y = enemy.y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = randRange(isBoss ? 0.8 : 0.4, isBoss ? 1.5 : 0.8); // Longer for bosses
          p.size = randRange(isBoss ? 5 : 3, isBoss ? 10 : 6); // Bigger for bosses
          p.color = enemy.originalColor; // Match enemy color
          p.hasGravity = false; // Pure radial burst
          p.alive = true;
        });
      }
      
      // Create realistic blood spray stains (CRATER EFFECT!)
      // Check cap BEFORE looping to avoid wasted iterations
      let activeStains = 0;
      for (const s of bloodStains.items) {
        if (s.alive) activeStains++;
      }

      const numStains = isBoss ? randRange(40, 60) : randRange(20, 30); // More stains for bosses
      const stainBudget = Math.max(0, MAX_BLOOD_STAINS - activeStains); // How many we can spawn
      const actualStains = Math.min(numStains, stainBudget); // Don't exceed cap

      for (let i = 0; i < actualStains; i++) {
        bloodStains.spawn(stain => {
          // Spray pattern - blood lands in burst around death point
          const angle = Math.random() * TAU;
          const distance = randRange(isBoss ? 10 : 5, isBoss ? 50 : 35); // Wider spread for bosses
          stain.x = enemy.x + Math.cos(angle) * distance;
          stain.y = enemy.y + Math.sin(angle) * distance;

          // Initial movement (blood droplets still traveling)
          stain.vx = Math.cos(angle) * randRange(20, 80);
          stain.vy = Math.sin(angle) * randRange(20, 80);

          stain.life = 0;
          stain.maxLife = isBoss ? 12.0 : 8.0; // Craters persist much longer, especially for bosses!
          stain.size = randRange(isBoss ? 2 : 1, isBoss ? 6 : 4); // Bigger droplets for bosses
          stain.alpha = isBoss ? 0.9 : 0.8; // Darker for bosses
          stain.settled = false;
          stain.alive = true;
        });
      }
      
      // Crystal drop logic - bosses get special treatment
      const p = game.player;
      if (enemy.behavior === 'boss' || enemy.behavior === 'superboss') {
        // Bosses: 22% chance to drop homing crystal (+10% from original 20%)
        if (Math.random() < 0.22) {
          spawnBossPickup(enemy.x, enemy.y);
        }
      } else {
        // Special drops for specific enemy types
        if ((enemy.behavior === 'trapper' || enemy.behavior === 'bomber') && Math.random() < 0.011) {
          // 1.1% chance for minelayers and grenadiers to drop Remote Detonator (+10% from original 1%)
          spawnDetonatorPickup(enemy.x, enemy.y);
        } else {
          // Regular enemies: 4.4% chance to drop any crystal (+10% from original 4%, +20% per lucky upgrade)
          const baseRate = 0.044;
          const luckyMultiplier = 1 + (p.luckyBonus || 0);
          const dropRate = baseRate * luckyMultiplier;
          const roll = Math.random();
          if (roll < dropRate) {
            spawnBulletPickup(enemy.x, enemy.y);
          }
        }
      }
      
      game.kills++;

      // Combo system: increment combo on kill and reset timer
      game.currentCombo++;
      game.comboTimer = 3.0; // 3 second window to chain next kill
      if (game.currentCombo > game.highestCombo) {
        game.highestCombo = game.currentCombo;
      }

      // Vampiric healing
      const player = game.player;
      if (player && player.vampiricHealing) {
        player.hp = Math.min(player.maxHp, player.hp + player.vampiricHealing);
      }
      
      // Check if wave is complete (half of enemies killed)
      const aliveEnemies = enemies.items.filter(e => e.alive && !e.dying).length;
      const enemiesKilledThisWave = game.waveEnemiesSpawned - aliveEnemies;
      if (game.waveActive && enemiesKilledThisWave >= Math.floor(game.waveEnemiesTarget * 0.5)) {
        // Wave complete! Start next wave after brief delay
        game.waveActive = false;
        
        // CRITICAL: Prevent duplicate wave transitions
        if (waveTransitionInProgress) {
          return; // Already transitioning, don't schedule another
        }
        waveTransitionInProgress = true;
        
        // Cancel any existing wave transition
        if (nextWaveTimeoutId) {
          clearTimeout(nextWaveTimeoutId);
        }
        
        // Store timeout ID so we can cancel it if needed
        nextWaveTimeoutId = setTimeout(() => {
          waveTransitionInProgress = false; // Reset flag
          nextWaveTimeoutId = null; // Clear timeout ID
          game.wave++;
          game.waveEnemiesSpawned = 0;
          game.waveBossesSpawned = 0;
          // Proper enemy scaling: Wave 1=15, Wave 10=30, Wave 50=60, Wave 100=90
          // Using a square root-based scaling for gradual increase
          if (game.wave <= 50) {
            // From wave 1-50: 15 to 60 enemies
            // Formula: 15 + 45 * sqrt((wave-1)/49)
            const progress = (game.wave - 1) / 49; // 0 to 1
            game.waveEnemiesTarget = Math.floor(15 + 45 * Math.sqrt(progress));
          } else {
            // From wave 51-100: 60 to 90 enemies
            // Formula: 60 + 30 * ((wave-50)/50)
            const progress = Math.min(1, (game.wave - 50) / 50); // 0 to 1, capped
            game.waveEnemiesTarget = Math.floor(60 + 30 * progress);
          }
          // Set boss target for this wave
          if (game.wave % 10 === 0) {
            game.waveBossesTarget = Math.floor(game.wave / 10); // 1 boss on round 10, 2 on round 20, etc.
          } else {
            game.waveBossesTarget = 0;
          }
          waveSound();
          
          // Only show wave announcement if not in powerup dialog
          if (game.state !== STATE.POWERUP) {
            if (game.wave % 10 === 0) {
              showWaveAnnouncement(game.wave, true);
            } else {
              showWaveAnnouncement(game.wave, false);
            }
          }
          game.waveActive = true;
          
          // Spawn all enemies within 2-4 seconds
          const spawnDuration = 2000 + Math.random() * 2000; // 2-4 seconds
          const spawnInterval = spawnDuration / game.waveEnemiesTarget;
          
          // 30% chance for cluster spawn pattern
          if (Math.random() < 0.3) {
            // Cluster spawn - spawn in groups
            const clustersCount = 2 + Math.floor(Math.random() * 3); // 2-4 clusters
            const enemiesPerCluster = Math.ceil(game.waveEnemiesTarget / clustersCount);
            
            for (let c = 0; c < clustersCount; c++) {
              // Pick random edge for cluster
              const side = (Math.random() * 4) | 0;
              let clusterX, clusterY;
              const w = game.width(), h = game.height();
              if (side===0){ clusterX=randRange(50, w-50); clusterY=-20; }
              else if (side===1){ clusterX=randRange(50, w-50); clusterY=h+20; }
              else if (side===2){ clusterX=-20; clusterY=randRange(50, h-50); }
              else { clusterX=w+20; clusterY=randRange(50, h-50); }
              
              for (let e = 0; e < enemiesPerCluster && game.waveEnemiesSpawned < game.waveEnemiesTarget; e++) {
                const delay = (c * clustersCount * 500) + (e * 100); // Stagger clusters
                setTimeout(() => {
                  if (game.waveActive && game.waveEnemiesSpawned < game.waveEnemiesTarget) {
                    spawnEnemy(game, clusterX, clusterY);
                    game.waveEnemiesSpawned++;
                  }
                }, delay);
              }
            }
          } else {
            // Normal spread spawn
            for (let i = 0; i < game.waveEnemiesTarget; i++) {
              setTimeout(() => {
                if (game.waveActive) {
                  spawnEnemy(game);
                  game.waveEnemiesSpawned++;
                }
              }, i * spawnInterval);
            }
          }
        }, 3000); // 3 second breathing room between waves (allows previous wave card to fully disappear)
      }
      
      // Powerup selection - accelerating progression: 10, 25, 50, 100, then formula-based
      if (!game.level) game.level = 0;
      if (!game.nextLevelup) game.nextLevelup = 10; // First level at 10 kills
      
      if (game.kills >= game.nextLevelup) {
        showPowerupDialog();
        game.level++;
        
        // Calculate kills needed for next level
        let killsForNextLevel;
        if (game.level === 1) {
          killsForNextLevel = 25; // Level 2 needs 25 more
        } else if (game.level === 2) {
          killsForNextLevel = 50; // Level 3 needs 50 more
        } else if (game.level === 3) {
          killsForNextLevel = 100; // Level 4 needs 100 more
        } else {
          // Level 5+: 50 + 50  (level - 4)
          // Level 5 = 50 + 501 = 100, Level 6 = 50 + 502 = 150, etc.
          killsForNextLevel = 50 + 50 * (game.level - 3);
        }
        
        game.nextLevelup += killsForNextLevel;
      }
    }
  }

  /**
   * Calculates bullet pattern based on active crystal effects
   * @param {Object} player - Player object with patternMultipliers Map
   * @returns {Object} Object with totalBullets count and directions array
   */
  function calculateBulletPattern(player) {
    let totalBullets = 1; // Base single bullet
    
    // Apply all pattern multipliers
    for (const [pattern, shots] of player.patternMultipliers) {
      if (shots > 0) {
        if (pattern === 'triple') totalBullets *= 3;
        else if (pattern === 'quad') totalBullets *= 4;
      }
    }
    
    // Cap at maximum bullets per shot
    totalBullets = Math.min(totalBullets, PERF_CONSTANTS.MAX_BULLETS_PER_SHOT);
    
    // Get mouse direction as the center of the pattern
    const [baseDx, baseDy] = norm(mouseX - player.x, mouseY - player.y);
    const baseAngle = Math.atan2(baseDy, baseDx);
    
    // Calculate evenly spaced angles CENTERED on mouse direction
    const directions = [];
    if (totalBullets === 1) {
      // Single bullet - use mouse direction exactly
      directions.push({dx: baseDx, dy: baseDy});
    } else {
      // Multiple bullets - one ALWAYS points to mouse, others evenly spaced around it
      const angleStep = TAU / totalBullets;
      
      for (let i = 0; i < totalBullets; i++) {
        const angle = baseAngle + (angleStep * i);
        const dx = fastCos(angle);
        const dy = fastSin(angle);
        directions.push({dx, dy});
      }
      
      // First bullet always goes exactly toward mouse
      directions[0] = {dx: baseDx, dy: baseDy};
    }
    
    return {totalBullets, directions};
  }

  /**
   * Spawns a player bullet with specified position, direction, and effects
   * @param {number} x - Starting X position
   * @param {number} y - Starting Y position
   * @param {number} dirX - Normalized direction X component
   * @param {number} dirY - Normalized direction Y component
   * @param {Array<string>} effects - Array of active crystal effect names
   */
  function spawnBullet(x,y,dirX,dirY,effects=[]){
    const baseSpeed = GAME_CONSTANTS.PLAYER_BULLET_BASE_SPEED;
    const player = game?.player;
    const speed = baseSpeed * (player?.bulletSpeed || 1.0);
    const size = GAME_CONSTANTS.PLAYER_BULLET_BASE_SIZE * (player?.bulletSize || 1.0);
    
    // Critical hit calculation
    const critChance = player?.criticalChance || 0;
    const isCritical = Math.random() < critChance;
    
    bullets.spawn(b => {
      b.x = x; b.y = y;
      b.vx = dirX * speed;
      b.vy = dirY * speed;
      b.r = size;
      b.life = 0;
      
      // Convert effects array to Set for O(1) lookups (vs O(n) includes())
      b.effectSet.clear();
      for (let i = 0, len = effects.length; i < len; i++) {
        b.effectSet.add(effects[i]); // Faster loop without for-of iterator
      }
      
      b.maxLife = b.effectSet.has('ricochet') ? 4.0 : 2.0;
      b.type = effects.length > 0 ? effects[0] : 'normal'; // Legacy compatibility
      b.effects = effects; // Direct reference instead of spread operator (no new array)
      b.pierces = (player?.piercingCount || 0);
      b.bounces = b.effectSet.has('ricochet') ? 3 : 0;
      b.homingTarget = null;
      b.hitEnemies.clear(); // Reset hit enemies for this bullet
      b.critical = isCritical;
      b.alive = true;
    });
  }

  /**
   * Spawns an enemy bullet aimed at a target position
   * @param {number} x - Starting X position
   * @param {number} y - Starting Y position
   * @param {number} targetX - Target X position
   * @param {number} targetY - Target Y position
   * @param {number} angleOffset - Angle offset in radians (default: 0)
   * @param {number} speedMult - Speed multiplier (default: 1.0)
   */
  // MIGRATED TO EnemyAI NAMESPACE - See EnemyAI.spawnBullet() above

  function spawnBulletPickup(x, y){
    pickups.spawn(p => {
      p.x = x; p.y = y;
      p.vx = (Math.random() - 0.5) * 100;
      // Variable bounce heights
      const bounceVariation = 0.7 + Math.random() * 0.6; // 0.7x to 1.3x
      p.vy = -(Math.random() * 150 + 50) * bounceVariation;
      // Weighted crystal selection - homing is 3x rarer than each regular crystal
      // Weight: 7 regular crystals (weight=1 each) + 1 homing (weight=1/3)
      // Homing probability = (1/3) / (7 + 1/3) = 1/22  4.54%
      let selectedPowerup;
      if (Math.random() < 1/22) { // 1/22 = ~4.54% chance for homing
        selectedPowerup = bulletPowerupMap.get('homing');
      } else {
        // Choose from pre-computed non-homing crystals (avoid O(n) filter)
        selectedPowerup = nonHomingPowerups[(Math.random() * nonHomingLength) | 0];
      }
      p.type = selectedPowerup.type;
      p.bounceTimer = 0;
      p.collected = false;
      p.rotationSpeed = 2 + Math.random() * 4; // Random rotation speed between 2-6
      p.rotation = Math.random() * TAU; // Random starting rotation
      p.alive = true;
    });
  }

  function spawnBossPickup(x, y){
    pickups.spawn(p => {
      p.x = x; p.y = y;
      p.vx = (Math.random() - 0.5) * 100;
      // Variable bounce heights (bosses drop with more force)
      const bounceVariation = 1.0 + Math.random() * 0.5; // 1.0x to 1.5x
      p.vy = -(Math.random() * 150 + 50) * bounceVariation;
      // Boss always drops homing crystal
      const homingPowerup = bulletPowerupMap.get('homing');
      p.type = homingPowerup.type;
      p.bounceTimer = 0;
      p.collected = false;
      p.rotationSpeed = 2 + Math.random() * 4; // Random rotation speed between 2-6
      p.rotation = Math.random() * TAU; // Random starting rotation
      p.alive = true;
    });
  }
  
  function spawnDetonatorPickup(x, y){
    pickups.spawn(p => {
      p.x = x; p.y = y;
      p.vx = (Math.random() - 0.5) * 100;
      // Detonators drop with less bounce (heavier)
      const bounceVariation = 0.5 + Math.random() * 0.3; // 0.5x to 0.8x
      p.vy = -(Math.random() * 150 + 50) * bounceVariation;
      p.type = 'detonator'; // Special type for detonator
      p.bounceTimer = 0;
      p.collected = false;
      p.rotationSpeed = 1; // Detonator rotates slowly
      p.rotation = 0; // Start aligned
      p.alive = true;
    });
  }

  function spawnBurst(x,y, n=10, color='#ffffff'){
    const adaptiveN = (n * performanceLevel) | 0; // Bit operation faster than Math.floor
    for (let i=0;i<adaptiveN;i++){
      if (shouldSpawnParticle()) {
        particles.spawn(p => {
          const a = Math.random()*TAU;
          const s = 40 + Math.random() * 120; // Inline randRange for speed
          p.x = x; p.y = y;
          p.vx = fastCos(a)*s;
          p.vy = fastSin(a)*s;
          p.life = 0; 
          // Longer lifespan for explosions (optimized color check)
          const isExplosion = color === '#ff8000' || color === '#ff4000' || color === '#ffff00';
          p.maxLife = isExplosion ? 
                      0.8 + Math.random() * 0.4 : 0.2 + Math.random() * 0.3;
          p.size = isExplosion ? 
                   2 + Math.random() * 4 : 1.5 + Math.random() * 2;
          p.color = color;
          p.hasGravity = false;
          p.alive = true;
        });
      }
    }
  }

  // Pre-computed blood colors to avoid runtime generation
  const BLOOD_COLORS = ['#ff0000', '#cc0000', '#800000', '#990000', '#e60000', '#b30000', '#660000', '#a60000'];
  
  function spawnBlood(x, y, dirX=0, dirY=0, type='impact'){
    // Check blood stain cap
    let activeStains = 0;
    for (const s of bloodStains.items) {
      if (s.alive) activeStains++;
    }
    if (activeStains >= MAX_BLOOD_STAINS) return; // Don't spawn if at cap
    
    
    if (type === 'impact') {
      // Small blood spray from bullet impact
      for (let i=0; i<8; i++){
        particles.spawn(p => {
          const spread = 0.6;
          const baseAngle = dirX !== 0 || dirY !== 0 ? Math.atan2(dirY, dirX) : Math.random() * TAU;
          const angle = baseAngle + (Math.random()-0.5)*spread;
          const speed = 80 + Math.random() * 100; // Inline for speed
          p.x = x; p.y = y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = 0.3 + Math.random() * 0.5; // Inline randRange
          p.size = 1 + Math.random() * 2; // Inline randRange
          p.color = BLOOD_COLORS[(Math.random() * BLOOD_COLORS.length) | 0];
          p.hasGravity = true;
          p.alive = true;
        });
      }
    } else if (type === 'death') {
      // Large blood burst when enemy dies
      const deathParticleCount = performanceLevel > 0.5 ? 15 : 8;
      for (let i=0; i<deathParticleCount; i++){
        particles.spawn(p => {
          const angle = Math.random() * TAU;
          const speed = 60 + Math.random() * 190; // Inline randRange
          p.x = x; p.y = y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = 0.8 + Math.random() * 0.7; // Inline randRange
          p.size = 2 + Math.random() * 4; // Inline randRange
          p.color = BLOOD_COLORS[(Math.random() * BLOOD_COLORS.length) | 0];
          p.hasGravity = true;
          p.alive = true;
        });
      }
    } else if (type === 'player') {
      // Player damage - red particles flying outward
      const playerParticleCount = performanceLevel > 0.5 ? 10 : 5;
      for (let i=0; i<playerParticleCount; i++){
        particles.spawn(p => {
          const angle = Math.random() * TAU;
          const speed = 100 + Math.random() * 100; // Inline randRange
          p.x = x; p.y = y;
          p.vx = fastCos(angle) * speed;
          p.vy = fastSin(angle) * speed;
          p.life = 0; p.maxLife = 0.4 + Math.random() * 0.3; // Inline randRange
          p.size = 2 + Math.random() * 2; // Inline randRange
          p.color = '#ff0000';
          p.hasGravity = true;
          p.alive = true;
        });
      }
    }
  }

  // Footstep spawning function
  function spawnFootstep(x, y, angle, isPlayer = false, entity = null) {
    // Check footstep cap
    let activeFootsteps = 0;
    for (const f of footsteps.items) {
      if (f.alive) activeFootsteps++;
    }
    if (activeFootsteps >= MAX_FOOTSTEPS) return;
    
    // Track which foot for alternating steps
    if (!entity.nextFoot) entity.nextFoot = false;
    const isLeft = entity.nextFoot;
    entity.nextFoot = !entity.nextFoot;
    
    // Calculate perpendicular offset for left/right foot placement
    const perpOffset = isPlayer ? 4 : 3;
    const perpX = Math.cos(angle + Math.PI/2) * perpOffset * (isLeft ? 1 : -1);
    const perpY = Math.sin(angle + Math.PI/2) * perpOffset * (isLeft ? 1 : -1);
    
    footsteps.spawn(f => {
      f.x = x + perpX;
      f.y = y + perpY;
      f.life = 0;
      f.maxLife = 3.0; // Moderate fade time
      f.size = isPlayer ? 7 : 5; // Slightly larger
      f.alpha = 0.35; // More opaque start
      f.angle = angle; // Direction of movement
      f.isPlayer = isPlayer;
      f.isLeft = isLeft;
      f.alive = true;
    });
  }

  // ===== Gradient Cache (for performance) =====
  const gradientCache = new Map();
  const MAX_GRADIENT_CACHE_SIZE = 100;
  
  // ===== Update & Draw =====
  // ============================================================
  // EXTRACTED UPDATE HELPERS - Breaking up god function
  // ============================================================

  /**
   * Processes player input, movement, stamina, and position updates
   * Extracted from update() to reduce god-function complexity (was 1730 lines)
   * @param {Object} game - Game state object
   * @param {Object} player - Player entity
   * @param {number} dt - Delta time in seconds
   * @returns {{ax: number, ay: number, isSprinting: boolean, canFire: boolean, heatSpreadMod: number, heatFireRateMod: number}}
   */
  function updatePlayerMovement(game, player, dt) {
    // Input -> movement (keyboard + touch)
    let ax = 0, ay = 0;
    if (keys.has('KeyW')) ay -= 1;
    if (keys.has('KeyS')) ay += 1;
    if (keys.has('KeyA')) ax -= 1;
    if (keys.has('KeyD')) ax += 1;

    // Improved touch movement with virtual joystick
    if (touchMove.active) {
      const deadZone = 15;
      const touchDx = touchMove.x - touchMove.startX;
      const touchDy = touchMove.y - touchMove.startY;
      const touchDist = fastLength(touchDx, touchDy);

      if (touchDist > deadZone) {
        const maxDist = 60;
        const scale = Math.min(touchDist, maxDist) / maxDist;
        const angle = Math.atan2(touchDy, touchDx);
        ax += Math.cos(angle) * scale * 1.2;
        ay += Math.sin(angle) * scale * 1.2;
      }
    }

    // Exhaustion cooldown
    if (player.exhausted > 0) player.exhausted -= dt;

    // Adrenaline timer countdown
    if (player.adrenalineTimer > 0) player.adrenalineTimer -= dt;

    // Leap cooldown
    if (player.leapCd > 0) {
      player.leapCd -= dt;
      if (player.leapCd <= 0) player.leapReady = true;
    }

    // Emergency leap (Space key)
    if (keys.has('Space') && player.leapReady && (ax || ay)) {
      const leapVec = normInPlace(ax, ay, vecPool.temp1);
      player.vx += leapVec.x * player.leapSpeed;
      player.vy += leapVec.y * player.leapSpeed;
      player.leapCd = 3.0;
      player.leapReady = false;
      beep(400, 0.08, 'triangle', 0.03);
    }

    // Stamina system
    const wantsToSprint = keys.has('ShiftLeft') || keys.has('ShiftRight');
    const canSprint = player.stamina > 0 && player.exhausted <= 0;
    const isSprinting = wantsToSprint && canSprint && (ax || ay);
    player.isSprinting = isSprinting;

    if (isSprinting) {
      const oldStamina = player.stamina;
      player.stamina = Math.max(0, player.stamina - 20 * dt);
      if (oldStamina > 0 && player.stamina <= 0) {
        const baseExhaustion = 2.0;
        const reduction = player.dashCooldownReduction || 0;
        player.exhausted = baseExhaustion * (1 - reduction);
        staminaDepletedSound();
      }
    } else {
      player.stamina = Math.min(100, player.stamina + 12.5 * dt * player.staminaRegen);
    }

    // Apply movement if input detected
    if (ax || ay) {
      const moveVec = normInPlace(ax, ay, vecPool.temp1);
      const nx = moveVec.x, ny = moveVec.y;
      const waveSpeedBonus = game.wave * GAME_CONSTANTS.PLAYER_WAVE_SPEED_BONUS;
      const adrenalineBonus = (player.adrenalineTimer > 0) ? GAME_CONSTANTS.PLAYER_ADRENALINE_MULTIPLIER : 1.0;
      const baseSpeed = (player.speed + waveSpeedBonus) * adrenalineBonus;
      const speed = Math.min(GAME_CONSTANTS.PLAYER_MAX_SPEED, isSprinting ? baseSpeed * GAME_CONSTANTS.PLAYER_SPRINT_MULTIPLIER : baseSpeed);
      player.vx += nx * speed * dt * GAME_CONSTANTS.PLAYER_ACCELERATION;
      player.vy += ny * speed * dt * GAME_CONSTANTS.PLAYER_ACCELERATION;
    }

    // Friction
    player.vx *= (1 - GAME_CONSTANTS.PLAYER_FRICTION * dt);
    player.vy *= (1 - GAME_CONSTANTS.PLAYER_FRICTION * dt);

    // Integrate position with bounds clamping
    player.x = clamp(player.x + player.vx * dt, player.radius, game.width() - player.radius);
    player.y = clamp(player.y + player.vy * dt, player.radius, game.height() - player.radius);

    // Spawn footsteps when moving
    if (!player.footstepTimer) player.footstepTimer = 0;
    const playerSpeed = fastLength(player.vx, player.vy);
    if (playerSpeed > GAME_CONSTANTS.PLAYER_FOOTSTEP_SPEED_THRESHOLD) {
      player.footstepTimer -= dt;
      if (player.footstepTimer <= 0) {
        const moveAngle = Math.atan2(player.vy, player.vx);
        spawnFootstep(player.x, player.y, moveAngle, true, player);
        player.footstepTimer = isSprinting ? GAME_CONSTANTS.PLAYER_FOOTSTEP_SPRINT_INTERVAL : GAME_CONSTANTS.PLAYER_FOOTSTEP_INTERVAL;
      }
    }

    // Heat dissipation when not firing
    if (!mouseDown || player.overheated) {
      player.heat = Math.max(0, player.heat - player.heatDissipation * dt);
      if (player.overheated && player.heat <= player.overheatCooldown) {
        player.overheated = false;
      }
    }

    // Calculate heat-based penalties
    let heatSpreadMod = 0;
    let heatFireRateMod = 1.0;
    let canFire = true;

    const weaponHeatPercent = player.heat / player.maxHeat;
    if (weaponHeatPercent >= GAME_CONSTANTS.HEAT_THRESHOLD_LOW && weaponHeatPercent < GAME_CONSTANTS.HEAT_THRESHOLD_MED) {
      heatSpreadMod = GAME_CONSTANTS.HEAT_SPREAD_LOW;
    } else if (weaponHeatPercent >= GAME_CONSTANTS.HEAT_THRESHOLD_MED && weaponHeatPercent < GAME_CONSTANTS.HEAT_THRESHOLD_HIGH) {
      heatSpreadMod = GAME_CONSTANTS.HEAT_SPREAD_MED;
      heatFireRateMod = GAME_CONSTANTS.HEAT_FIRERATE_MED;
    } else if (weaponHeatPercent >= GAME_CONSTANTS.HEAT_THRESHOLD_HIGH && weaponHeatPercent < 1.0) {
      heatSpreadMod = GAME_CONSTANTS.HEAT_SPREAD_HIGH;
      heatFireRateMod = GAME_CONSTANTS.HEAT_FIRERATE_HIGH;
    } else if (player.heat >= player.maxHeat) {
      player.overheated = true;
      player.heat = Math.min(player.heat, player.maxHeat);
      canFire = false;
    }

    return { ax, ay, isSprinting, canFire, heatSpreadMod, heatFireRateMod };
  }

  // TODO: Extract additional update() subsystems (~1600 lines remaining):
  // - updatePlayerShooting(game, player, dt, {canFire, heatSpreadMod, heatFireRateMod}) - ~150 lines
  // - updateBullets(game, dt) - ~200 lines (homing, seeking, ricochet logic)
  // - updateEnemies(game, dt) - ~600 lines (PARTIALLY in EnemyAI namespace)
  // - updateCollisions(game, dt) - ~400 lines (enemy hits, pickups, mines, shields)
  // - updateWaveProgression(game, dt) - ~200 lines (spawning, wave completion)
  // - updateParticles(game, dt) - ~100 lines (explosions, blood, footsteps)

  /**
   * Main game update loop - handles physics, AI, collisions, and game logic
   * @param {Object} g - Game state object
   * @param {number} dt - Delta time since last frame (in seconds)
   */
  function update(g, dt){
    g.t += dt;
    if (g.invulTime > 0) g.invulTime -= dt;
    if (g.damageFlash > 0) g.damageFlash -= dt;

    // Combo timer decay
    if (g.comboTimer > 0) {
      g.comboTimer -= dt;
      if (g.comboTimer <= 0) {
        g.currentCombo = 0; // Reset combo when timer expires
      }
    }

    // Static powerup effects
    const p = g.player;
    if (p.healthRegenRate > 0) {
      p.healthRegenTimer = (p.healthRegenTimer || 0) - dt;
      if (p.healthRegenTimer <= 0) {
        p.hp = Math.min(p.hp + p.healthRegenRate, p.maxHp);
        p.healthRegenTimer = 1.0; // Check every second
      }
    }

    // Process player movement, input, stamina, and heat (EXTRACTED to reduce god-function size)
    const {ax, ay, isSprinting, canFire, heatSpreadMod, heatFireRateMod} = updatePlayerMovement(g, p, dt);
    
    // shooting
    if (p.fireTimer > 0) p.fireTimer -= dt;
    if (mouseDown && p.fireTimer <= 0 && canFire && !p.overheated){
      const shootVec = normInPlace(mouseX - p.x, mouseY - p.y, vecPool.temp1);
      const dx = shootVec.x, dy = shootVec.y;
      
      // Gather all active effects (new modular system)
      const activeEffects = [];
      for (const [effect, shots] of p.activeEffects) {
        if (shots > 0) activeEffects.push(effect);
      }
      
      // Calculate bullet pattern (multiplicative system)
      const {totalBullets, directions} = calculateBulletPattern(p);
      const hasUpgrade = p.upgradeShots > 0;
      
      // New unified shooting system - handle all patterns/upgrades
      if (hasUpgrade && totalBullets === 1) {
        // Special case: Front + Back shot with single bullet
        const {dx, dy} = directions[0]; // Use the single calculated direction
        spawnBullet(p.x + dx*p.radius*1.1, p.y + dy*p.radius*1.1, dx, dy, activeEffects); // Front
        spawnBullet(p.x - dx*p.radius*1.1, p.y - dy*p.radius*1.1, -dx, -dy, activeEffects); // Back
        // Check for ammo efficiency (chance to not consume ammo)
        const efficiencyChance = p.ammoEfficiency || 0;
        if (Math.random() >= efficiencyChance) {
          p.upgradeShots--;
        }
      } else if (hasUpgrade && totalBullets > 1) {
        // V-formation applied to each bullet direction (double the bullets)
        const vAngle = 0.15; // Smaller angle for multi-bullet spread
        const cs1 = Math.cos(vAngle), sn1 = Math.sin(vAngle);
        const cs2 = Math.cos(-vAngle), sn2 = Math.sin(-vAngle);
        
        for (const {dx, dy} of directions) {
          const sx1 = dx*cs1 - dy*sn1, sy1 = dx*sn1 + dy*cs1;
          const sx2 = dx*cs2 - dy*sn2, sy2 = dx*sn2 + dy*cs2;
          spawnBullet(p.x + sx1*p.radius*1.1, p.y + sy1*p.radius*1.1, sx1, sy1, activeEffects);
          spawnBullet(p.x + sx2*p.radius*1.1, p.y + sy2*p.radius*1.1, sx2, sy2, activeEffects);
        }
        // Check for ammo efficiency (chance to not consume ammo)
        const efficiencyChance = p.ammoEfficiency || 0;
        if (Math.random() >= efficiencyChance) {
          p.upgradeShots--;
        }
      } else {
        // Normal pattern shooting - spawn bullet for each direction
        for (const {dx, dy} of directions) {
          if (totalBullets === 1) {
            // Single bullet - add slight spread when sprinting + heat spread
            const baseSpread = (keys.has('ShiftLeft')||keys.has('ShiftRight')) ? 0.08 : 0.02;
            const spread = baseSpread + heatSpreadMod;
            const s = (Math.random()-0.5)*spread;
            const cs = Math.cos(s), sn = Math.sin(s);
            const sx = dx*cs - dy*sn, sy = dx*sn + dy*cs;
            spawnBullet(p.x + sx*p.radius*1.1, p.y + sy*p.radius*1.1, sx, sy, activeEffects);
          } else {
            // Multiple bullets - no spread, perfect circle
            spawnBullet(p.x + dx*p.radius*1.1, p.y + dy*p.radius*1.1, dx, dy, activeEffects);
          }
        }
      }
      
      // Decrement all active effects and pattern multipliers after shooting
      // Check for ammo efficiency (chance to not consume ammo)
      const efficiencyChance = p.ammoEfficiency || 0;
      if (Math.random() >= efficiencyChance) {
        for (const [effect, shots] of p.activeEffects) {
          if (shots > 0) p.activeEffects.set(effect, shots - 1);
        }
        for (const [pattern, shots] of p.patternMultipliers) {
          if (shots > 0) p.patternMultipliers.set(pattern, shots - 1);
        }
      }
      
      // Apply fire rate penalty from heat
      p.fireTimer = p.fireDelay * heatFireRateMod;
      
      // Generate heat per trigger pull, NOT per bullet (multi-shot doesn't increase heat)
      const actualBulletCount = hasUpgrade ? totalBullets * 2 : totalBullets;
      let heatGenerated = p.heatPerShot; // Fixed heat per shot regardless of bullet count
      
      // Extra heat generation when already hot (90%+)
      if (p.heat >= p.maxHeat * 0.9) {
        heatGenerated *= 1.5; // 50% more heat when near overheat
      }
      
      p.heat = Math.min(p.maxHeat, p.heat + heatGenerated * p.heatEfficiencyMod);
      shootSound();

      // Track shots fired for accuracy stat
      g.shotsFired += actualBulletCount;
    }

    // Enemy spawning now handled by setTimeout in wave completion logic
    // (All enemies spawn within 2-4 seconds at wave start)

    // Build spatial grid of enemies
    g.grid.reset();
    
    // Check for enemies near screen edges
    let nearTop = false, nearBottom = false, nearLeft = false, nearRight = false;
    const edgeThreshold = 100;
    
    // Cache expensive calculations
    const gameWidth = g.width();
    const gameHeight = g.height();
    const rightEdge = gameWidth - edgeThreshold;
    const bottomEdge = gameHeight - edgeThreshold;
    
    // Apply time scale to enemies only (player unaffected for boss death advantage)
    const enemyDt = dt * g.timeScale;

    for (const e of enemies.items){
      if (!e.alive) continue;

      // Update spawn timer
      if (e.spawnTimer && e.spawnTimer > 0) {
        e.spawnTimer -= enemyDt;
      }

      // Handle death animation
      if (e.dying) {
        e.deathTimer -= enemyDt;
        // Death animation: white flash  red flash  fade
        const progress = 1 - (e.deathTimer / 0.2);
        if (progress < 0.3) {
          e.color = '#ffffff'; // White flash
        } else if (progress < 0.7) {
          e.color = '#ff0000'; // Red flash
        } else {
          e.color = e.originalColor || '#ff4444'; // Fade back to original (with fallback)
        }
        
        if (e.deathTimer <= 0) {
          e.alive = false; // Actually remove enemy
          continue;
        }
        // Don't do normal movement/behavior during death animation
        g.grid.insert(e);
        continue;
      }
      
      // Update critical hit flash timer
      if (e.critFlashTimer > 0) {
        e.critFlashTimer -= enemyDt;
      }

      // Check edge proximity (using cached values)
      if (e.y < edgeThreshold) nearTop = true;
      if (e.y > bottomEdge) nearBottom = true;
      if (e.x < edgeThreshold) nearLeft = true;
      if (e.x > rightEdge) nearRight = true;

      // Handle freeze effect
      if (e.frozen > 0) e.frozen -= enemyDt;
      const freezeMultiplier = e.frozen > 0 ? 0.5 : 1.0; // 50% speed when frozen

      // Apply behavior-specific movement (replaces old generic movement)
      const dirVec = normInPlace(p.x - e.x, p.y - e.y, vecPool.temp1);
      const dx = dirVec.x, dy = dirVec.y;

      // Add human-like walking cadence to all enemies
      if (!e.cadence) e.cadence = Math.random() * TAU; // Random starting phase
      e.cadence += enemyDt * 4; // Walking rhythm frequency
      const walkRhythm = 0.8 + 0.2 * fastSin(e.cadence); // 0.6 to 1.0 speed multiplier
      
      if (e.behavior === 'stalker') {
        // Improved gait-like movement toward player
        const gaitPattern = 0.7 + 0.4 * fastSin(e.cadence) + 0.1 * fastSin(e.cadence * 2); // More realistic gait
        const stepSway = fastSin(e.cadence + Math.PI/4) * 8; // Slight left-right sway while walking
        const perpX = -dy; // Perpendicular to movement direction
        const perpY = dx;
        
        e.vx += dx * e.speed * enemyDt * 2.6 * gaitPattern * freezeMultiplier; // Increased 30% from 2.0 to 2.6
        e.vy += dy * e.speed * enemyDt * 2.6 * gaitPattern * freezeMultiplier;
        e.vx += perpX * stepSway * enemyDt * freezeMultiplier; // Add subtle sway
        e.vy += perpY * stepSway * enemyDt * freezeMultiplier;
      } else if (e.behavior === 'serpent') {
        // Strong zigzag movement - very noticeable serpentine pattern
        e.vx += dx * e.speed * enemyDt * AI_CONSTANTS.SERPENT_SPEED_MULTIPLIER * walkRhythm * freezeMultiplier;
        e.vy += dy * e.speed * enemyDt * AI_CONSTANTS.SERPENT_SPEED_MULTIPLIER * walkRhythm * freezeMultiplier;
        // Much stronger zigzag for clear serpentine movement
        e.vx += fastSin(g.t * 10 + e.x * 0.01) * AI_CONSTANTS.SERPENT_ZIGZAG_STRENGTH_X * enemyDt * freezeMultiplier;
        e.vy += fastCos(g.t * 8 + e.y * 0.01) * AI_CONSTANTS.SERPENT_ZIGZAG_STRENGTH_Y * enemyDt * freezeMultiplier;
      } else if (e.behavior === 'prowler') {
        // Flanking movement - circles around to attack from sides
        const playerAngle = Math.atan2(p.y - e.y, p.x - e.x);
        // Larger flanking angle for more obvious circling
        const flankAngle = playerAngle + fastSin(g.t * 3 + e.x * 0.005) * Math.PI/2;
        const fx = fastCos(flankAngle);
        const fy = fastSin(flankAngle);
        // Faster flanking movement
        e.vx += fx * e.speed * enemyDt * AI_CONSTANTS.PROWLER_FLANK_SPEED * walkRhythm * freezeMultiplier;
        e.vy += fy * e.speed * enemyDt * AI_CONSTANTS.PROWLER_FLANK_SPEED * walkRhythm * freezeMultiplier;
        // Less direct attraction for more flanking
        e.vx += dx * e.speed * enemyDt * AI_CONSTANTS.PROWLER_DIRECT_ATTRACTION * freezeMultiplier;
        e.vy += dy * e.speed * enemyDt * AI_CONSTANTS.PROWLER_DIRECT_ATTRACTION * freezeMultiplier;
      } else if (e.behavior === 'berserker') {
        // Enhanced dash zombie with telegraph system
        if (!e.dashState) e.dashState = 'prowling';
        if (!e.dashTimer) e.dashTimer = 2 + Math.random() * 3;
        
        e.dashTimer -= enemyDt;
        
        if (e.dashState === 'prowling') {
          // Prowl around player between dashes
          e.vx += dx * e.speed * enemyDt * AI_CONSTANTS.BERSERKER_PROWL_SPEED * walkRhythm * freezeMultiplier;
          e.vy += dy * e.speed * enemyDt * AI_CONSTANTS.BERSERKER_PROWL_SPEED * walkRhythm * freezeMultiplier;

          if (e.dashTimer <= 0) {
            // Start telegraph phase
            e.dashState = 'telegraph';
            e.dashTimer = AI_CONSTANTS.BERSERKER_TELEGRAPH_DURATION;
            e.originalColor = e.color;
            e.dashDirection = { x: dx, y: dy }; // Lock dash direction
            beep(400, 0.1, 'triangle', 0.08); // Telegraph warning sound
          }
        } else if (e.dashState === 'telegraph') {
          // Flash bright white during telegraph and slow down
          e.color = Math.sin(g.t * 12) > 0 ? '#ffffff' : e.originalColor;

          // Move very slowly during telegraph
          e.vx += dx * e.speed * enemyDt * AI_CONSTANTS.BERSERKER_TELEGRAPH_SPEED * freezeMultiplier;
          e.vy += dy * e.speed * enemyDt * AI_CONSTANTS.BERSERKER_TELEGRAPH_SPEED * freezeMultiplier;

          if (e.dashTimer <= 0) {
            // Start dash
            e.dashState = 'dashing';
            e.dashTimer = AI_CONSTANTS.BERSERKER_DASH_DURATION;
            e.color = '#ffff00'; // Bright yellow while dashing
            beep(600, 0.05, 'sawtooth', 0.12); // Dash sound
          }
        } else if (e.dashState === 'dashing') {
          // Fast linear dash in locked direction
          const dashSpeed = e.speed * AI_CONSTANTS.BERSERKER_DASH_MULTIPLIER;
          e.vx += e.dashDirection.x * dashSpeed * enemyDt * AI_CONSTANTS.BERSERKER_DASH_IMPULSE;
          e.vy += e.dashDirection.y * dashSpeed * enemyDt * AI_CONSTANTS.BERSERKER_DASH_IMPULSE;

          if (e.dashTimer <= 0) {
            // Return to prowling
            e.dashState = 'prowling';
            e.dashTimer = AI_CONSTANTS.BERSERKER_COOLDOWN_MIN + Math.random() * (AI_CONSTANTS.BERSERKER_COOLDOWN_MAX - AI_CONSTANTS.BERSERKER_COOLDOWN_MIN);
            e.color = e.originalColor; // Restore original color
          }
        }
      } else if (e.behavior === 'maniac') {
        // Truly chaotic, unpredictable movement - much more erratic
        const panicRhythm = 0.5 + 0.5 * Math.sin(e.cadence * 3);
        // Much stronger random movement
        e.vx += (Math.random() - 0.5) * AI_CONSTANTS.MANIAC_CHAOS_FACTOR * enemyDt * panicRhythm;
        e.vy += (Math.random() - 0.5) * AI_CONSTANTS.MANIAC_CHAOS_FACTOR * enemyDt * panicRhythm;
        // Faster base movement toward player
        e.vx += dx * e.speed * AI_CONSTANTS.MANIAC_SPEED_MULTIPLIER * enemyDt * freezeMultiplier;
        e.vy += dy * e.speed * AI_CONSTANTS.MANIAC_SPEED_MULTIPLIER * enemyDt * freezeMultiplier;
      } else if (e.behavior === 'superboss') {
        // Super boss with changing movement phases every 20 seconds
        e.phaseTimer = (e.phaseTimer || 0) + dt;
        if (e.phaseTimer >= 20) {
          e.phaseTimer = 0;
          e.currentPhase = (e.currentPhase + 1) % 4; // Cycle through 4 phases
        }
        
        const phase = e.currentPhase || 0;
        const heavyStep = 0.8 + 0.4 * Math.sin(e.cadence * 0.3); // Powerful rhythm
        
        if (phase === 0) {
          // Phase 0: Relentless pursuit - direct aggressive chase
          e.vx += dx * e.speed * enemyDt * 2.0 * heavyStep;
          e.vy += dy * e.speed * enemyDt * 2.0 * heavyStep;
        } else if (phase === 1) {
          // Phase 1: Circling predator - orbits around player
          const orbitSpeed = 1.8;
          const perpDx = -dy; // Perpendicular to player direction  
          const perpDy = dx;
          e.vx += (dx * 0.8 + perpDx * orbitSpeed) * e.speed * enemyDt * heavyStep;
          e.vy += (dy * 0.8 + perpDy * orbitSpeed) * e.speed * enemyDt * heavyStep;
        } else if (phase === 2) {
          // Phase 2: Erratic berserker - unpredictable bursts
          const chaos = 0.7 + 0.6 * Math.sin(e.cadence * 4); // Chaotic rhythm
          e.vx += ((Math.random() - 0.5) * 400 + dx * 150) * enemyDt * chaos;
          e.vy += ((Math.random() - 0.5) * 400 + dy * 150) * enemyDt * chaos;
        } else {
          // Phase 3: Charging bull - periodic devastating rushes
          if (!e.rushPhase) e.rushPhase = { timer: 0, charging: false };
          e.rushPhase.timer += enemyDt;
          
          if (!e.rushPhase.charging && e.rushPhase.timer >= 2) {
            e.rushPhase.charging = true;
            e.rushPhase.timer = 0;
            e.rushDirection = { x: dx, y: dy }; // Lock rush direction
          }
          
          if (e.rushPhase.charging) {
            if (e.rushPhase.timer < 1.5) {
              // Charging for 1.5 seconds
              const rushPower = 3.0 + Math.sin(e.rushPhase.timer * 8) * 0.5;
              e.vx += e.rushDirection.x * e.speed * enemyDt * rushPower;
              e.vy += e.rushDirection.y * e.speed * enemyDt * rushPower;
            } else {
              // Reset for next cycle
              e.rushPhase.charging = false;
              e.rushPhase.timer = 0;
            }
          } else {
            // Slow stalking between charges
            e.vx += dx * e.speed * enemyDt * 0.3 * heavyStep;
            e.vy += dy * e.speed * enemyDt * 0.3 * heavyStep;
          }
        }
      } else if (e.behavior === 'boss') {
        // Boss moves deliberately with heavy footsteps
        const heavyStep = 0.9 + 0.2 * Math.sin(e.cadence * 0.5); // Still rhythmic but faster
        e.vx += dx * e.speed * enemyDt * 1.2 * heavyStep;
        e.vy += dy * e.speed * enemyDt * 1.2 * heavyStep;
      } else if (e.behavior === 'leaper') {
        // Zergling rush behavior - quick leap attacks like player emergency dash
        if (!e.rushTimer) e.rushTimer = Math.random() * 1.5 + 0.5; // Initial delay
        e.rushTimer -= enemyDt;
        
        if (e.rushTimer <= 0) {
          // Perform rush leap toward player
          const rushSpeed = e.speed * 4; // 4x speed burst (increased from 3x)
          e.vx += dx * rushSpeed * enemyDt * 10; // Stronger impulse
          e.vy += dy * rushSpeed * enemyDt * 10;
          e.rushTimer = 1.0 + Math.random() * 1.5; // 1.0-2.5 second cooldown (faster leaps)
        } else {
          // Fast movement between rushes (no longer slow!)
          e.vx += dx * e.speed * enemyDt * 1.8 * walkRhythm; // 1.8x speed (was 0.8x)
          e.vy += dy * e.speed * enemyDt * 1.8 * walkRhythm;
        }
      } else if (e.behavior === 'volatile') {
        // Suicide crawler - orbits player then charges periodically
        if (!e.chargeState) e.chargeState = 'orbiting';
        if (!e.chargeTimer) e.chargeTimer = 10 + Math.random() * 10; // 10-20 second orbit time
        if (!e.orbitAngle) e.orbitAngle = Math.random() * TAU; // Random starting orbit position
        // baseColor is now set during enemy creation
        
        e.chargeTimer -= enemyDt;
        
        if (e.chargeState === 'orbiting') {
          // Orbit around player at medium distance
          const orbitRadius = 120;
          const orbitSpeed = 1.2; // Orbit speed
          e.orbitAngle += enemyDt * orbitSpeed;
          
          const targetX = p.x + fastCos(e.orbitAngle) * orbitRadius;
          const targetY = p.y + fastSin(e.orbitAngle) * orbitRadius;
          
          const orbitDx = targetX - e.x;
          const orbitDy = targetY - e.y;
          const orbitVec = normInPlace(orbitDx, orbitDy, vecPool.temp3);
          
          // Move toward orbit position with some attraction to player
          e.vx += orbitVec.x * e.speed * enemyDt * 1.5;
          e.vy += orbitVec.y * e.speed * enemyDt * 1.5;
          e.vx += dx * e.speed * enemyDt * 0.2; // Slight player attraction
          e.vy += dy * e.speed * enemyDt * 0.2;
          
          e.color = e.baseColor || e.originalColor || '#8844ff'; // Use baseColor with fallbacks
          
          if (e.chargeTimer <= 0) {
            // Start telegraph phase
            e.chargeState = 'telegraph';
            e.chargeTimer = 1.0; // Telegraph for 1 second
          }
        } else if (e.chargeState === 'telegraph') {
          // Flash bright red during telegraph
          e.color = Math.sin(g.t * 15) > 0 ? '#ff0000' : (e.baseColor || e.originalColor || '#8844ff');
          
          // Slow down during telegraph
          e.vx += dx * e.speed * enemyDt * 0.2;
          e.vy += dy * e.speed * enemyDt * 0.2;
          
          if (e.chargeTimer <= 0) {
            // Start charging
            e.chargeState = 'charging';
            e.chargeTimer = 4.0; // Longer charge duration
            e.color = '#ff0000'; // Stay red while charging
            beep(350, 0.12, 'sawtooth', 0.10); // Charge sound
          }
        } else if (e.chargeState === 'charging') {
          // Seeking charge - gentler curve toward player like seeking bullets
          const seekVec = normInPlace(p.x - e.x, p.y - e.y, vecPool.temp2);
          const sx = seekVec.x, sy = seekVec.y;
          
          // Use seeking bullet approach - blend current direction with target direction
          const currentSpeed = fastLength(e.vx, e.vy) || e.speed * 2; // 2x base speed
          const currentVec = currentSpeed > 0 ? normInPlace(e.vx, e.vy, vecPool.temp3) : { x: sx, y: sy };
          const seekingStrength = 0.15; // Gentler than bullet seeking (0.2)
          
          // Gradually curve toward player
          const newDx = currentVec.x + sx * seekingStrength;
          const newDy = currentVec.y + sy * seekingStrength;
          const finalVec = normInPlace(newDx, newDy, vecPool.temp1);
          
          // Apply final velocity at 2x speed
          const targetSpeed = e.speed * 2; // Actual 2x speed
          e.vx = finalVec.x * targetSpeed;
          e.vy = finalVec.y * targetSpeed;
          
          // Check if hit screen boundaries
          const gameWidth = g.width();
          const gameHeight = g.height();
          const hitBoundary = (e.x <= e.r || e.x >= gameWidth - e.r || 
                              e.y <= e.r || e.y >= gameHeight - e.r);
          
          if (e.chargeTimer <= 0 || hitBoundary) {
            // Reset to orbiting instead of exploding
            e.chargeState = 'orbiting';
            e.chargeTimer = 8 + Math.random() * 8; // 8-16 second orbit before next charge
            e.color = e.baseColor || e.originalColor || '#8844ff'; // Back to base with fallbacks
            e.orbitAngle = Math.atan2(e.y - p.y, e.x - p.x); // Start orbit from current position
          }
        }
      } else if (e.behavior === 'juggernaut') {
        // Slow push - deliberate tanky movement toward player
        const pushStep = 0.9 + 0.2 * Math.sin(e.cadence * 0.4); // Heavy, slow rhythm
        e.vx += dx * e.speed * enemyDt * 0.8 * pushStep * freezeMultiplier; // Slow but persistent
        e.vy += dy * e.speed * enemyDt * 0.8 * pushStep * freezeMultiplier;
        
        // Update shield direction at 90% of rotation speed for counterplay
        if (e.hasShield && e.shieldDirection) {
          const shieldRotationSpeed = 0.9; // 90% speed
          const targetDir = { x: dx, y: dy };
          
          // Smoothly interpolate shield direction toward player direction
          e.shieldDirection.x = e.shieldDirection.x * (1 - shieldRotationSpeed * enemyDt) + targetDir.x * shieldRotationSpeed * enemyDt;
          e.shieldDirection.y = e.shieldDirection.y * (1 - shieldRotationSpeed * enemyDt) + targetDir.y * shieldRotationSpeed * enemyDt;
          
          // Normalize shield direction
          const len = fastLength(e.shieldDirection.x, e.shieldDirection.y);
          if (len > 0) {
            e.shieldDirection.x /= len;
            e.shieldDirection.y /= len;
          }
        }
      } else if (e.behavior === 'vortex') {
        // Spiral shooter - slow movement, rotates aim and shoots in patterns
        e.vx += dx * e.speed * enemyDt * 0.6 * walkRhythm * freezeMultiplier; // Slow movement
        e.vy += dy * e.speed * enemyDt * 0.6 * walkRhythm * freezeMultiplier;
        
        // Initialize spiral shooting properties
        if (!e.spiralAngle) e.spiralAngle = 0;
        if (!e.spiralShootTimer) e.spiralShootTimer = Math.random() * 2;
        
        // Rotate spiral angle continuously
        const rotationSpeed = 3.0; // radians per second
        e.spiralAngle += rotationSpeed * enemyDt;
        
        // Shoot periodically in spiral pattern
        e.spiralShootTimer -= enemyDt;
        if (e.spiralShootTimer <= 0) {
          EnemyAI.spawnBullet(e.x, e.y,
            e.x + fastCos(e.spiralAngle) * 100,
            e.y + fastSin(e.spiralAngle) * 100);
          e.spiralShootTimer = 0.6; // Half frequency (was 0.3)
          beep(320, 0.04, 'triangle', 0.04); // High-pitched spiral sound
        }
      } else if (e.behavior === 'divider') {
        // Splitter zombie - normal movement with slight erratic behavior
        const splitStep = 0.8 + 0.3 * Math.sin(e.cadence * 1.5); // Slightly erratic rhythm
        e.vx += dx * e.speed * enemyDt * 1.0 * splitStep * freezeMultiplier;
        e.vy += dy * e.speed * enemyDt * 1.0 * splitStep * freezeMultiplier;
        // Add slight random movement for unpredictability
        e.vx += (Math.random() - 0.5) * 50 * enemyDt;
        e.vy += (Math.random() - 0.5) * 50 * enemyDt;
      } else if (e.behavior === 'trapper') {
        // Mine layer - slow movement, drops mines periodically
        e.vx += dx * e.speed * enemyDt * 0.7 * walkRhythm * freezeMultiplier; // 30% slower
        e.vy += dy * e.speed * enemyDt * 0.7 * walkRhythm * freezeMultiplier;
        
        // Initialize mine dropping properties
        if (!e.mineDropTimer) e.mineDropTimer = 1 + Math.random() * 2;
        if (!e.minesDropped) e.minesDropped = 0;
        const maxMines = GAME_CONSTANTS.MINE_MAX_PER_ENEMY;

        // Drop mines periodically
        e.mineDropTimer -= enemyDt;
        if (e.mineDropTimer <= 0 && e.minesDropped < maxMines) {
          // Spawn mine at current position
          mines.spawn(mine => {
            mine.x = e.x + (Math.random() - 0.5) * 20; // Slight position variance
            mine.y = e.y + (Math.random() - 0.5) * 20;
            mine.fuseTime = 0;
            mine.maxFuseTime = GAME_CONSTANTS.MINE_FUSE_TIME;
            mine.isArmed = false; // Not armed immediately
            mine.triggerRadius = GAME_CONSTANTS.MINE_TRIGGER_RADIUS;
            mine.explosionRadius = GAME_CONSTANTS.MINE_EXPLOSION_RADIUS;
            mine.explosionDamage = GAME_CONSTANTS.MINE_BASE_DAMAGE + game.wave * 1;
            mine.flashTimer = 0;
            mine.isTriggered = false; // New triggered state
            mine.isGrenade = false; // Explicitly mark as NOT a grenade
            mine.r = 8; // Standard mine size
            mine.alive = true;
            mine.owner = e; // Track which enemy dropped it
          });

          e.minesDropped++;
          e.mineDropTimer = GAME_CONSTANTS.MINE_DROP_INTERVAL;
          beep(180, 0.08, 'square', 0.06); // Mine drop sound
        }
      } else if (e.behavior === 'bomber') {
        // Grenadier - uses mixed movement patterns with grenade throwing
        const currentDist = fastLength(p.x - e.x, p.y - e.y);
        
        // Initialize pattern timer if not set
        if (!e.patternTimer) {
          e.patternTimer = 0;
          e.currentPattern = Math.floor(Math.random() * 3);
        }
        
        // Switch patterns every 2-3 seconds
        e.patternTimer += enemyDt;
        if (e.patternTimer > 2 + Math.random()) {
          e.patternTimer = 0;
          e.currentPattern = (e.currentPattern + 1) % 3;
        }
        
        // Use persistent pattern choice
        if (e.currentPattern === 0) {
          // Normal chase pattern with walk rhythm
          const gaitPattern = 0.7 + 0.4 * fastSin(e.cadence) + 0.1 * fastSin(e.cadence * 2);
          e.vx += dx * e.speed * enemyDt * 1.2 * gaitPattern * freezeMultiplier;
          e.vy += dy * e.speed * enemyDt * 1.2 * gaitPattern * freezeMultiplier;
        } else if (e.currentPattern === 1) {
          // Zigzag approach
          e.vx += dx * e.speed * enemyDt * 0.8 * walkRhythm * freezeMultiplier;
          e.vy += dy * e.speed * enemyDt * 0.8 * walkRhythm * freezeMultiplier;
          e.vx += fastSin(g.t * 4 + e.x * 0.01) * 60 * enemyDt * freezeMultiplier;
          e.vy += fastCos(g.t * 3 + e.y * 0.01) * 60 * enemyDt * freezeMultiplier;
        } else {
          // Flanking movement
          const playerAngle = Math.atan2(p.y - e.y, p.x - e.x);
          const flankAngle = playerAngle + fastSin(g.t * 1.5 + e.x * 0.005) * Math.PI/3;
          const fx = fastCos(flankAngle);
          const fy = fastSin(flankAngle);
          e.vx += fx * e.speed * enemyDt * 0.9 * walkRhythm * freezeMultiplier;
          e.vy += fy * e.speed * enemyDt * 0.9 * walkRhythm * freezeMultiplier;
          // Some direct attraction
          e.vx += dx * e.speed * enemyDt * 0.3 * freezeMultiplier;
          e.vy += dy * e.speed * enemyDt * 0.3 * freezeMultiplier;
        }
        
        // Initialize grenade throwing properties
        if (!e.grenadeTimer) e.grenadeTimer = 2 + Math.random() * 2;
        if (!e.grenadesThrown) e.grenadesThrown = 0;
        const maxGrenades = 12; // Maximum grenades per enemy
        
        // Throw grenades periodically (range: 0-600 pixels ONLY)
        e.grenadeTimer -= enemyDt;
        if (e.grenadeTimer <= 0 && e.grenadesThrown < maxGrenades) {
          // STRICT distance check - only throw if within range
          if (currentDist <= 600 && currentDist > 0) {
            // Target exact current player position
            const targetX = p.x;
            const targetY = p.y;
            
            // Calculate grenade physics for proper arc
            const throwSpeed = 300; // Fixed projectile speed of 300
            const gravity = 600; // Gravity constant
            
            // Spawn grenade (using mine system but with different behavior)
            mines.spawn(grenade => {
              // Start grenade at enemy position (no offset for accuracy)
              grenade.x = e.x;
              grenade.y = e.y;
              
              // Calculate direction to player
              const throwDx = targetX - e.x;
              const throwDy = targetY - e.y;
              const throwDist = Math.sqrt(throwDx * throwDx + throwDy * throwDy);
              
              // Set velocity at fixed speed toward player
              grenade.vx = (throwDx / throwDist) * throwSpeed;
              grenade.vy = (throwDy / throwDist) * throwSpeed;
              
              // Calculate travel time based on distance and speed
              const travelTime = throwDist / throwSpeed;
              
              // Calculate initial upward velocity for proper arc
              // Using physics: z = vz*t - 0.5*g*t = 0 when t = travelTime
              // So: vz = 0.5*g*travelTime
              grenade.vz = (gravity * travelTime) / 2;
              grenade.z = 1; // Start slightly above ground
              grenade.gravity = gravity; // Store gravity for this grenade
              
              grenade.fuseTime = 0;
              grenade.maxFuseTime = travelTime + 0.8; // Explode 0.8s after landing
              grenade.isArmed = false;
              grenade.triggerRadius = 0; // No proximity trigger, only timer
              grenade.explosionRadius = 60; // Slightly smaller than mines
              grenade.explosionDamage = 10 + game.wave * 0.5; // Scales with wave
              grenade.flashTimer = 0;
              grenade.isTriggered = false;
              grenade.isGrenade = true; // Mark as grenade for special rendering
              grenade.targetX = targetX; // Where it should land
              grenade.targetY = targetY;
              grenade.alive = true;
              grenade.owner = e;
              grenade.r = 8; // Same size as mines for consistency
            });
          
            e.grenadesThrown++;
            beep(400, 0.1, 'sawtooth', 0.08); // Grenade throw sound
          }
          // Reset timer regardless of whether we threw (prevents rapid checks)
          e.grenadeTimer = 3.0 + Math.random() * 2; // 3-5 second interval
        }
      } else {
        // DEFAULT MOVEMENT - Basic pursuit for any unrecognized behavior
        e.vx += dx * e.speed * enemyDt * 1.5 * walkRhythm * freezeMultiplier;
        e.vy += dy * e.speed * enemyDt * 1.5 * walkRhythm * freezeMultiplier;
      }
      
      // Shooter enemy logic with different patterns
      if (e.isShooter) {
        e.shootTimer -= enemyDt;
        if (e.shootTimer <= 0) {
          if (e.shootPattern === 'spread') {
            EnemyAI.spawnSpreadShot(e.x, e.y, p.x, p.y, 3, Math.PI/3); // 3 bullets, 60 spread
            e.shootTimer = 2.5; // Slightly slower for spread
            beep(280, 0.08, 'sine', 0.10); // Lower, longer sound for spread
          } else if (e.shootPattern === 'burst') {
            EnemyAI.spawnBullet(e.x, e.y, p.x, p.y);
            e.burstCount++;

            if (e.burstCount >= 3) {
              e.shootTimer = 3.0; // Long cooldown after burst
              e.burstCount = 0;
              beep(320, 0.05, 'sine', 0.06); // Final burst sound
            } else {
              e.shootTimer = 0.15; // Quick successive shots
              beep(300, 0.04, 'sine', 0.06); // Rapid burst sound
            }
          } else {
            // Single shot (default)
            EnemyAI.spawnBullet(e.x, e.y, p.x, p.y);
            e.shootTimer = 2.0; // Reset timer
            beep(300, 0.06, 'sine', 0.08); // Enemy shooting sound
          }
        }
      }
      
      // damp
      e.vx *= (1 - 3*enemyDt);
      e.vy *= (1 - 3*enemyDt);
      e.x += e.vx*enemyDt;
      e.y += e.vy*enemyDt;
      // clamp bounds
      e.x = clamp(e.x, e.r, g.width()-e.r);
      e.y = clamp(e.y, e.r, g.height()-e.r);
      
      // Spawn footsteps for enemies
      if (!e.footstepTimer) e.footstepTimer = 0;
      const enemySpeed = fastLength(e.vx, e.vy);
      if (enemySpeed > 20) { // Lower threshold for enemies
        e.footstepTimer -= enemyDt;
        if (e.footstepTimer <= 0) {
          const moveAngle = Math.atan2(e.vy, e.vx);
          spawnFootstep(e.x, e.y, moveAngle, false, e);
          // Enemy footstep frequency based on speed
          e.footstepTimer = 0.3 - Math.min(0.1, enemySpeed * 0.0005);
        }
      }
      g.grid.insert(e);
    }
    
    // Update edge warnings
    // Update edge warnings using object
    edgeWarnings.top.style.display = nearTop ? 'block' : 'none';
    edgeWarnings.bottom.style.display = nearBottom ? 'block' : 'none';
    edgeWarnings.left.style.display = nearLeft ? 'block' : 'none';
    edgeWarnings.right.style.display = nearRight ? 'block' : 'none';

    // bullets - cache expensive property access and dimensions
    const bulletSpeedMult = game?.player?.bulletSpeed || 1.0;
    const gameWidthBounds = g.width() + 10;
    const gameHeightBounds = g.height() + 10;
    
    for (const b of bullets.items){
      if (!b.alive) continue;
      
      // Homing bullets
      const effects = b.effects || [];
      if (b.effectSet.has('homing')) {
        // Find new target if current target is dead/dying or we don't have one
        if (!b.homingTarget || !b.homingTarget.alive || b.homingTarget.dying || b.hitEnemies.has(b.homingTarget)) {
          let closest = null, closestDist = Infinity;
          for (const e of enemies.items) {
            if (!e.alive || e.dying || b.hitEnemies.has(e)) continue; // Skip dead/dying/already hit enemies
            const dist = fastLength(e.x - b.x, e.y - b.y);
            if (dist < closestDist) { closest = e; closestDist = dist; }
          }
          b.homingTarget = closest;
        }
      }
      
      if (b.effectSet.has('homing') && b.homingTarget && b.homingTarget.alive && !b.homingTarget.dying) {
        const homingVec = normInPlace(b.homingTarget.x - b.x, b.homingTarget.y - b.y, vecPool.temp2);
        const hx = homingVec.x, hy = homingVec.y;
        
        // Use consistent target speed instead of current speed (cache property access)
        const bulletSpeedMult = game?.player?.bulletSpeed || 1.0;
        const baseSpeed = 720 * bulletSpeedMult;
        const homingStrength = 0.3; // Even stronger homing
        
        b.vx = (b.vx * (1-homingStrength) + hx * baseSpeed * homingStrength);
        b.vy = (b.vy * (1-homingStrength) + hy * baseSpeed * homingStrength);
      }
      
      // Seeking bullets - curve toward nearest enemy without needing a specific target
      if (b.effectSet.has('seeking')) {
        let closest = null, closestDist = Infinity;
        for (const e of enemies.items) {
          if (!e.alive || e.dying) continue;
          const dist = fastLength(e.x - b.x, e.y - b.y);
          if (dist < closestDist && dist < 200) { // Seeking range
            closest = e; closestDist = dist;
          }
        }
        if (closest) {
          const seekVec = normInPlace(closest.x - b.x, closest.y - b.y, vecPool.temp3);
          const sx = seekVec.x, sy = seekVec.y;
          const baseSpeed = 720 * bulletSpeedMult; // Reuse cached value
          const seekingStrength = 0.2; // Lighter curve than homing
          
          // Gradually curve toward target
          const currentSpeed = fastLength(b.vx, b.vy);
          const currentVec = normInPlace(b.vx, b.vy, vecPool.temp4);
          const newDx = currentVec.x + sx * seekingStrength;
          const newDy = currentVec.y + sy * seekingStrength;
          const finalVec = normInPlace(newDx, newDy, vecPool.temp2);
          const finalDx = finalVec.x, finalDy = finalVec.y;
          
          b.vx = finalDx * currentSpeed;
          b.vy = finalDy * currentSpeed;
        }
      }
      
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life += dt;
      
      // Small trail effects for fast bullets
      const speed = fastLength(b.vx, b.vy);
      if (speed > 500 && shouldSpawnParticle() && Math.random() < 0.3) {
        particles.spawn(p => {
          p.x = b.x - b.vx * dt * 0.5; // Slightly behind bullet
          p.y = b.y - b.vy * dt * 0.5;
          p.vx = b.vx * 0.1; p.vy = b.vy * 0.1; // Slow trailing motion
          p.life = 0; p.maxLife = 0.15; // Short lifespan
          p.size = Math.min(2, b.r * 0.3); // Small size
          // Random trail color variations
          if (b.effects && b.effects.length > 0) {
            // Yellow variations for effect bullets
            const yellowVariation = Math.floor(Math.random() * 40) - 20;
            const green = Math.max(0x88, Math.min(0xff, 0xff + yellowVariation));
            p.color = '#ffff' + green.toString(16).padStart(2, '0');
          } else {
            // White/blue variations for normal bullets
            const blueShift = Math.floor(Math.random() * 60);
            const value = 0xff - blueShift;
            p.color = '#' + value.toString(16).padStart(2, '0') + value.toString(16).padStart(2, '0') + 'ff';
          }
        });
      }
      
      // Ricochet bullets (using cached dimensions)
      if (b.effectSet.has('ricochet') && b.bounces > 0) {
        if (b.x <= 0 || b.x >= gameWidth) { b.vx *= -1; b.bounces--; }
        if (b.y <= 0 || b.y >= gameHeight) { b.vy *= -1; b.bounces--; }
        b.x = clamp(b.x, 0, gameWidth);
        b.y = clamp(b.y, 0, gameHeight);
      } else if (b.life > b.maxLife || b.x< -10 || b.y< -10 || b.x>gameWidthBounds || b.y>gameHeightBounds){
        b.alive = false; continue;
      }
      // collide with enemies via spatial hash - piercing bullets track hit enemies
      const nearby = g.grid.near(b.x,b.y);
      for (const e of nearby){
        if (!e.alive || e.dying) continue;
        if (b.hitEnemies.has(e)) continue; // Skip enemies already hit by this bullet
        const rr = (b.r+e.r);
        if (fastDistanceCheck(b.x, b.y, e.x, e.y, rr)){
          // hit
          const damage = b.critical ? 2 : 1; // Critical hits deal double damage
          
          // Shield system - ONLY for slowpush enemies with shields
          let hitsShield = false;
          if (e.behavior === 'juggernaut' && e.hasShield && e.shieldHP > 0 && e.shieldDirection) {
            // Calculate bullet direction relative to enemy
            const bulletDir = normInPlace(b.x - e.x, b.y - e.y, vecPool.temp2);
            
            // Check if bullet is coming from shield side (dot product > 0 means same direction)
            const dotProduct = bulletDir.x * e.shieldDirection.x + bulletDir.y * e.shieldDirection.y;
            hitsShield = dotProduct > 0.3; // Shield covers ~120 arc in front
          }
          
          if (hitsShield) {
            // Bullet hits shield
            e.shieldHP -= damage;
            if (e.shieldHP <= 0) {
              e.hasShield = false; // Shield broken
              beep(200, 0.06, 'square', 0.08); // Shield break sound
            } else {
              beep(300, 0.03, 'triangle', 0.05); // Shield hit sound
            }
          } else {
            // Bullet hits enemy body directly (from behind/side or no shield)
            e.hp -= damage;
          }
          
          b.hitEnemies.add(e); // Mark this enemy as hit by this bullet

          // Track successful hit for accuracy stat
          g.shotsHit++;

          // Critical hit effects
          if (b.critical) {
            criticalHitSound();
            spawnBurst(e.x, e.y, 8, '#ffff00'); // Golden particles
            e.critFlashTimer = 0.1; // Brief flash effect
          }
          
          // Apply all special bullet effects
          const effects = b.effects || [];
          
          if (b.effectSet.has('explosive')) {
            // Explosive bullets damage nearby enemies
            for (const e2 of enemies.items) {
              if (!e2.alive || e2 === e) continue;
              const dist = fastLength(e2.x - b.x, e2.y - b.y);
              if (dist < 60) {
                e2.hp -= 1; // Increased from 40 to 60
                handleEnemyDeath(e2, g); // Handle death and crystal drops
              }
            }
            // Much more obvious explosion effect
            spawnBurst(b.x, b.y, 25, '#ff8000'); // More particles
            spawnBurst(b.x, b.y, 15, '#ff4000'); // Secondary burst
            spawnBurst(b.x, b.y, 10, '#ffff00'); // Yellow core
          }
          
          if (b.effectSet.has('lightning')) {
            // Lightning chains to nearby enemies (limit to prevent infinite chaining)
            let chainCount = 0;
            const maxChains = 3; // Limit chains per bullet

            // Use spatial grid for efficient nearby enemy lookup
            const nearbyEnemies = g.grid.near(b.x, b.y);
            for (const e2 of nearbyEnemies) {
              if (!e2.alive || e2 === e || e2.dying) continue; // Skip dying enemies
              if (chainCount >= maxChains) break; // Limit total chains

              const dist = fastLength(e2.x - b.x, e2.y - b.y);
              if (dist < 120) { // Chain range
                e2.hp -= 1; // Chain damage
                chainCount++;
                handleEnemyDeath(e2, g); // Handle death and crystal drops
                
                // More obvious lightning effect
                spawnBurst(e2.x, e2.y, 12, '#ffff00');
                spawnBurst(e2.x, e2.y, 8, '#ffffff'); 
                spawnBurst(e2.x, e2.y, 4, '#00ffff');
                
                // Create lightning bolt line effect
                const steps = 5;
                for (let i = 0; i < steps; i++) {
                  const t = i / (steps - 1);
                  const lx = b.x + (e2.x - b.x) * t;
                  const ly = b.y + (e2.y - b.y) * t;
                  spawnBurst(lx, ly, 2, '#ffffff');
                }
              }
            }
          }
          
          if (b.effectSet.has('freeze')) {
            // Freeze shot slows enemies
            if (!e.frozen) e.frozen = 0;
            e.frozen = Math.max(e.frozen, 2.0); // 2 seconds of slowness
            spawnBurst(e.x, e.y, 8, '#00ffff');
          }
          
          if (b.effectSet.has('cluster')) {
            // Cluster shot - bullets split into smaller bullets on impact
            const fragments = 3;
            for (let i = 0; i < fragments; i++) {
              const angle = (TAU * i) / fragments;
              const dx = Math.cos(angle);
              const dy = Math.sin(angle);
              spawnBullet(b.x, b.y, dx, dy, []);
            }
            spawnBurst(b.x, b.y, 12, '#ffa500');
          }
          
          if (b.effectSet.has('seeking')) {
            // Seeking bullets curve toward enemies (enhanced homing)
            // This is implemented in the bullet update loop above, similar to homing
            // but with different behavior - seeking bullets don't need a specific target
          }
          
          // Handle enemy death and effects
          handleEnemyDeath(e, g);
          
          // Blood spray from bullet impact
          spawnBlood(b.x, b.y, b.vx, b.vy, 'impact');
          hitSound();
          
          // Shotgun effect - spawn additional bullets in spread BEFORE bullet is destroyed
          if (b.effectSet.has('shotgun')) {
            const spreadCount = 4;
            const spreadAngle = 0.5;
            for (let i = 0; i < spreadCount; i++) {
              const angle = (i / (spreadCount - 1) - 0.5) * spreadAngle;
              const cos = Math.cos(angle), sin = Math.sin(angle);
              const newDx = b.vx * cos - b.vy * sin;
              const newDy = b.vx * sin + b.vy * cos;
              const speed = fastLength(newDx, newDy);
              spawnBullet(b.x, b.y, newDx/speed, newDy/speed, []);
            }
          }
          
          // Piercing check - reduce pierces and destroy bullet if none left
          if (b.pierces > 0) {
            b.pierces--;
            // Bullet continues moving and can hit more enemies
          } else {
            // No pierces left, bullet is destroyed
            b.alive = false;
            break;
          }
          
          // Don't break - piercing bullets can hit multiple enemies in one frame
          // but each enemy can only be hit once per bullet (tracked by hitEnemies set)
        }
      }
    }

    // enemy bullets
    // Enemy bullets also affected by time scale
    for (const eb of enemyBullets.items) {
      if (!eb.alive) continue;

      eb.x += eb.vx * enemyDt;
      eb.y += eb.vy * enemyDt;
      eb.life += enemyDt;
      
      // Remove bullets that go off screen or expire
      if (eb.life > eb.maxLife || eb.x < -20 || eb.y < -20 || eb.x > g.width() + 20 || eb.y > g.height() + 20) {
        eb.alive = false;
        continue;
      }
      
      // Collision with player only
      const dist = fastLength(eb.x - p.x, eb.y - p.y);
      if (dist < eb.r + p.radius) {
        eb.alive = false; // Destroy bullet
        
        if (g.invulTime <= 0) {
          // Player takes damage from enemy bullet
          const damage = 8 + ((g.wave / 5) | 0); // +1 damage every 5 waves (bit operation)
          const actualDamage = Math.ceil(damage * (1 - p.damageReduction));
          p.hp -= actualDamage;
          g.invulTime = 0.35;
          g.damageFlash = 0.3;
          g.screenShake = 0.7; // Screen shake on projectile hit!
          hurtSound();
          
          // Knockback effect - push player away from bullet (no array allocation)
          const knockVec = normInPlace(eb.vx, eb.vy, vecPool.temp1);
          p.vx += knockVec.x * 300; // Strong knockback
          p.vy += knockVec.y * 300;
          
          // Player blood effect
          spawnBlood(p.x, p.y, 0, 0, 'player');
          
          if (p.hp <= 0) {
            triggerGameOver(g);
          }
        }
      }
    }

    // Bullet-to-bullet collision (player bullets can destroy enemy bullets)
    for (const pb of bullets.items) {
      if (!pb.alive) continue;

      for (const eb of enemyBullets.items) {
        if (!eb.alive) continue;

        // Check collision between bullets
        const dist = fastLength(pb.x - eb.x, pb.y - eb.y);
        if (dist < pb.r + eb.r + 2) { // Small buffer for better collision
          // Destroy both bullets
          pb.alive = false;
          eb.alive = false;

          // Visual effect at collision point
          const midX = (pb.x + eb.x) / 2;
          const midY = (pb.y + eb.y) / 2;
          spawnBurst(midX, midY, 8, '#ffff00'); // Yellow flash
          spawnBurst(midX, midY, 5, '#ffffff'); // White core

          // Sound effect
          beep(500, 0.04, 'square', 0.02); // Quick high pitch

          break; // This player bullet is destroyed, move to next
        }
      }
    }

    // enemy -> player collision
    const nearP = g.grid.near(p.x, p.y);
    for (const e of nearP){
      if (!e.alive || e.dying) continue;
      const rr = (p.radius + e.r);
      if (fastDistanceCheck(p.x, p.y, e.x, e.y, rr)){
        if (g.invulTime <= 0){
          const damage = Math.ceil(e.touchDmg * (1 - p.damageReduction));
          p.hp -= damage;
          g.invulTime = 0.35;
          g.damageFlash = 0.3; // Red vignette flash for 0.3 seconds
          g.screenShake = 0.8; // Screen shake on damage!
          hurtSound();
          
          // Suicide crawlers reset to orbiting after hitting player
          if (e.behavior === 'volatile') {
            e.chargeState = 'orbiting';
            e.chargeTimer = 6 + Math.random() * 6; // 6-12 second orbit after hit
            e.color = e.baseColor || e.originalColor || '#8844ff'; // Back to base with fallbacks
            e.orbitAngle = Math.atan2(e.y - p.y, e.x - p.x) + Math.PI; // Orbit away from player initially
          }
          
          // Slow push enemies apply knockback
          if (e.behavior === 'juggernaut' && e.knockbackStrength) {
            const knockbackVec = normInPlace(p.x - e.x, p.y - e.y, vecPool.temp1);
            const knockbackForce = e.knockbackStrength;
            
            // Apply impulse knockback to player
            p.vx += knockbackVec.x * knockbackForce * dt;
            p.vy += knockbackVec.y * knockbackForce * dt;
            
            // Visual/audio feedback for knockback
            beep(150, 0.08, 'square', 0.06); // Low thud sound
          }
          
          // Adrenaline boost trigger
          if (p.adrenalineBoost) {
            p.adrenalineTimer = 3.0; // 3 seconds of speed boost
          }
          // Player blood effect
          spawnBlood(p.x, p.y, 0, 0, 'player');
          if (p.hp <= 0){
            // game over
            triggerGameOver(g);
          }
        }
        // Knockback (reduced by resistance)
        const knockbackReduction = Math.min(1.0, p.knockbackResistance || 0);
        const knockbackForce = 200 * (1 - knockbackReduction);
        if (knockbackForce > 0) {
          const knockVec = normInPlace(p.x - e.x, p.y - e.y, vecPool.temp1);
          p.vx += knockVec.x * knockbackForce;
          p.vy += knockVec.y * knockbackForce;
        }
      }
    }

    // pickups
    for (const pickup of pickups.items){
      if (!pickup.alive) continue;
      
      // Physics - top-down view
      pickup.x += pickup.vx * dt;
      pickup.y += pickup.vy * dt;
      pickup.vy += 200 * dt; // Reduced gravity for top-down
      pickup.bounceTimer += dt;
      
      // Update rotation with gradual slowdown
      if (pickup.rotation !== undefined && pickup.rotationSpeed) {
        pickup.rotation += pickup.rotationSpeed * dt;
        // Apply friction to rotation speed to make it slow down
        pickup.rotationSpeed *= (1 - 2*dt);
        // Stop rotation when speed is very low
        if (Math.abs(pickup.rotationSpeed) < 0.1) {
          pickup.rotationSpeed = 0;
        }
      }
      
      // Keep crystals on screen - clamp to bounds
      pickup.x = clamp(pickup.x, 10, g.width() - 10);
      pickup.y = clamp(pickup.y, 10, g.height() - 10);
      
      // Ground collision
      if (pickup.y >= g.height() - 20) {
        pickup.y = g.height() - 20;
        pickup.vy = Math.min(pickup.vy, 0); // Stop downward movement
      }
      
      // Add friction to slow horizontal movement
      pickup.vx *= (1 - 3*dt);
      
      // Gentle settle instead of hard ground bounce
      if (pickup.vy > 0 && pickup.bounceTimer > 0.3) {
        pickup.vy *= (1 - 4*dt); // Slow down vertical movement
        if (Math.abs(pickup.vy) < 20) pickup.vy = 0; // Stop when slow enough
      }
      
      // Magnetic crystals effect + player collision (single distance calculation)
      const dist = fastLength(pickup.x - p.x, pickup.y - p.y);
      
      if (p.magneticRange > 0 && dist < p.magneticRange && dist > 20) {
        const magVec = normInPlace(p.x - pickup.x, p.y - pickup.y, vecPool.temp2);
        pickup.vx += magVec.x * 750 * dt;
        pickup.vy += magVec.y * 750 * dt;
      }
      
      // Player collision (reuse distance calculation)
      if (dist < 20) {
        // Handle special pickups first
        if (pickup.type === 'detonator') {
          // Remote Detonator - trigger all enemy mines
          pickup.alive = false;
          
          let minesDetonated = 0;
          
          // Trigger all enemy mines immediately
          for (const mine of mines.items) {
            if (mine.alive && !mine.isTriggered) {
              mine.isTriggered = true;
              mine.fuseTime = mine.maxFuseTime - 0.1; // Set to detonate in 0.1 seconds
              minesDetonated++;
              
              // Visual feedback on each mine
              particles.spawn(part => {
                part.x = mine.x;
                part.y = mine.y;
                part.vx = 0;
                part.vy = -50;
                part.life = 0;
                part.maxLife = 0.5;
                part.size = 15;
                part.color = '#ff0000';
                part.alive = true;
              });
            }
          }
          
          // Visual/audio feedback
          if (minesDetonated > 0) {
            beep(1500, 0.2, 'sawtooth', 0.4); // High pitched activation
            beep(800, 0.15, 'square', 0.3); // Secondary tone
            spawnBurst(p.x, p.y, 30, '#ff0000'); // Red burst effect
            spawnBurst(p.x, p.y, 20, '#ffaa00'); // Orange burst
          } else {
            beep(400, 0.1, 'triangle', 0.2); // Low tone if no mines
          }
          
          // Show notification
          const notification = document.getElementById('powerupNotification');
          if (notification) {
            notification.textContent = minesDetonated > 0 
              ? `DETONATOR: ${minesDetonated} MINE${minesDetonated > 1 ? 'S' : ''} TRIGGERED!`
              : 'DETONATOR: NO MINES FOUND';
            notification.style.display = 'block';
            notification.style.animation = 'none';
            void notification.offsetHeight; // Force reflow
            notification.style.animation = 'powerupPulse 3s ease-out forwards';
          }
        } else {
          // Regular crystal collection
          const powerup = bulletPowerupMap.get(pickup.type);
          const particleColor = powerup ? powerup.color : '#ffffff';
          for (let i = 0; i < 8; i++) {
            particles.spawn(part => {
              part.x = pickup.x;
              part.y = pickup.y;
              const angle = (i / 8) * TAU;
              const speed = 100 + Math.random() * 100;
              part.vx = Math.cos(angle) * speed;
              part.vy = Math.sin(angle) * speed;
              part.life = 0;
              part.maxLife = 0.5;
              part.size = 2 + Math.random() * 2;
              part.color = particleColor;
            });
          }
          
          pickup.alive = false;
          
          // All crystals now use unified bullet powerup system
          if (powerup) {
          if (powerup.type === 'upgrade') {
            // Dual shot upgrade
            p.upgradeShots += powerup.shots;
            beep(800, 0.1, 'triangle', 0.03);
          } else if (powerup.type === 'triple' || powerup.type === 'quad') {
            // Pattern powerup - actually add shots to existing
            const currentShots = p.patternMultipliers.get(powerup.type) || 0;
            p.patternMultipliers.set(powerup.type, currentShots + powerup.shots);
            // Legacy support
            p.bulletPattern = powerup.type;
            p.patternTimer = currentShots + powerup.shots;
            beep(600, 0.15, 'sawtooth', 0.04);
          } else {
            // Effect powerup - actually add shots to existing (not replace)
            const currentShots = p.activeEffects.get(powerup.type) || 0;
            p.activeEffects.set(powerup.type, currentShots + powerup.shots);
            // Legacy support
            p.bulletType = powerup.type;
            p.bulletTimer = currentShots + powerup.shots;
            beep(600, 0.15, 'sawtooth', 0.04);
          }
          showPowerupNotification(powerup.name);
          }
        }
      }
    }

    // mines and grenades - timed explosives
    // Mines also affected by time scale (placed by enemies)
    for (const mine of mines.items) {
      if (!mine.alive) continue;

      // Handle grenade projectile movement
      if (mine.isGrenade) {
        // Move grenade horizontally
        mine.x += mine.vx * enemyDt;
        mine.y += mine.vy * enemyDt;

        // Handle vertical movement (arc)
        if (mine.z !== undefined && mine.z !== null) {
          mine.z += mine.vz * enemyDt;
          mine.vz -= (mine.gravity || 600) * enemyDt; // Use grenade's gravity or default
          
          // Check if grenade hit the ground
          if (mine.z <= 0 && mine.vz < 0) {
            mine.z = 0;
            // Grenade landed - trigger it if not already triggered
            if (!mine.isTriggered) {
              mine.isTriggered = true;
              mine.fuseTime = mine.maxFuseTime - 0.8; // Start countdown
              beep(600, 0.08, 'square', 0.1); // Grenade land sound
              
              // Stop horizontal movement
              mine.vx = 0;
              mine.vy = 0;
              mine.vz = 0;
            }
          }
        } else {
          // Fallback for grenades without z coordinate
          const distToTarget = fastLength(mine.x - mine.targetX, mine.y - mine.targetY);
          if (distToTarget < 30 && !mine.isTriggered) {
            mine.isTriggered = true;
            mine.fuseTime = mine.maxFuseTime - 0.8;
            beep(600, 0.08, 'square', 0.1);
            mine.vx = 0;
            mine.vy = 0;
          }
        }
        
        // No air resistance for grenades - they need to maintain velocity to hit target
        // Air resistance would make them fall short
      }
      
      // Fuse timer
      mine.fuseTime += enemyDt;
      mine.flashTimer += enemyDt;
      
      // Arm mine after 0.5 seconds (can't be triggered immediately) - not for grenades
      if (!mine.isGrenade && !mine.isArmed && mine.fuseTime >= 0.5) {
        mine.isArmed = true;
      }
      
      // Check player proximity for armed mines (not grenades)
      if (!mine.isGrenade && mine.isArmed && !mine.isTriggered) {
        const distToPlayer = fastLength(mine.x - p.x, mine.y - p.y);
        
        // Trigger mine if player steps into trigger radius
        if (distToPlayer <= mine.triggerRadius) {
          mine.isTriggered = true;
          mine.fuseTime = 0; // Reset fuse for explosion countdown
          mine.maxFuseTime = 1.5; // 1.5 second explosion delay
          beep(400, 0.1, 'triangle', 0.1); // Trigger warning sound
        }
      }
      
      // Handle triggered mines
      if (mine.isTriggered && mine.fuseTime >= mine.maxFuseTime) {
        // Explode mine
        const explosionDist = fastLength(mine.x - p.x, mine.y - p.y);
        if (explosionDist <= mine.explosionRadius) {
          // Damage player
          p.hp -= mine.explosionDamage;
          g.screenShake = 1.2; // Strong screen shake from mine explosion!
          beep(100, 0.15, 'sawtooth', 0.2); // Deep explosion
          spawnBlood(p.x, p.y, 0, 0, 'player');
          hurtSound();
        }
        
        // Also damage nearby enemies (friendly fire!)
        for (const enemy of enemies.items) {
          if (!enemy.alive || enemy.dying) continue;
          const enemyDist = fastLength(mine.x - enemy.x, mine.y - enemy.y);
          if (enemyDist <= mine.explosionRadius) {
            // Don't damage the mine owner (optional - remove this check for full friendly fire)
            if (enemy !== mine.owner) {
              const damage = Math.ceil(mine.explosionDamage * 0.5); // Half damage to enemies
              enemy.hp -= damage;
              
              // Knockback
              const knockbackForce = 300;
              const dx = enemy.x - mine.x;
              const dy = enemy.y - mine.y;
              const dist = Math.max(1, enemyDist);
              enemy.vx += (dx / dist) * knockbackForce;
              enemy.vy += (dy / dist) * knockbackForce;
              
              // Blood effect
              spawnBlood(enemy.x, enemy.y, 0, 0, 'impact');
              
              // Handle enemy death if killed
              handleEnemyDeath(enemy, g);
            }
          }
        }
        
        // Explosion particles (bigger explosion)
        for (let i = 0; i < 30; i++) {
          particles.spawn(part => {
            const angle = (i / 30) * TAU + Math.random() * 0.3;
            const speed = randRange(150, 350); // Bigger explosion
            part.x = mine.x; part.y = mine.y;
            part.vx = fastCos(angle) * speed;
            part.vy = fastSin(angle) * speed;
            part.life = 0; part.maxLife = randRange(0.6, 1.0); // Longer lasting
            part.size = randRange(3, 7); // Bigger particles
            part.color = '#ff6600'; // Orange explosion
            part.hasGravity = false;
            part.alive = true;
          });
        }
        
        // Reduce mine/grenade count for owner
        if (mine.owner) {
          if (mine.isGrenade) {
            mine.owner.grenadesThrown--;
          } else {
            mine.owner.minesDropped--;
          }
        }
        mine.alive = false;
      }
    }

    // blood stains - realistic droplet physics
    for (const stain of bloodStains.items){
      if (!stain.alive) continue;
      
      if (!stain.settled) {
        // Blood droplets still in motion
        stain.x += stain.vx * dt;
        stain.y += stain.vy * dt;
        stain.vx *= (1 - 8*dt); // Strong friction
        stain.vy *= (1 - 8*dt);
        
        // Settle when slow enough
        if (fastLength(stain.vx, stain.vy) < 10) {
          stain.settled = true;
          stain.vx = 0;
          stain.vy = 0;
        }
      }
      
      stain.life += dt;
      // Fade similar to footsteps but slower (6 seconds total)
      const fadeProgress = stain.life / stain.maxLife;
      if (fadeProgress < 0.6) {
        // First 60% of lifetime (0-3.6 seconds): Stay mostly visible
        stain.alpha = 0.8 * (1.0 - fadeProgress * 0.2);
      } else {
        // Last 40% of lifetime (3.6-6 seconds): Quick fade
        stain.alpha = 0.8 * 0.8 * (1.0 - (fadeProgress - 0.6) / 0.4);
      }
      if (stain.life >= stain.maxLife) stain.alive = false;
    }
    
    // Update footsteps
    for (const footstep of footsteps.items) {
      if (!footstep.alive) continue;
      
      footstep.life += dt;
      // Fade out with easing - stays visible longer, then fades quickly
      const fadeProgress = footstep.life / footstep.maxLife;
      if (fadeProgress < 0.6) {
        // Stay mostly visible for first 60%
        footstep.alpha = 0.35 * (1.0 - fadeProgress * 0.3);
      } else {
        // Quick fade in last 40%
        footstep.alpha = 0.35 * 0.7 * (1.0 - (fadeProgress - 0.6) / 0.4);
      }
      if (footstep.life >= footstep.maxLife) {
        footstep.alive = false;
      }
    }

    // particles
    activeParticleCount = 0; // Reset counter each frame
    for (const p2 of particles.items){
      if (!p2.alive) continue;
      activeParticleCount++; // Count active particles
      p2.x += p2.vx*dt;
      p2.y += p2.vy*dt;
      // Add gravity to blood particles
      if (p2.hasGravity) {
        p2.vy += 150 * dt; // Gravity effect
      }
      p2.life += dt;
      if (p2.life >= p2.maxLife) p2.alive = false;
    }

    // HUD - batch updates to prevent layout thrashing
    // Cache previous values to avoid unnecessary updates
    const newHp = Math.max(0, Math.floor(p.hp));
    const newStamina = Math.floor(p.stamina);
    const newHeat = Math.floor(p.heat);
    const hpPercent = clamp(p.hp/p.maxHp,0,1)*100;
    const staminaPercent = clamp(p.stamina/100,0,1)*100;
    const heatPercent = clamp(p.heat/p.maxHeat,0,1)*100;
    
    queueDOMUpdate(() => {
      // Only update if values changed
      if (hpTxt._lastValue !== newHp) {
        hpTxt._lastValue = newHp;
        hpTxt.textContent = newHp.toString();
      }
      if (hudHpBar._lastPercent !== hpPercent) {
        // Check if HP is increasing for healing effect
        if (hudHpBar._lastPercent !== undefined && hpPercent > hudHpBar._lastPercent) {
          hudHpBar.parentElement.classList.add('healing');
          clearTimeout(hudHpBar._healingTimeout);
          hudHpBar._healingTimeout = setTimeout(() => {
            hudHpBar.parentElement.classList.remove('healing');
          }, 1500);
        }
        // Check if HP is decreasing for damage effect
        else if (hudHpBar._lastPercent !== undefined && hpPercent < hudHpBar._lastPercent) {
          hudHpBar.parentElement.classList.add('taking-damage');
          clearTimeout(hudHpBar._damageTimeout);
          hudHpBar._damageTimeout = setTimeout(() => {
            hudHpBar.parentElement.classList.remove('taking-damage');
          }, 300);
        }
        hudHpBar._lastPercent = hpPercent;
        hudHpBar.style.width = `${hpPercent}%`;
        // Add/remove low class for pulsing effect
        if (hpPercent <= 30) {
          hudHpBar.parentElement.classList.add('low');
        } else {
          hudHpBar.parentElement.classList.remove('low');
        }
      }
      if (staminaTxt._lastValue !== newStamina) {
        staminaTxt._lastValue = newStamina;
        staminaTxt.textContent = newStamina.toString();
      }
      // Always update the bar width directly without transitions
      hudStaminaBar.style.width = `${staminaPercent}%`;
      
      // Handle stamina state classes with proper thresholds
      if (hudStaminaBar._lastPercent !== undefined) {
        const diff = staminaPercent - hudStaminaBar._lastPercent;
        
        // Only trigger effects for significant changes (>1% difference)
        if (Math.abs(diff) > 1) {
          // Clear any existing timeouts
          clearTimeout(hudStaminaBar._healingTimeout);
          clearTimeout(hudStaminaBar._usageTimeout);
          
          if (diff > 0 && !p.isSprinting) {
            // Stamina is regenerating
            hudStaminaBar.parentElement.classList.remove('using-stamina');
            hudStaminaBar.parentElement.classList.add('healing');
            hudStaminaBar._healingTimeout = setTimeout(() => {
              hudStaminaBar.parentElement.classList.remove('healing');
            }, 1500);
          } else if (diff < 0 && p.isSprinting) {
            // Stamina is being used
            hudStaminaBar.parentElement.classList.remove('healing');
            hudStaminaBar.parentElement.classList.add('using-stamina');
            hudStaminaBar._usageTimeout = setTimeout(() => {
              hudStaminaBar.parentElement.classList.remove('using-stamina');
            }, 200);
          }
        }
      }
      
      // Handle low stamina warning
      if (staminaPercent <= 30) {
        hudStaminaBar.parentElement.classList.add('low');
      } else {
        hudStaminaBar.parentElement.classList.remove('low');
      }
      
      hudStaminaBar._lastPercent = staminaPercent;
      
      // Heat bar updates
      if (heatTxt._lastValue !== newHeat) {
        heatTxt._lastValue = newHeat;
        heatTxt.textContent = newHeat.toString();
      }
      if (hudHeatBar._lastPercent !== heatPercent) {
        hudHeatBar._lastPercent = heatPercent;
        hudHeatBar.style.width = `${heatPercent}%`;
        
        // Remove all heat classes first
        hudHeatBar.parentElement.classList.remove('warning', 'danger', 'overheated');
        
        // Add appropriate heat state class
        if (p.overheated) {
          hudHeatBar.parentElement.classList.add('overheated');
        } else if (heatPercent >= 90) {
          hudHeatBar.parentElement.classList.add('danger');
        } else if (heatPercent >= 75) {
          hudHeatBar.parentElement.classList.add('warning');
        }
      }
      
      if (waveTxt._lastValue !== g.wave) {
        waveTxt._lastValue = g.wave;
        waveTxt.textContent = g.wave.toString();
      }
      if (killsTxt._lastValue !== g.kills) {
        killsTxt._lastValue = g.kills;
        killsTxt.textContent = g.kills.toString();
      }
      
      // Update mobile button states
      if (isMobile && leapBtn) {
        if (p.leapReady) {
          leapBtn.classList.add('ready');
          leapBtn.classList.remove('cooldown');
        } else {
          leapBtn.classList.remove('ready');
          leapBtn.classList.add('cooldown');
          // Update cooldown timer visual
          const cooldownPercent = (p.leapCd / 3.0) * 100;
          if (leapBtn._lastCooldown !== cooldownPercent) {
            leapBtn._lastCooldown = cooldownPercent;
            leapBtn.style.setProperty('--cooldown-percent', `${cooldownPercent}%`);
          }
        }
      }
    });
    
    // Clean up expired effects and patterns (no display needed)
    for (const [effect, shots] of p.activeEffects) {
      if (shots <= 0) p.activeEffects.delete(effect);
    }
    for (const [pattern, shots] of p.patternMultipliers) {
      if (shots <= 0) p.patternMultipliers.delete(pattern);
    }
  }

  /**
   * Main render loop - draws all game entities and UI elements
   * Uses interpolation for smooth 60 FPS regardless of update rate
   * @param {Object} g - Game state object
   * @param {number} alpha - Interpolation factor between frames (0.0 to 1.0)
   */
  function draw(g, alpha){
    // Reset render state for new frame
    resetRenderState();

    // CRITICAL: Reset canvas transform to prevent accumulation bugs
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    
    // Evict oldest gradient cache entries if it gets too large (simple LRU)
    if (gradientCache.size > MAX_GRADIENT_CACHE_SIZE) {
      // Remove the first 20 entries (oldest in Map insertion order)
      let removed = 0;
      for (const key of gradientCache.keys()) {
        gradientCache.delete(key);
        if (++removed >= 20) break; // Remove 20 oldest entries
      }
    }
    
    // clear
    setFillStyle('#0d1015');
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Apply screen shake transform
    if (g.screenShake > 0) {
      ctx.translate(g.screenShakeX, g.screenShakeY);
    }

    // Draw cached background grid (only when needed)
    if (bgNeedsRedraw) {
      if (!bgCanvas) {
        bgCanvas = document.createElement('canvas');
        bgCtx = bgCanvas.getContext('2d');
      }
      bgCanvas.width = canvas.width;
      bgCanvas.height = canvas.height;
      
      // Draw hexagonal tile floor to offscreen canvas
      bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
      
      // Hexagon parameters
      const hexRadius = 28;
      const hexWidth = hexRadius * 2;
      const hexHeight = Math.sqrt(3) * hexRadius;
      const horizontalSpacing = hexWidth * 0.75;
      const verticalSpacing = hexHeight;
      
      // Helper function to draw a hexagon
      function drawHex(cx, cy, radius, isDamaged) {
        bgCtx.save();
        
        // Create gradient for depth effect
        const gradient = bgCtx.createRadialGradient(cx, cy, 0, cx, cy, radius);
        if (isDamaged) {
          // Darker damaged tiles
          gradient.addColorStop(0, '#0c0e12');
          gradient.addColorStop(1, '#090b0e');
        } else {
          // Normal tiles with subtle gradient
          gradient.addColorStop(0, '#111519');
          gradient.addColorStop(0.7, '#0f1318');
          gradient.addColorStop(1, '#0d1015');
        }
        
        // Fill hexagon
        bgCtx.fillStyle = gradient;
        bgCtx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 3) * i - Math.PI / 6;
          const x = cx + radius * Math.cos(angle);
          const y = cy + radius * Math.sin(angle);
          if (i === 0) bgCtx.moveTo(x, y);
          else bgCtx.lineTo(x, y);
        }
        bgCtx.closePath();
        bgCtx.fill();
        
        // Subtle border
        bgCtx.strokeStyle = '#151a20';
        bgCtx.lineWidth = 0.5;
        bgCtx.globalAlpha = 0.3;
        bgCtx.stroke();
        
        bgCtx.restore();
      }
      
      // Draw hexagonal grid
      const cols = Math.ceil(canvas.width / horizontalSpacing) + 2;
      const rows = Math.ceil(canvas.height / verticalSpacing) + 2;
      
      for (let row = -1; row < rows; row++) {
        for (let col = -1; col < cols; col++) {
          const x = col * horizontalSpacing;
          const y = row * verticalSpacing + (col % 2) * (hexHeight / 2);
          
          // 5% chance for damaged/darker tile
          const isDamaged = Math.random() < 0.05;
          drawHex(x, y, hexRadius, isDamaged);
        }
      }
      
      bgNeedsRedraw = false;
    }
    // Blit pre-drawn background
    ctx.drawImage(bgCanvas, 0, 0);

    // blood stains - individual rendering for proper alpha fading
    ctx.save();
    
    // Draw settled stains with individual alpha
    for (const stain of bloodStains.items){
      if (!stain.alive || !stain.settled) continue;
      ctx.fillStyle = '#600000';
      ctx.globalAlpha = stain.alpha * 0.8; // Apply individual fade
      ctx.beginPath();
      ctx.arc(stain.x, stain.y, stain.size * 1.5, 0, TAU);
      ctx.fill();
    }
    
    // Draw moving droplets with individual alpha
    for (const stain of bloodStains.items){
      if (!stain.alive || stain.settled) continue;
      ctx.fillStyle = '#cc0000';
      ctx.globalAlpha = stain.alpha * 0.9; // Apply individual fade
      ctx.beginPath();
      ctx.arc(stain.x, stain.y, stain.size, 0, TAU);
      ctx.fill();
    }
    
    // Draw footsteps with sophisticated appearance
    for (const footstep of footsteps.items) {
      if (!footstep.alive || footstep.alpha <= 0) continue;
      
      ctx.save();
      ctx.translate(footstep.x, footstep.y);
      ctx.rotate(footstep.angle);
      
      // Subtle outer glow/shadow for depth
      ctx.fillStyle = '#0a0a0a'; // Very dark shadow
      ctx.globalAlpha = footstep.alpha * 0.3;
      
      // Shadow slightly larger and offset
      ctx.save();
      ctx.scale(1.15, 1.15);
      ctx.translate(1, 1);
      
      // Shadow foot pad
      ctx.beginPath();
      ctx.ellipse(-footstep.size * 0.2, 0, footstep.size * 0.35, footstep.size * 0.7, 0, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(footstep.size * 0.3, 0, footstep.size * 0.25, footstep.size * 0.35, 0, 0, TAU);
      ctx.fill();
      ctx.restore();
      
      // Main footprint with gradient
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, footstep.size);
      gradient.addColorStop(0, '#4a3a28'); // Lighter tan center
      gradient.addColorStop(0.7, '#3d2f1f'); // Dark tan
      gradient.addColorStop(1, '#2a2015'); // Darker edge
      
      ctx.fillStyle = gradient;
      ctx.globalAlpha = footstep.alpha;
      
      // Draw a realistic footprint shape
      // Main foot pad (heel to ball)
      ctx.beginPath();
      ctx.ellipse(-footstep.size * 0.2, 0, footstep.size * 0.35, footstep.size * 0.7, 0, 0, TAU);
      ctx.fill();
      
      // Toe area (smaller circle at front)
      ctx.beginPath();
      ctx.ellipse(footstep.size * 0.3, 0, footstep.size * 0.25, footstep.size * 0.35, 0, 0, TAU);
      ctx.fill();
      
      // Small toe marks with slightly different color
      if (footstep.isPlayer) {
        ctx.fillStyle = '#3a2c1c'; // Slightly different shade for toes
        ctx.globalAlpha = footstep.alpha * 0.9;
        // Player gets slightly more detailed footprints
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          const toeX = footstep.size * 0.5 + i * footstep.size * 0.08;
          const toeY = (i - 1) * footstep.size * 0.12;
          ctx.arc(toeX, toeY, footstep.size * 0.06, 0, TAU);
          ctx.fill();
        }
      }
      
      ctx.restore();
    }
    
    ctx.restore(); // Restore the save from line 6374 (blood stains and footsteps section)

    // draw player with leap glow
    const p = g.player;
    ctx.save();
    
    // Leap ready glow effect
    if (p.leapReady) {
      const glowIntensity = 0.7 + 0.3 * fastSin(g.t * 6); // Pulsing glow
      const glowRadius = p.radius + 8;
      
      // Outer glow (cached)
      const glowKey = `leap_${((glowRadius*100)|0)}_${((glowIntensity*100)|0)}`;
      let outerGradient = gradientCache.get(glowKey);
      if (!outerGradient) {
        outerGradient = ctx.createRadialGradient(p.x, p.y, p.radius, p.x, p.y, glowRadius);
        outerGradient.addColorStop(0, `rgba(0, 255, 255, ${glowIntensity * 0.3})`);
        outerGradient.addColorStop(0.7, `rgba(0, 255, 255, ${glowIntensity * 0.2})`);
        outerGradient.addColorStop(1, `rgba(0, 255, 255, 0)`);
        gradientCache.set(glowKey, outerGradient);
      }
      ctx.fillStyle = outerGradient;
      ctx.beginPath();
      ctx.arc(p.x, p.y, glowRadius, 0, TAU);
      ctx.fill();
      
      // Inner rim glow
      ctx.strokeStyle = `rgba(0, 255, 255, ${glowIntensity * 0.8})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius + 2, 0, TAU);
      ctx.stroke();
    }
    
    // Overheat visual effects
    if (p.overheated) {
      // Pulsing red warning glow
      const overheatPulse = 0.5 + 0.5 * fastSin(g.t * 12);
      const overheatRadius = p.radius + 12;
      
      // Red overheat aura
      const overheatKey = `overheat_${((overheatPulse*100)|0)}`;
      let overheatGradient = gradientCache.get(overheatKey);
      if (!overheatGradient) {
        overheatGradient = ctx.createRadialGradient(p.x, p.y, p.radius, p.x, p.y, overheatRadius);
        overheatGradient.addColorStop(0, `rgba(255, 0, 0, ${overheatPulse * 0.6})`);
        overheatGradient.addColorStop(0.5, `rgba(255, 100, 0, ${overheatPulse * 0.4})`);
        overheatGradient.addColorStop(1, `rgba(255, 0, 0, 0)`);
        gradientCache.set(overheatKey, overheatGradient);
      }
      ctx.fillStyle = overheatGradient;
      ctx.beginPath();
      ctx.arc(p.x, p.y, overheatRadius, 0, TAU);
      ctx.fill();
    } else if (p.heat >= 75) {
      // Warning glow for high heat
      const heatIntensity = (p.heat - 75) / 25; // 0 to 1 as heat goes 75-100
      const heatPulse = 0.7 + 0.3 * fastSin(g.t * 8);
      const heatRadius = p.radius + 6;
      
      ctx.fillStyle = `rgba(255, ${150 - heatIntensity * 100}, 0, ${heatPulse * heatIntensity * 0.4})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, heatRadius, 0, TAU);
      ctx.fill();
    }
    
    // Player invulnerability flash
    if (g.invulTime > 0){
      ctx.globalAlpha = 0.6 + 0.4*fastSin(g.t*40);
    }
    
    // Main player body - color changes based on heat
    if (p.overheated) {
      ctx.fillStyle = '#ff4444'; // Red when overheated
    } else if (p.heat >= 90) {
      ctx.fillStyle = '#ff8800'; // Orange when very hot
    } else if (p.heat >= 75) {
      ctx.fillStyle = '#ffaa00'; // Yellow-orange when hot
    } else if (p.heat >= 50) {
      ctx.fillStyle = '#88ff00'; // Yellow-green when warm
    } else {
      ctx.fillStyle = '#00ff00'; // Normal green
    }
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, TAU);
    ctx.fill();
    ctx.restore();

    // crosshair
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = '#34d1ff';
    ctx.beginPath();
    ctx.arc(mouseX, mouseY, 10, 0, TAU);
    ctx.moveTo(mouseX-14, mouseY); ctx.lineTo(mouseX-4, mouseY);
    ctx.moveTo(mouseX+14, mouseY); ctx.lineTo(mouseX+4, mouseY);
    ctx.moveTo(mouseX, mouseY-14); ctx.lineTo(mouseX, mouseY-4);
    ctx.moveTo(mouseX, mouseY+14); ctx.lineTo(mouseX, mouseY+4);
    ctx.stroke();
    ctx.restore();

    // enemies
    for (const e of enemies.items){
      if (!e.alive) continue;
      
      // Super boss phase-based visual effects
      if (e.behavior === 'superboss') {
        ctx.save();
        
        // Phase-based color modulation
        const phase = e.currentPhase || 0;
        const phaseColors = ['#800080', '#ff0080', '#ff8000', '#8000ff'];
        const pulseIntensity = 0.7 + 0.3 * fastSin(g.t * 6);
        
        // Intimidating aura (cached)
        const auraRadius = e.r + 20;
        const auraKey = `boss_${phase}_${((pulseIntensity*100)|0)}`;
        let auraGradient = gradientCache.get(auraKey);
        if (!auraGradient) {
          auraGradient = ctx.createRadialGradient(e.x, e.y, e.r, e.x, e.y, auraRadius);
          auraGradient.addColorStop(0, `${phaseColors[phase]}80`);
          auraGradient.addColorStop(1, `${phaseColors[phase]}00`);
          gradientCache.set(auraKey, auraGradient);
        }
        ctx.fillStyle = auraGradient;
        ctx.beginPath();
        ctx.arc(e.x, e.y, auraRadius, 0, TAU);
        ctx.fill();
        
        // Main boss body with phase color
        ctx.fillStyle = phaseColors[phase] || '#800080'; // Fallback to purple if undefined
        ctx.globalAlpha = pulseIntensity;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, TAU);
        ctx.fill();
        
        // Phase indicator ring
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r + 8, 0, TAU);
        ctx.stroke();
        
        // Draw overlord symbol
        EnemyAI.drawSymbol(ctx, e, e.x, e.y, e.r);
        
        ctx.restore();
      } else {
        // Normal enemy rendering with shadow
        ctx.save();
        
        // Apply spawn animation - ENSURE MINIMUM VISIBILITY
        if (e.spawnTimer && e.spawnTimer > 0) {
          const progress = Math.max(0.3, 1 - (e.spawnTimer / 0.5)); // MINIMUM 30% visibility
          if (e.spawnAnimation === 'fade') {
            ctx.globalAlpha = progress;
          } else if (e.spawnAnimation === 'scale') {
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.scale(progress, progress);
            ctx.translate(-e.x, -e.y);
            
            // Draw the enemy while scaled
            // SIMPLE COLOR SYSTEM - ALWAYS HAVE A VALID COLOR
            let renderColor = '#ff4444'; // Default bright red - ALWAYS visible
            
            // Get the color, with multiple fallbacks
            if (e.color && e.color !== '' && e.color !== 'undefined' && e.color !== 'null') {
              renderColor = e.color;
            } else if (e.originalColor && e.originalColor !== '' && e.originalColor !== 'undefined') {
              renderColor = e.originalColor;
            } else if (e.baseColor && e.baseColor !== '' && e.baseColor !== 'undefined') {
              renderColor = e.baseColor;
            }
            
            // Apply crit flash if needed
            if (e.critFlashTimer > 0) {
              renderColor = '#ffff88';
            }
            
            // ALWAYS use a valid color
            ctx.fillStyle = renderColor;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r, 0, TAU);
            ctx.fill();
            
            ctx.restore(); // ALWAYS restore after scale
            
            // Draw enemy symbol AFTER scale restore to prevent distortion
            EnemyAI.drawSymbol(ctx, e, e.x, e.y, e.r);
          } else {
            // No scale animation, draw normally
            let renderColor = '#ff4444';
            if (e.color && e.color !== '' && e.color !== 'undefined' && e.color !== 'null') {
              renderColor = e.color;
            } else if (e.originalColor && e.originalColor !== '' && e.originalColor !== 'undefined') {
              renderColor = e.originalColor;
            } else if (e.baseColor && e.baseColor !== '' && e.baseColor !== 'undefined') {
              renderColor = e.baseColor;
            }
            if (e.critFlashTimer > 0) {
              renderColor = '#ffff88';
            }
            ctx.fillStyle = renderColor;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.r, 0, TAU);
            ctx.fill();
            EnemyAI.drawSymbol(ctx, e, e.x, e.y, e.r);
          }
        } else {
          // No spawn animation at all
          let renderColor = '#ff4444';
          if (e.color && e.color !== '' && e.color !== 'undefined' && e.color !== 'null') {
            renderColor = e.color;
          } else if (e.originalColor && e.originalColor !== '' && e.originalColor !== 'undefined') {
            renderColor = e.originalColor;
          } else if (e.baseColor && e.baseColor !== '' && e.baseColor !== 'undefined') {
            renderColor = e.baseColor;
          }
          if (e.critFlashTimer > 0) {
            renderColor = '#ffff88';
          }
          ctx.fillStyle = renderColor;
          ctx.beginPath();
          ctx.arc(e.x, e.y, e.r, 0, TAU);
          ctx.fill();
          EnemyAI.drawSymbol(ctx, e, e.x, e.y, e.r);
        }
        
        ctx.restore();
        
        // Shield rendering - ONLY for slowpush enemies
        if (e.behavior === 'juggernaut' && e.hasShield && e.shieldHP > 0) {
          // Use lagged shield direction instead of instant player direction
          const shieldDir = e.shieldDirection || { x: 1, y: 0 };
          const shieldOffset = e.r * 1.3; // Shield positioned just outside enemy body
          const shieldX = e.x + shieldDir.x * shieldOffset;
          const shieldY = e.y + shieldDir.y * shieldOffset;
          
          // Shield dimensions (when properly oriented)
          const shieldLength = e.r * 1.2;  // Length of shield (perpendicular to direction)
          const shieldThickness = e.r * 0.8; // Thickness of shield (along direction)
          
          // Calculate angle to rotate shield perpendicular to enemy-player line
          const shieldAngle = Math.atan2(shieldDir.y, shieldDir.x);
          
          // Shield health-based transparency
          const shieldAlpha = Math.max(0.3, e.shieldHP / e.maxShieldHP);
          
          ctx.save();
          ctx.globalAlpha = shieldAlpha;
          
          // Translate to shield position and rotate perpendicular
          ctx.translate(shieldX, shieldY);
          ctx.rotate(shieldAngle + Math.PI/2); // Rotate 90 degrees to be perpendicular
          
          // Draw shield (now properly oriented as a wall)
          ctx.fillStyle = '#cccccc'; // Light gray shield (very visible)
          ctx.fillRect(-shieldLength/2, -shieldThickness/2, shieldLength, shieldThickness);
          
          // Shield border
          ctx.strokeStyle = '#aaaaaa';
          ctx.lineWidth = 1;
          ctx.strokeRect(-shieldLength/2, -shieldThickness/2, shieldLength, shieldThickness);
          
          ctx.restore();
        }
      }
    }

    // player bullets - batched rendering
    setFillStyle('#e3e7ef');
    ctx.beginPath();
    for (const b of bullets.items){
      if (!b.alive) continue;
      ctx.moveTo(b.x + b.r, b.y);
      ctx.arc(b.x, b.y, b.r, 0, TAU);
    }
    ctx.fill();

    // enemy bullets - batched rendering
    setFillStyle('#ff4444');
    ctx.beginPath();
    for (const eb of enemyBullets.items){
      if (!eb.alive) continue;
      ctx.moveTo(eb.x + eb.r, eb.y);
      ctx.arc(eb.x, eb.y, eb.r, 0, TAU);
    }
    ctx.fill();

    // pickups
    for (const pickup of pickups.items){
      if (!pickup.alive) continue;
      ctx.save();
      
      // Apply rotation if crystal has it
      if (pickup.rotation !== undefined) {
        ctx.translate(pickup.x, pickup.y);
        ctx.rotate(pickup.rotation);
        ctx.translate(-pickup.x, -pickup.y);
      }
      
      // Enhanced animated sparkle effect
      const sparkle = 0.7 + 0.3 * fastSin(g.t * 12 + pickup.bounceTimer * 3);
      ctx.globalAlpha = sparkle;
      
      // Glow effect removed - no shadows
      
      // Color based on pickup type
      const powerup = bulletPowerupMap.get(pickup.type);
      
      // Special glow effects for homing crystals (gold)
      if (pickup.type === 'homing') {
        // Golden glow aura
        const glowIntensity = 0.7 + 0.3 * fastSin(g.t * 15 + pickup.bounceTimer * 5);
        const glowSize = 25 + 10 * fastSin(g.t * 8);
        
        // Cache expensive gradient creation (numeric key is faster)
        const glowKey = ((glowSize*100)|0) * 10000 + ((glowIntensity*100)|0);
        let outerGlow = gradientCache.get(glowKey);
        if (!outerGlow) {
          outerGlow = ctx.createRadialGradient(0, 0, 8, 0, 0, glowSize);
          const alpha08 = (glowIntensity * 0.8).toFixed(2);
          const alpha04 = (glowIntensity * 0.4).toFixed(2);
          outerGlow.addColorStop(0, 'rgba(255,215,0,' + alpha08 + ')');
          outerGlow.addColorStop(0.5, 'rgba(255,215,0,' + alpha04 + ')');
          outerGlow.addColorStop(1, 'rgba(255,215,0,0)');
          gradientCache.set(glowKey, outerGlow);
        }
        ctx.fillStyle = outerGlow;
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, glowSize, 0, TAU);
        ctx.fill();
        
        // Inner bright core (cached)
        const coreKey = `core_${((glowIntensity*100)|0)}`;
        let coreGlow = gradientCache.get(coreKey);
        if (!coreGlow) {
          coreGlow = ctx.createRadialGradient(pickup.x, pickup.y, 0, pickup.x, pickup.y, 12);
          coreGlow.addColorStop(0, `rgba(255, 255, 255, ${glowIntensity * 0.9})`);
          coreGlow.addColorStop(0.3, `rgba(255, 235, 59, ${glowIntensity * 0.7})`);
          coreGlow.addColorStop(1, `rgba(255, 215, 0, ${glowIntensity * 0.3})`);
          gradientCache.set(coreKey, coreGlow);
        }
        ctx.fillStyle = coreGlow;
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, 12, 0, TAU);
        ctx.fill();
      }
      
      // Draw based on pickup type
      if (pickup.type === 'detonator') {
        // Remote Detonator - Rectangle with red center and black rim
        const width = 20;
        const height = 14;
        
        // Black rim
        ctx.fillStyle = '#000000';
        ctx.fillRect(pickup.x - width/2, pickup.y - height/2, width, height);
        
        // Red center
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(pickup.x - width/2 + 2, pickup.y - height/2 + 2, width - 4, height - 4);
        
        // Small yellow button in center
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(pickup.x - 3, pickup.y - 3, 6, 6);
      } else {
        // Enhanced crystal drawing with multi-layered structure
        const size = pickup.type === 'homing' ? 15 : 12;
        const baseColor = powerup ? powerup.color : '#ffffff';
        
        // 1. Different crystal shapes for different types
        const gradient = ctx.createRadialGradient(pickup.x, pickup.y, 0, pickup.x, pickup.y, size);
        
        // Parse color and create gradient (darker edges to lighter center)
        if (pickup.type === 'homing') {
          // Special gradient for homing
          gradient.addColorStop(0, '#ffffff');
          gradient.addColorStop(0.5, baseColor);
          gradient.addColorStop(1, baseColor + '88');
        } else if (pickup.type === 'lightning') {
          // Yellow/blue gradient for lightning
          gradient.addColorStop(0, '#FFFF00');
          gradient.addColorStop(0.3, '#FFD700');
          gradient.addColorStop(0.6, '#87CEEB');
          gradient.addColorStop(1, '#87CEEB66');
        } else {
          gradient.addColorStop(0, baseColor);
          gradient.addColorStop(0.7, baseColor + 'cc');
          gradient.addColorStop(1, baseColor + '66');
        }
        
        ctx.fillStyle = gradient;
        ctx.strokeStyle = pickup.type === 'homing' ? '#FFFFFF' : '#ffffff88';
        ctx.lineWidth = pickup.type === 'homing' ? 2 : 1;
        
        // Draw different shapes based on crystal type
        ctx.beginPath();
        
        if (pickup.type === 'homing') {
          // Star shape for homing
          for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI / 4) - Math.PI / 2;
            const radius = i % 2 === 0 ? size : size * 0.5;
            const x = pickup.x + Math.cos(angle) * radius;
            const y = pickup.y + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (pickup.type === 'explosive') {
          // Hexagon for explosive
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI / 3) - Math.PI / 6;
            const x = pickup.x + Math.cos(angle) * size;
            const y = pickup.y + Math.sin(angle) * size;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (pickup.type === 'lightning') {
          // Lightning bolt shape - simple zig-zag
          ctx.moveTo(pickup.x - size*0.3, pickup.y - size);
          ctx.lineTo(pickup.x + size*0.2, pickup.y - size*0.3);
          ctx.lineTo(pickup.x - size*0.1, pickup.y);
          ctx.lineTo(pickup.x + size*0.3, pickup.y + size);
          ctx.lineTo(pickup.x - size*0.2, pickup.y + size*0.3);
          ctx.lineTo(pickup.x, pickup.y);
          // Don't manually close - let closePath() handle it
        } else if (pickup.type === 'freeze') {
          // Snowflake shape (6-pointed star)
          for (let i = 0; i < 12; i++) {
            const angle = (i * Math.PI / 6) - Math.PI / 2;
            const radius = i % 2 === 0 ? size : size * 0.4;
            const x = pickup.x + Math.cos(angle) * radius;
            const y = pickup.y + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (pickup.type === 'ricochet') {
          // Triangle for ricochet
          ctx.moveTo(pickup.x, pickup.y - size);
          ctx.lineTo(pickup.x + size * 0.866, pickup.y + size * 0.5);
          ctx.lineTo(pickup.x - size * 0.866, pickup.y + size * 0.5);
        } else if (pickup.type === 'shotgun') {
          // Stylized connected spread crystal for shotgun
          // Main body with flared end
          ctx.moveTo(pickup.x - size * 0.3, pickup.y + size * 0.4);
          ctx.lineTo(pickup.x - size * 0.3, pickup.y - size * 0.4);
          ctx.lineTo(pickup.x + size * 0.2, pickup.y - size * 0.3);
          // Top spread arm
          ctx.lineTo(pickup.x + size * 0.5, pickup.y - size * 0.7);
          ctx.lineTo(pickup.x + size * 0.8, pickup.y - size * 0.6);
          ctx.lineTo(pickup.x + size * 0.6, pickup.y - size * 0.3);
          // Middle spread arm
          ctx.lineTo(pickup.x + size * 0.7, pickup.y);
          ctx.lineTo(pickup.x + size * 0.9, pickup.y);
          ctx.lineTo(pickup.x + size * 0.7, pickup.y);
          // Bottom spread arm
          ctx.lineTo(pickup.x + size * 0.6, pickup.y + size * 0.3);
          ctx.lineTo(pickup.x + size * 0.8, pickup.y + size * 0.6);
          ctx.lineTo(pickup.x + size * 0.5, pickup.y + size * 0.7);
          ctx.lineTo(pickup.x + size * 0.2, pickup.y + size * 0.3);
        } else if (pickup.type === 'cluster') {
          // Three overlapping circles for cluster
          ctx.arc(pickup.x - size*0.4, pickup.y, size*0.6, 0, TAU);
          ctx.moveTo(pickup.x + size*0.4 + size*0.6, pickup.y - size*0.3);
          ctx.arc(pickup.x + size*0.4, pickup.y - size*0.3, size*0.6, 0, TAU);
          ctx.moveTo(pickup.x + size*0.4 + size*0.6, pickup.y + size*0.3);
          ctx.arc(pickup.x + size*0.4, pickup.y + size*0.3, size*0.6, 0, TAU);
        } else if (pickup.type === 'seeking') {
          // Cool stylized arrow with swept-back wings
          // Arrow tip
          ctx.moveTo(pickup.x, pickup.y - size);
          // Right wing
          ctx.lineTo(pickup.x + size*0.8, pickup.y - size*0.2);
          ctx.lineTo(pickup.x + size*0.5, pickup.y);
          // Right shaft indent
          ctx.lineTo(pickup.x + size*0.3, pickup.y - size*0.1);
          // Shaft
          ctx.lineTo(pickup.x + size*0.2, pickup.y + size*0.6);
          // Right tail fin
          ctx.lineTo(pickup.x + size*0.6, pickup.y + size*0.8);
          ctx.lineTo(pickup.x + size*0.2, pickup.y + size);
          // Bottom center
          ctx.lineTo(pickup.x, pickup.y + size*0.7);
          // Left tail fin
          ctx.lineTo(pickup.x - size*0.2, pickup.y + size);
          ctx.lineTo(pickup.x - size*0.6, pickup.y + size*0.8);
          // Left shaft
          ctx.lineTo(pickup.x - size*0.2, pickup.y + size*0.6);
          // Left shaft indent
          ctx.lineTo(pickup.x - size*0.3, pickup.y - size*0.1);
          // Left wing
          ctx.lineTo(pickup.x - size*0.5, pickup.y);
          ctx.lineTo(pickup.x - size*0.8, pickup.y - size*0.2);
        } else {
          // Default diamond shape (for dual, triple, quad)
          ctx.moveTo(pickup.x, pickup.y - size);
          ctx.lineTo(pickup.x + size, pickup.y);
          ctx.lineTo(pickup.x, pickup.y + size);
          ctx.lineTo(pickup.x - size, pickup.y);
        }
        
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // 2. Pulsing inner glow based on crystal type
        let pulseSpeed = 4;
        let pulseIntensity = 0.3;
        
        // Different pulse patterns for different crystal types
        if (pickup.type === 'homing') {
          pulseSpeed = 8; // Fast pulse for homing
          pulseIntensity = 0.5;
        } else if (pickup.type === 'explosive') {
          pulseSpeed = 3; // Slow, intense pulse
          pulseIntensity = 0.4;
        } else if (pickup.type === 'lightning') {
          pulseSpeed = 10; // Very fast flicker
          pulseIntensity = 0.6;
        } else if (pickup.type === 'freeze') {
          pulseSpeed = 2; // Very slow, gentle
          pulseIntensity = 0.2;
        }
        
        const pulse = Math.max(0, Math.sin(game.t * pulseSpeed) * pulseIntensity + (1 - pulseIntensity));
        const coreSize = size * 0.3 * pulse;
        
        ctx.save();
        ctx.globalAlpha = 0.8;
        const coreGradient = ctx.createRadialGradient(pickup.x, pickup.y, 0, pickup.x, pickup.y, coreSize);
        coreGradient.addColorStop(0, '#ffffff');
        coreGradient.addColorStop(0.5, baseColor);
        coreGradient.addColorStop(1, baseColor + '00');
        
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, coreSize, 0, TAU);
        ctx.fill();
        ctx.restore();
        
        // 3. Particle effects (sparkles/energy wisps)
        // Initialize particle timer if not exists
        if (!pickup.particleTimer) pickup.particleTimer = 0;
        pickup.particleTimer += 0.016; // Approximate dt
        
        // Spawn sparkle particles periodically
        const particleInterval = pickup.type === 'lightning' ? 0.15 : 0.3; // Lightning spawns more frequently
        if (pickup.particleTimer > particleInterval) {
          pickup.particleTimer = 0;
          
          // Spawn more particles for lightning
          const particleCount = pickup.type === 'homing' ? 3 : 
                               pickup.type === 'lightning' ? 4 : 2;
          for (let i = 0; i < particleCount; i++) {
            particles.spawn(p => {
              const angle = Math.random() * TAU;
              const distance = size + Math.random() * 10;
              p.x = pickup.x + Math.cos(angle) * distance;
              p.y = pickup.y + Math.sin(angle) * distance;
              
              // Energy wisps float upward
              p.vx = (Math.random() - 0.5) * 20;
              p.vy = -30 - Math.random() * 20; // Upward movement
              
              p.life = 0;
              p.maxLife = 0.8 + Math.random() * 0.4;
              p.size = 1 + Math.random() * 2;
              // Use bright cyan for lightning particles for visibility
              p.color = pickup.type === 'homing' ? '#ffffff' : 
                       pickup.type === 'lightning' ? '#00FFFF' : 
                       baseColor;
              p.hasGravity = false;
              p.alive = true;
            });
          }
        }
        
      }
      
      ctx.restore();
    }

    // mines and grenades - explosive devices
    for (const mine of mines.items) {
      if (!mine.alive) continue;
      
      // Different rendering for grenades vs mines
      if (mine.isGrenade) {
        // Calculate grenade position with height offset
        const drawY = mine.y - (mine.z || 0) * 0.5; // Visual height offset
        const size = mine.r || 6;
        
        // Shadow on ground (shows where grenade will land)
        if (mine.z > 0) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.beginPath();
          ctx.ellipse(mine.x, mine.y, size * 0.8, size * 0.4, 0, 0, TAU);
          ctx.fill();
        }
        
        // Grenade body - red color
        ctx.fillStyle = mine.isTriggered ? '#ff0000' : '#cc0000'; // Bright red when triggered
        ctx.strokeStyle = mine.isTriggered ? '#ffaa00' : '#660000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(mine.x, drawY, size, 0, TAU);
        ctx.fill();
        ctx.stroke();
        
        // Add spinning effect
        ctx.strokeStyle = '#990000';
        ctx.lineWidth = 1;
        const spin = mine.fuseTime * 10;
        ctx.beginPath();
        ctx.moveTo(mine.x + Math.cos(spin) * size, drawY + Math.sin(spin) * size);
        ctx.lineTo(mine.x - Math.cos(spin) * size, drawY - Math.sin(spin) * size);
        ctx.stroke();
        
        // Motion trail for flying grenades
        if ((mine.vx !== 0 || mine.vy !== 0) && mine.z > 0) {
          // Normalize trail length to prevent huge lines
          const trailLength = 15; // Fixed trail length in pixels
          const speed = Math.sqrt(mine.vx * mine.vx + mine.vy * mine.vy);
          if (speed > 0) {
            const trailX = (mine.vx / speed) * trailLength;
            const trailY = (mine.vy / speed) * trailLength;
            
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
            ctx.lineWidth = size * 0.6;
            ctx.beginPath();
            ctx.moveTo(mine.x, drawY);
            ctx.lineTo(mine.x - trailX, drawY - trailY);
            ctx.stroke();
          }
        }
      } else {
        // Regular mine
        ctx.fillStyle = mine.isArmed ? '#ff4400' : '#994400'; // Orange when armed, dark orange when not
        ctx.beginPath();
        ctx.arc(mine.x, mine.y, mine.r, 0, TAU);
        ctx.fill();
        
        // Show trigger radius for armed mines (static circle)
        if (mine.isArmed && !mine.isTriggered) {
          ctx.strokeStyle = 'rgba(255, 100, 0, 0.3)'; // Faint orange circle
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]); // Small dashed circle
          ctx.beginPath();
          ctx.arc(mine.x, mine.y, mine.triggerRadius, 0, TAU);
          ctx.stroke();
          ctx.setLineDash([]); // Reset line dash
        }
      }
      
      // Flashing effect when triggered and about to explode
      if (mine.isTriggered) {
        const flashRate = Math.min(20, mine.fuseTime * 15); // Accelerating flash
        if (Math.sin(mine.flashTimer * flashRate) > 0) {
          ctx.fillStyle = '#ffff00'; // Bright yellow flash
          ctx.beginPath();
          ctx.arc(mine.x, mine.y, mine.r, 0, TAU);
          ctx.fill();
        }
        
        // Pulsing explosion radius warning circle (doubled size)
        const pulseIntensity = 0.4 + 0.5 * Math.sin(mine.flashTimer * flashRate * 0.8);
        ctx.strokeStyle = `rgba(255, 255, 0, ${pulseIntensity})`;
        ctx.lineWidth = 3;
        ctx.setLineDash([8, 4]); // Bigger dashed circle
        ctx.beginPath();
        ctx.arc(mine.x, mine.y, mine.explosionRadius, 0, TAU);
        ctx.stroke();
        ctx.setLineDash([]); // Reset line dash
      }
      
      // Mine spikes/details
      ctx.strokeStyle = '#663300';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * TAU;
        const spike = mine.r + 2;
        ctx.moveTo(mine.x, mine.y);
        ctx.lineTo(mine.x + fastCos(angle) * spike, mine.y + fastSin(angle) * spike);
      }
      ctx.stroke();
    }

    // particles
    for (const p2 of particles.items){
      if (!p2.alive) continue;
      const a = 1 - p2.life/p2.maxLife;
      ctx.globalAlpha = a*0.9;
      ctx.fillStyle = p2.color;
      ctx.fillRect(p2.x, p2.y, p2.size, p2.size);
      ctx.globalAlpha = 1;
    }

    // Red damage vignette (cached)
    if (g.damageFlash > 0) {
      const intensity = g.damageFlash / 0.3; // Fade from 1 to 0
      const vignetteKey = `vignette_${((intensity*100)|0)}`;
      let gradient = gradientCache.get(vignetteKey);
      if (!gradient) {
        gradient = ctx.createRadialGradient(
          canvas.width/2, canvas.height/2, 0,
          canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)
        );
        gradient.addColorStop(0, `rgba(255, 0, 0, 0)`);
        gradient.addColorStop(0.7, `rgba(255, 0, 0, ${intensity * 0.1})`);
        gradient.addColorStop(1, `rgba(255, 0, 0, ${intensity * 0.4})`);
        gradientCache.set(vignetteKey, gradient);
      }
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Crystal inventory display under HUD
    const crystalInventoryY = 280; // Moved further down to avoid Wave/Kills text overlap
    const crystalSize = 60; // 50% larger than 40 = 60
    const crystalSpacing = 75; // Adjust spacing for larger crystals
    let inventoryIndex = 0;
    
    // Show dual shot if active
    if (g.player.upgradeShots > 0) {
      const x = 50; // Moved right to prevent clipping (crystal extends 30px left from center)
      const y = crystalInventoryY + (inventoryIndex * crystalSpacing);
      
      // Don't draw if it would go off screen
      if (y + crystalSize/2 < canvas.height - 20) {
        ctx.save();
        
        // Enhanced sparkle effect for inventory
        const sparkle = 0.6 + 0.4 * fastSin(g.t * 10 + inventoryIndex * 0.5);
        ctx.globalAlpha = sparkle;
        
        // Add pulsing glow
        // No shadow effects
        
        // Create gradient for dual shot
        const dualGradient = ctx.createRadialGradient(x, y, 0, x, y, crystalSize/2);
        dualGradient.addColorStop(0, '#32CD32');
        dualGradient.addColorStop(0.7, '#32CD32cc');
        dualGradient.addColorStop(1, '#32CD3266');
        
        ctx.fillStyle = dualGradient;
        ctx.strokeStyle = '#ffffff88';
        ctx.lineWidth = 1.5;
        
        // Draw diamond shape for dual shot
        ctx.beginPath();
        ctx.moveTo(x, y - crystalSize/2);
        ctx.lineTo(x + crystalSize/2, y);
        ctx.lineTo(x, y + crystalSize/2);
        ctx.lineTo(x - crystalSize/2, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Draw crystal name
        ctx.fillStyle = '#e3e7ef';
        ctx.font = '18px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('Dual Shot', x + crystalSize/2 + 8, y + 4);
        
        ctx.restore();
        
        inventoryIndex++;
      }
    }
    
    // Show pattern multipliers
    for (const [pattern, shots] of g.player.patternMultipliers) {
      if (shots > 0) {
        const x = 50;
        const y = crystalInventoryY + (inventoryIndex * crystalSpacing);
        
        // Don't draw if it would go off screen
        if (y + crystalSize/2 < canvas.height - 20) {
          ctx.save();
          
          // Enhanced sparkle effect for inventory
          const sparkle = 0.6 + 0.4 * fastSin(g.t * 10 + inventoryIndex * 0.5);
          ctx.globalAlpha = sparkle;
          
          const powerup = bulletPowerupMap.get(pattern);
          
          // Add pulsing glow
          // No shadow effects
          
          // Create gradient for pattern crystals
          const patternGradient = ctx.createRadialGradient(x, y, 0, x, y, crystalSize/2);
          const baseColor = powerup ? powerup.color : '#ffffff';
          
          if (pattern === 'triple') {
            // Use correct blue color for triple
            patternGradient.addColorStop(0, '#00BFFF');
            patternGradient.addColorStop(0.7, '#00BFFFcc');
            patternGradient.addColorStop(1, '#00BFFF66');
          } else if (pattern === 'quad') {
            patternGradient.addColorStop(0, baseColor);
            patternGradient.addColorStop(0.7, baseColor + 'cc');
            patternGradient.addColorStop(1, baseColor + '66');
          } else {
            patternGradient.addColorStop(0, baseColor);
            patternGradient.addColorStop(0.7, baseColor + 'cc');
            patternGradient.addColorStop(1, baseColor + '66');
          }
          
          ctx.fillStyle = patternGradient;
          ctx.strokeStyle = '#ffffff88';
          ctx.lineWidth = 1.5;
          
          // Draw diamond shape for patterns
          ctx.beginPath();
          ctx.moveTo(x, y - crystalSize/2);
          ctx.lineTo(x + crystalSize/2, y);
          ctx.lineTo(x, y + crystalSize/2);
          ctx.lineTo(x - crystalSize/2, y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Draw crystal name
          ctx.fillStyle = '#e3e7ef';
          ctx.font = '18px system-ui';
          ctx.textAlign = 'left';
          const crystalName = powerup ? powerup.name : pattern;
          ctx.fillText(crystalName, x + crystalSize/2 + 8, y + 4);
          
          ctx.restore();
          
          inventoryIndex++;
        }
      }
    }
    
    // Show active effects
    for (const [effect, shots] of g.player.activeEffects) {
      if (shots > 0) {
        const x = 50;
        const y = crystalInventoryY + (inventoryIndex * crystalSpacing);
        
        // Don't draw if it would go off screen
        if (y + crystalSize/2 < canvas.height - 20) {
          ctx.save();
          
          // Enhanced sparkle effect for inventory
          const sparkle = 0.6 + 0.4 * fastSin(g.t * 10 + inventoryIndex * 0.5);
          ctx.globalAlpha = sparkle;
          
          const powerup = bulletPowerupMap.get(effect);
          
          // Special glow effects for homing crystals in inventory
          if (effect === 'homing') {
            const glowIntensity = 0.7 + 0.3 * fastSin(g.t * 12);
            const glowSize = crystalSize/2 + 20;
            
            // Add extra shadow glow for homing
            // No shadow effects
            
            // Golden glow aura for inventory homing crystal (cached)
            const invGlowKey = `inv_homing_${((glowIntensity*100)|0)}_${((glowSize*10)|0)}`;
            let inventoryGlow = gradientCache.get(invGlowKey);
            if (!inventoryGlow) {
              inventoryGlow = ctx.createRadialGradient(x, y, crystalSize/2, x, y, glowSize);
              inventoryGlow.addColorStop(0, `rgba(255, 215, 0, ${glowIntensity * 0.6})`);
              inventoryGlow.addColorStop(0.7, `rgba(255, 215, 0, ${glowIntensity * 0.3})`);
              inventoryGlow.addColorStop(1, `rgba(255, 215, 0, 0)`);
              gradientCache.set(invGlowKey, inventoryGlow);
            }
            ctx.fillStyle = inventoryGlow;
            ctx.beginPath();
            ctx.arc(x, y, glowSize, 0, TAU);
            ctx.fill();
          }
          
          // Create gradient based on crystal type
          const effectGradient = ctx.createRadialGradient(x, y, 0, x, y, crystalSize/2);
          const baseColor = powerup ? powerup.color : '#ffffff';
          
          if (effect === 'homing') {
            // Golden gradient for homing
            effectGradient.addColorStop(0, '#ffffff');
            effectGradient.addColorStop(0.5, '#FFD700');
            effectGradient.addColorStop(1, '#FFD70088');
          } else if (effect === 'lightning') {
            // Yellow/blue gradient for lightning
            effectGradient.addColorStop(0, '#FFFF00');
            effectGradient.addColorStop(0.3, '#FFD700');
            effectGradient.addColorStop(0.6, '#87CEEB');
            effectGradient.addColorStop(1, '#87CEEB66');
          } else {
            effectGradient.addColorStop(0, baseColor);
            effectGradient.addColorStop(0.7, baseColor + 'cc');
            effectGradient.addColorStop(1, baseColor + '66');
          }
          
          ctx.fillStyle = effectGradient;
          ctx.strokeStyle = effect === 'homing' ? '#FFFFFF' : '#ffffff88';
          ctx.lineWidth = effect === 'homing' ? 2 : 1.5;
          
          // Draw different shapes based on crystal type
          ctx.beginPath();
          
          if (effect === 'homing') {
            // Star shape for homing
            for (let i = 0; i < 8; i++) {
              const angle = (i * Math.PI / 4) - Math.PI / 2;
              const radius = i % 2 === 0 ? crystalSize/2 : crystalSize/2 * 0.5;
              const px = x + Math.cos(angle) * radius;
              const py = y + Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
          } else if (effect === 'explosive') {
            // Hexagon for explosive
            for (let i = 0; i < 6; i++) {
              const angle = (i * Math.PI / 3) - Math.PI / 6;
              const px = x + Math.cos(angle) * crystalSize/2;
              const py = y + Math.sin(angle) * crystalSize/2;
              if (i === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
          } else if (effect === 'lightning') {
            // Lightning bolt shape
            ctx.moveTo(x - crystalSize/2*0.3, y - crystalSize/2);
            ctx.lineTo(x + crystalSize/2*0.2, y - crystalSize/2*0.3);
            ctx.lineTo(x - crystalSize/2*0.1, y);
            ctx.lineTo(x + crystalSize/2*0.3, y + crystalSize/2);
            ctx.lineTo(x - crystalSize/2*0.2, y + crystalSize/2*0.3);
            ctx.lineTo(x, y);
          } else if (effect === 'freeze') {
            // Snowflake shape (6-pointed star)
            for (let i = 0; i < 12; i++) {
              const angle = (i * Math.PI / 6) - Math.PI / 2;
              const radius = i % 2 === 0 ? crystalSize/2 : crystalSize/2 * 0.4;
              const px = x + Math.cos(angle) * radius;
              const py = y + Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
          } else if (effect === 'ricochet') {
            // Triangle for ricochet
            ctx.moveTo(x, y - crystalSize/2);
            ctx.lineTo(x + crystalSize/2 * 0.866, y + crystalSize/2 * 0.5);
            ctx.lineTo(x - crystalSize/2 * 0.866, y + crystalSize/2 * 0.5);
          } else if (effect === 'seeking') {
            // Cool stylized arrow with swept-back wings (matching ground pickup)
            const s = crystalSize/2;
            // Arrow tip
            ctx.moveTo(x, y - s);
            // Right wing
            ctx.lineTo(x + s*0.8, y - s*0.2);
            ctx.lineTo(x + s*0.5, y);
            // Right shaft indent
            ctx.lineTo(x + s*0.3, y - s*0.1);
            // Shaft
            ctx.lineTo(x + s*0.2, y + s*0.6);
            // Right tail fin
            ctx.lineTo(x + s*0.6, y + s*0.8);
            ctx.lineTo(x + s*0.2, y + s);
            // Bottom center
            ctx.lineTo(x, y + s*0.7);
            // Left tail fin
            ctx.lineTo(x - s*0.2, y + s);
            ctx.lineTo(x - s*0.6, y + s*0.8);
            ctx.lineTo(x - s*0.2, y + s*0.6);
            // Left shaft
            ctx.lineTo(x - s*0.3, y - s*0.1);
            ctx.lineTo(x - s*0.5, y);
            // Left wing
            ctx.lineTo(x - s*0.8, y - s*0.2);
          } else if (effect === 'shotgun') {
            // Stylized connected spread crystal for shotgun
            const s = crystalSize/2;
            // Main body with flared end
            ctx.moveTo(x - s * 0.3, y + s * 0.4);
            ctx.lineTo(x - s * 0.3, y - s * 0.4);
            ctx.lineTo(x + s * 0.2, y - s * 0.3);
            // Top spread arm
            ctx.lineTo(x + s * 0.5, y - s * 0.7);
            ctx.lineTo(x + s * 0.8, y - s * 0.6);
            ctx.lineTo(x + s * 0.6, y - s * 0.3);
            // Middle spread arm
            ctx.lineTo(x + s * 0.7, y);
            ctx.lineTo(x + s * 0.9, y);
            ctx.lineTo(x + s * 0.7, y);
            // Bottom spread arm
            ctx.lineTo(x + s * 0.6, y + s * 0.3);
            ctx.lineTo(x + s * 0.8, y + s * 0.6);
            ctx.lineTo(x + s * 0.5, y + s * 0.7);
            ctx.lineTo(x + s * 0.2, y + s * 0.3);
          } else if (effect === 'cluster') {
            // Three overlapping circles for cluster (matching ground pickup)
            const s = crystalSize/2;
            ctx.arc(x - s*0.4, y, s*0.6, 0, Math.PI * 2);
            ctx.moveTo(x + s*0.4 + s*0.6, y - s*0.3);
            ctx.arc(x + s*0.4, y - s*0.3, s*0.6, 0, Math.PI * 2);
            ctx.moveTo(x + s*0.4 + s*0.6, y + s*0.3);
            ctx.arc(x + s*0.4, y + s*0.3, s*0.6, 0, Math.PI * 2);
          } else {
            // Default diamond for unknown types
            ctx.moveTo(x, y - crystalSize/2);
            ctx.lineTo(x + crystalSize/2, y);
            ctx.lineTo(x, y + crystalSize/2);
            ctx.lineTo(x - crystalSize/2, y);
          }
          
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Draw crystal name
          ctx.fillStyle = '#e3e7ef';
          ctx.font = '18px system-ui';
          ctx.textAlign = 'left';
          const crystalName = powerup ? powerup.name : effect;
          ctx.fillText(crystalName, x + crystalSize/2 + 8, y + 4);
          
          ctx.restore();
          
          inventoryIndex++;
        }
      }
    }
  }

  // ===== Enemy Symbol Drawing =====
  /**
   * @deprecated Use EnemyAI.drawSymbol() instead - this wrapper maintained for compatibility
   */
  function drawEnemySymbol(ctx, e, x, y, r) {
    // MIGRATED: This function now delegates to EnemyAI.drawSymbol()
    return EnemyAI.drawSymbol(ctx, e, x, y, r);
  }

  // OLD IMPLEMENTATION REMOVED - See EnemyAI namespace above (lines 4851-5141)
  //
  // The full 290-line implementation has been moved to EnemyAI.drawSymbol()
  // to reduce god-function complexity and improve code organization.
  //
  // This wrapper is maintained temporarily for backwards compatibility,
  // but all new code should call EnemyAI.drawSymbol() directly.

  // ===== Loop (fixed-timestep with interpolation) =====
  let last = performance.now();
  const dtFixed = 1/60;
  let acc = 0;
  function frame(now){
    try {
      const rawDt = Math.min(0.05, (now - last)*0.001);
      updatePerformanceLevel(rawDt * 1000); // Convert to milliseconds
      last = now;
      if (game && game.state === STATE.RUN){
        // Smoothly lerp timeScale towards target for smooth slow-mo transitions
        if (game.timeScale !== game.timeScaleTarget) {
          const lerpSpeed = 5.0; // How fast to transition
          game.timeScale += (game.timeScaleTarget - game.timeScale) * Math.min(1.0, rawDt * lerpSpeed);
          // Snap to target if very close
          if (Math.abs(game.timeScale - game.timeScaleTarget) < 0.01) {
            game.timeScale = game.timeScaleTarget;
          }
        }

        // Update screen shake
        if (game.screenShake > 0) {
          game.screenShake -= rawDt * 8; // Decay shake over time
          if (game.screenShake < 0) game.screenShake = 0;
          // Generate shake offsets
          game.screenShakeX = (Math.random() - 0.5) * game.screenShake * 20;
          game.screenShakeY = (Math.random() - 0.5) * game.screenShake * 20;
        } else {
          game.screenShakeX = 0;
          game.screenShakeY = 0;
        }

        acc += rawDt; // Don't apply time dilation to accumulator - we'll apply it per-entity
        acc = Math.min(acc, dtFixed * 3); // Cap at 3 frames max to prevent spiral of death
        while (acc >= dtFixed){
          try {
            update(game, dtFixed);
          } catch (updateError) {
            // Game update error
            // Pause game on critical error to prevent infinite errors
            if (game) setState(game, STATE.PAUSE);
            // Notify user of error
            if (banner) {
              banner.textContent = 'Game Error - Please Refresh';
              banner.style.display = 'block';
            }
            break;
          }
          acc -= dtFixed;
        }
        const alpha = acc / dtFixed;
        try {
          draw(game, alpha);
        } catch (drawError) {
          // Game draw error
        }
      }

      // FPS
      if (game){
        try {
          const fps = 1/rawDt;
          game.fpsSamples.push(fps);
          game.fpsSum += fps;
          if (game.fpsSamples.length > 20){
            game.fpsSum -= game.fpsSamples.shift(); // Subtract removed value
            const avg = game.fpsSum / game.fpsSamples.length;
            fpsTxt.textContent = 'FPS: ' + Math.round(avg);
          }
        } catch (fpsError) {
          // FPS calculation error
        }
      }
    } catch (frameError) {
      // Critical frame error
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ===== Animated enemy preview system =====
  let enemyPreviewAnimations = [];
  
  function initEnemyPreviews() {
    // Clear any existing animations
    enemyPreviewAnimations.forEach(anim => cancelAnimationFrame(anim.id));
    enemyPreviewAnimations = [];
    
    // Get all canvas elements for enemy previews
    const canvases = document.querySelectorAll('.enemy-preview-canvas');
    
    canvases.forEach(canvas => {
      const ctx = canvas.getContext('2d');
      const color = canvas.dataset.enemyColor;
      const behavior = canvas.dataset.enemyBehavior;
      const isShooter = canvas.dataset.enemyShooter === 'true';
      const shootPattern = canvas.dataset.shootPattern || 'single';
      
      // Set proper scaling for high DPI displays
      const scale = 2; // 2x resolution for clarity
      canvas.style.width = '80px';
      canvas.style.height = '80px';
      
      // Animation state for this enemy (coordinates in logical space, not scaled)
      const animState = {
        x: 40,
        y: 40,
        targetX: 60,
        targetY: 40,
        time: 0,
        radius: behavior === 'superboss' || behavior === 'boss' ? 24 : 16,
        projectiles: [],
        lastShot: 0
      };
      
      // Create a mock enemy object for drawing
      const mockEnemy = {
        behavior: behavior,
        isShooter: isShooter,
        color: color,
        x: animState.x,
        y: animState.y,
        r: animState.radius,
        hasShield: behavior === 'juggernaut',
        shieldHP: behavior === 'juggernaut' ? 3 : 0,
        maxShieldHP: behavior === 'juggernaut' ? 3 : 0,
        shieldDirection: behavior === 'juggernaut' ? { x: 1, y: 0 } : null
      };
      
      function animate() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update position with smooth movement
        animState.time += 0.02;
        
        // Behavior-specific movement patterns
        if (behavior === 'prowler') {
          // Flanking movement - circles around
          const angle = animState.time * 2;
          mockEnemy.x = (40 + Math.cos(angle) * 15) * scale;
          mockEnemy.y = (40 + Math.sin(angle) * 8) * scale;
        } else if (behavior === 'serpent') {
          // Serpent - smooth zigzag
          const progress = (Math.sin(animState.time) + 1) / 2;
          mockEnemy.x = (24 + progress * 32) * scale;
          mockEnemy.y = (40 + Math.sin(animState.time * 3) * 8) * scale;
        } else if (behavior === 'maniac') {
          // Maniac - erratic random-ish movement
          const erraticX = Math.sin(animState.time * 2.7) + Math.sin(animState.time * 4.3) * 0.5;
          const erraticY = Math.cos(animState.time * 3.1) + Math.sin(animState.time * 5.7) * 0.3;
          mockEnemy.x = (40 + erraticX * 12) * scale;
          mockEnemy.y = (40 + erraticY * 8) * scale;
        } else if (behavior === 'leaper') {
          // Jumping motion
          const jumpCycle = animState.time % 2;
          const progress = (Math.sin(animState.time) + 1) / 2;
          mockEnemy.x = (24 + progress * 32) * scale;
          if (jumpCycle < 0.3) {
            mockEnemy.y = (40 - Math.sin((jumpCycle / 0.3) * Math.PI) * 10) * scale;
          } else {
            mockEnemy.y = 40 * scale;
          }
        } else {
          // Default back and forth movement
          const progress = (Math.sin(animState.time) + 1) / 2;
          const moveRange = behavior === 'superboss' || behavior === 'boss' ? 16 : 24;
          mockEnemy.x = (40 - moveRange/2 + progress * moveRange) * scale;
          mockEnemy.y = 40 * scale;
        }
        
        // Scale the radius for drawing
        mockEnemy.r = animState.radius * scale;
        
        // Handle shooting enemies
        if (isShooter || behavior === 'vortex') {
          // Spawn projectiles periodically
          if (animState.time - animState.lastShot > 1.5) {
            animState.lastShot = animState.time;
            
            if (shootPattern === 'spread') {
              // Triple spread shot
              for (let i = -1; i <= 1; i++) {
                const angle = i * 0.3; // Spread angle
                animState.projectiles.push({
                  x: mockEnemy.x / scale,
                  y: mockEnemy.y / scale,
                  vx: Math.cos(angle) * 2,
                  vy: Math.sin(angle) * 2,
                  life: 1
                });
              }
            } else if (shootPattern === 'burst') {
              // Burst fire (3 rapid shots)
              for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                  animState.projectiles.push({
                    x: mockEnemy.x / scale,
                    y: mockEnemy.y / scale,
                    vx: 2,
                    vy: 0,
                    life: 1
                  });
                }, i * 100); // 100ms between burst shots
              }
            } else {
              // Single shot (default)
              animState.projectiles.push({
                x: mockEnemy.x / scale,
                y: mockEnemy.y / scale,
                vx: behavior === 'vortex' ? Math.cos(animState.time * 3) * 2 : 2,
                vy: behavior === 'vortex' ? Math.sin(animState.time * 3) * 2 : 0,
                life: 1
              });
            }
          }
        }
        
        // Update and draw projectiles
        animState.projectiles = animState.projectiles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.02;
          
          if (p.life > 0) {
            ctx.save();
            ctx.fillStyle = '#ff0000';
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x * scale, p.y * scale, 3 * scale, 0, TAU);
            ctx.fill();
            ctx.restore();
            return true;
          }
          return false;
        });
        
        // Update juggernaut shield direction to face "player"
        if (behavior === 'juggernaut' && mockEnemy.hasShield) {
          // Simulate player at center-left of the preview area
          const playerX = 20 * scale;
          const playerY = 40 * scale;
          
          // Calculate direction from juggernaut to "player"
          const dx = playerX - mockEnemy.x;
          const dy = playerY - mockEnemy.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          mockEnemy.shieldDirection = { 
            x: dx / dist, 
            y: dy / dist 
          };
        }
        
        // Draw juggernaut shield using the same rendering as in-game
        if (mockEnemy.behavior === 'juggernaut' && mockEnemy.hasShield && mockEnemy.shieldHP > 0) {
          const shieldDir = mockEnemy.shieldDirection || { x: 1, y: 0 };
          const shieldOffset = mockEnemy.r + 5; // 5 pixels in front of enemy
          const shieldX = mockEnemy.x + shieldDir.x * shieldOffset;
          const shieldY = mockEnemy.y + shieldDir.y * shieldOffset;
          
          // Shield dimensions
          const shieldWidth = mockEnemy.r * 1.2;
          const shieldHeight = mockEnemy.r * 0.8;
          
          // Shield health-based transparency
          const shieldAlpha = Math.max(0.3, mockEnemy.shieldHP / mockEnemy.maxShieldHP);
          
          ctx.save();
          ctx.globalAlpha = shieldAlpha;
          ctx.fillStyle = '#cccccc'; // Light gray shield (very visible)
          ctx.fillRect(shieldX - shieldWidth/2, shieldY - shieldHeight/2, shieldWidth, shieldHeight);
          
          // Shield border
          ctx.strokeStyle = '#aaaaaa';
          ctx.lineWidth = 1;
          ctx.strokeRect(shieldX - shieldWidth/2, shieldY - shieldHeight/2, shieldWidth, shieldHeight);
          ctx.restore();
        }
        
        // Draw the enemy
        ctx.save();
        
        // Draw enemy body
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(mockEnemy.x, mockEnemy.y, mockEnemy.r, 0, TAU);
        ctx.fill();
        
        // Draw enemy symbol
        EnemyAI.drawSymbol(ctx, mockEnemy, mockEnemy.x, mockEnemy.y, mockEnemy.r);
        
        ctx.restore();
        
        // Continue animation
        const animId = requestAnimationFrame(animate);
        
        // Store animation reference
        const animRef = { id: animId, canvas: canvas };
        const existingIndex = enemyPreviewAnimations.findIndex(a => a.canvas === canvas);
        if (existingIndex >= 0) {
          enemyPreviewAnimations[existingIndex] = animRef;
        } else {
          enemyPreviewAnimations.push(animRef);
        }
      }
      
      // Start animation for this canvas
      animate();
    });
  }
  
  // Track crystal preview animations
  let crystalPreviewAnimations = [];
  let crystalAnimationsRunning = false;
  
  // Initialize crystal preview animations
  function initCrystalPreviews() {
    // Don't reinitialize if already running
    if (crystalAnimationsRunning) {
      return;
    }
    
    // Clear any existing animations first
    crystalPreviewAnimations.forEach(anim => anim.stop());
    crystalPreviewAnimations = [];
    crystalAnimationsRunning = true;
    
    // Get all canvas elements for crystal previews
    const canvases = document.querySelectorAll('.crystal-preview-canvas');
    
    canvases.forEach(canvas => {
      const ctx = canvas.getContext('2d');
      const type = canvas.dataset.crystalType;
      const color = canvas.dataset.crystalColor;
      
      // Center point for crystal (2x bigger)
      const centerX = 50;  // Updated for 100x100 canvas
      const centerY = 50;  // Updated for 100x100 canvas
      const size = type === 'homing' ? 30 : 24;  // Doubled from 15:12
      
      // Animation state
      let rotation = 0;
      let time = 0;
      let particleTimer = 0.29; // Start near spawn time to trigger particles quickly
      const particles = [];
      
      let animId = null;
      let animationActive = true;
      
      function drawCrystal() {
        // Validate canvas is still in DOM
        if (!document.body.contains(canvas)) {
          animationActive = false;
          if (animId) cancelAnimationFrame(animId);
          return;
        }
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx * 0.016;
          p.y += p.vy * 0.016;
          p.life += 0.016;
          if (p.life > p.maxLife) {
            particles.splice(i, 1);
          }
        }
        
        // Save context state
        ctx.save();
        
        // Apply slow rotation
        ctx.translate(centerX, centerY);
        ctx.rotate(rotation);
        ctx.translate(-centerX, -centerY);
        
        // Special golden glow for homing crystals (before main crystal)
        if (type === 'homing') {
          const glowIntensity = 0.7 + 0.3 * Math.sin(time * 15);
          const glowSize = 35 + 10 * Math.sin(time * 8);
          
          const outerGlow = ctx.createRadialGradient(centerX, centerY, 8, centerX, centerY, glowSize);
          outerGlow.addColorStop(0, `rgba(255,215,0,${glowIntensity * 0.8})`);
          outerGlow.addColorStop(0.5, `rgba(255,215,0,${glowIntensity * 0.4})`);
          outerGlow.addColorStop(1, 'rgba(255,215,0,0)');
          
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.fillStyle = outerGlow;
          ctx.beginPath();
          ctx.arc(centerX, centerY, glowSize, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        
        // Create gradient for crystal
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size);
        
        if (type === 'homing') {
          // Golden gradient for homing (matching in-game)
          gradient.addColorStop(0, '#ffffff');
          gradient.addColorStop(0.5, '#FFD700');
          gradient.addColorStop(1, '#FFD70088');
        } else if (type === 'lightning') {
          // Yellow/blue gradient for lightning
          gradient.addColorStop(0, '#FFFF00');
          gradient.addColorStop(0.3, '#FFD700');
          gradient.addColorStop(0.6, '#87CEEB');
          gradient.addColorStop(1, '#87CEEB66');
        } else {
          // Convert hex to proper alpha format
          gradient.addColorStop(0, color);
          gradient.addColorStop(0.7, color + (color.length === 7 ? 'cc' : ''));
          gradient.addColorStop(1, color + (color.length === 7 ? '66' : ''));
        }
        
        ctx.fillStyle = gradient;
        ctx.strokeStyle = type === 'homing' ? '#FFFFFF' : '#ffffff88';
        ctx.lineWidth = type === 'homing' ? 2 : 1;
        
        // Draw different shapes based on crystal type
        ctx.beginPath();
        
        if (type === 'homing') {
          // Star shape for homing
          for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI / 4) - Math.PI / 2;
            const radius = i % 2 === 0 ? size : size * 0.5;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (type === 'explosive') {
          // Hexagon for explosive
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI / 3) - Math.PI / 6;
            const x = centerX + Math.cos(angle) * size;
            const y = centerY + Math.sin(angle) * size;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (type === 'lightning') {
          // Lightning bolt shape - simple zig-zag
          ctx.moveTo(centerX - size*0.3, centerY - size);
          ctx.lineTo(centerX + size*0.2, centerY - size*0.3);
          ctx.lineTo(centerX - size*0.1, centerY);
          ctx.lineTo(centerX + size*0.3, centerY + size);
          ctx.lineTo(centerX - size*0.2, centerY + size*0.3);
          ctx.lineTo(centerX, centerY);
          // Don't manually close - let closePath() handle it
        } else if (type === 'freeze') {
          // Snowflake shape (6-pointed star)
          for (let i = 0; i < 12; i++) {
            const angle = (i * Math.PI / 6) - Math.PI / 2;
            const radius = i % 2 === 0 ? size : size * 0.4;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
        } else if (type === 'ricochet') {
          // Triangle for ricochet
          ctx.moveTo(centerX, centerY - size);
          ctx.lineTo(centerX + size * 0.866, centerY + size * 0.5);
          ctx.lineTo(centerX - size * 0.866, centerY + size * 0.5);
        } else if (type === 'shotgun') {
          // Stylized connected spread crystal for shotgun
          // Main body with flared end
          ctx.moveTo(centerX - size * 0.3, centerY + size * 0.4);
          ctx.lineTo(centerX - size * 0.3, centerY - size * 0.4);
          ctx.lineTo(centerX + size * 0.2, centerY - size * 0.3);
          // Top spread arm
          ctx.lineTo(centerX + size * 0.5, centerY - size * 0.7);
          ctx.lineTo(centerX + size * 0.8, centerY - size * 0.6);
          ctx.lineTo(centerX + size * 0.6, centerY - size * 0.3);
          // Middle spread arm
          ctx.lineTo(centerX + size * 0.7, centerY);
          ctx.lineTo(centerX + size * 0.9, centerY);
          ctx.lineTo(centerX + size * 0.7, centerY);
          // Bottom spread arm
          ctx.lineTo(centerX + size * 0.6, centerY + size * 0.3);
          ctx.lineTo(centerX + size * 0.8, centerY + size * 0.6);
          ctx.lineTo(centerX + size * 0.5, centerY + size * 0.7);
          ctx.lineTo(centerX + size * 0.2, centerY + size * 0.3);
        } else if (type === 'cluster') {
          // Three overlapping circles for cluster
          ctx.arc(centerX - size*0.4, centerY, size*0.6, 0, Math.PI * 2);
          ctx.moveTo(centerX + size*0.4 + size*0.6, centerY - size*0.3);
          ctx.arc(centerX + size*0.4, centerY - size*0.3, size*0.6, 0, Math.PI * 2);
          ctx.moveTo(centerX + size*0.4 + size*0.6, centerY + size*0.3);
          ctx.arc(centerX + size*0.4, centerY + size*0.3, size*0.6, 0, Math.PI * 2);
        } else if (type === 'seeking') {
          // Cool stylized arrow with swept-back wings
          // Arrow tip
          ctx.moveTo(centerX, centerY - size);
          // Right wing
          ctx.lineTo(centerX + size*0.8, centerY - size*0.2);
          ctx.lineTo(centerX + size*0.5, centerY);
          // Right shaft indent
          ctx.lineTo(centerX + size*0.3, centerY - size*0.1);
          // Shaft
          ctx.lineTo(centerX + size*0.2, centerY + size*0.6);
          // Right tail fin
          ctx.lineTo(centerX + size*0.6, centerY + size*0.8);
          ctx.lineTo(centerX + size*0.2, centerY + size);
          // Bottom center
          ctx.lineTo(centerX, centerY + size*0.7);
          // Left tail fin
          ctx.lineTo(centerX - size*0.2, centerY + size);
          ctx.lineTo(centerX - size*0.6, centerY + size*0.8);
          // Left shaft
          ctx.lineTo(centerX - size*0.2, centerY + size*0.6);
          // Left shaft indent
          ctx.lineTo(centerX - size*0.3, centerY - size*0.1);
          // Left wing
          ctx.lineTo(centerX - size*0.5, centerY);
          ctx.lineTo(centerX - size*0.8, centerY - size*0.2);
        } else {
          // Default diamond shape (for upgrade/dual, triple, quad)
          ctx.moveTo(centerX, centerY - size);
          ctx.lineTo(centerX + size, centerY);
          ctx.lineTo(centerX, centerY + size);
          ctx.lineTo(centerX - size, centerY);
        }
        
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Restore context state for non-rotated effects
        ctx.restore();
        
        // 2. Pulsing inner glow based on crystal type (EXACTLY like the game)
        let pulseSpeed = 4;
        let pulseIntensity = 0.3;
        
        // Different pulse patterns for different crystal types
        if (type === 'homing') {
          pulseSpeed = 8; // Fast pulse for homing
          pulseIntensity = 0.5;
        } else if (type === 'explosive') {
          pulseSpeed = 3; // Slow, intense pulse
          pulseIntensity = 0.4;
        } else if (type === 'lightning') {
          pulseSpeed = 10; // Very fast flicker
          pulseIntensity = 0.6;
        } else if (type === 'freeze') {
          pulseSpeed = 2; // Very slow, gentle
          pulseIntensity = 0.2;
        }
        
        const pulse = Math.sin(time * pulseSpeed) * pulseIntensity + (1 - pulseIntensity);
        const coreSize = Math.max(1, size * 0.3 * pulse); // Ensure coreSize is never negative or zero
        
        ctx.save();
        ctx.globalAlpha = 0.8;
        const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize);
        coreGradient.addColorStop(0, '#ffffff');
        coreGradient.addColorStop(0.5, color);
        coreGradient.addColorStop(1, color + '00');
        
        ctx.fillStyle = coreGradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // 3. Particle effects (sparkles/energy wisps) - EXACTLY like the game
        particleTimer += 0.016;
        
        // Spawn sparkle particles periodically (more frequent for lightning)
        const spawnInterval = type === 'lightning' ? 0.15 : 0.3;  // Lightning spawns twice as often
        if (particleTimer > spawnInterval) {
          particleTimer = 0;
          
          // Spawn more particles for lightning
          const particleCount = type === 'homing' ? 3 : 
                               type === 'lightning' ? 4 : 2;  // Lightning gets 4 particles
          for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = size * 0.8 + Math.random() * 5; // Spawn closer to crystal
            
            particles.push({
              x: centerX + Math.cos(angle) * distance,
              y: centerY + Math.sin(angle) * distance,
              vx: (Math.random() - 0.5) * 10, // Slower movement
              vy: -15 - Math.random() * 10, // Slower upward movement
              life: 0,
              maxLife: 1.0 + Math.random() * 0.5, // Longer life
              size: 2 + Math.random() * 3, // Bigger particles
              // Use brighter colors for dark crystals
              color: type === 'homing' ? '#ffffff' : 
                     type === 'lightning' ? '#00FFFF' :  // Bright cyan for lightning
                     type === 'shotgun' ? '#FFB347' :    // Brighter orange for shotgun
                     color
            });
          }
        }
        
        // Draw particles
        particles.forEach(p => {
          const alpha = 1 - (p.life / p.maxLife);
          ctx.save();
          ctx.globalAlpha = alpha * 0.8;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
        
        // Update animation state for next frame
        rotation += 0.005; // VERY slow spinning
        time += 0.016; // Time for pulsing effects
        
        // Continue animation only if still active
        if (animationActive) {
          animId = requestAnimationFrame(drawCrystal);
        }
      }
      
      // Store animation reference BEFORE starting
      const animRef = { 
        canvas, 
        getId: () => animId,  // Function to get current ID
        stop: () => { 
          animationActive = false;
          if (animId) cancelAnimationFrame(animId); 
        },
        isActive: () => animationActive
      };
      crystalPreviewAnimations.push(animRef);
      
      // Start animation
      drawCrystal();
    });
  }
  
  // ===== Helper function to create enemy legend HTML =====
  function createEnemyLegendHTML() {
    return `
      <div class="enemy-legend" style="padding: 12px; font-size: 13px;">
        <div style="margin-bottom: 12px;">
          <strong style="color: var(--accent); font-size: 14px;">Enemy Types & Behaviors</strong>
        </div>
        <div class="enemy-category">
          <h4> HOW ENEMIES WORK</h4>
          <div style="font-size: 12px; color: var(--muted); line-height: 1.6; margin-bottom: 10px;">
            <div><strong>COLOR = SPEED</strong> (Red=Fast, Purple=Slow)</div>
            <div><strong>SYMBOL = BEHAVIOR</strong> (Special ability)</div>
            <div>Each enemy = 1 base type + 1 behavior</div>
          </div>
        </div>
        
        <div class="enemy-category">
          <h4> SPEED COLORS</h4>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#FF0000" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Red</div>
              <div class="enemy-desc">Fastest - Run away!</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#FF4400" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Orange-Red</div>
              <div class="enemy-desc">Very fast</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#FF8800" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Orange</div>
              <div class="enemy-desc">Fast</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#FFAA00" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Yellow</div>
              <div class="enemy-desc">Above average</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#AAFF00" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Yellow-Green</div>
              <div class="enemy-desc">Average speed</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#00FF88" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Cyan</div>
              <div class="enemy-desc">Below average</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#00CCFF" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Blue</div>
              <div class="enemy-desc">Slow</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#CC44FF" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Purple</div>
              <div class="enemy-desc">Very slow</div>
            </div>
          </div>
        </div>
        
        <div class="enemy-category">
          <h4> BEHAVIOR SYMBOLS</h4>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="stalker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name"> Stalker</div>
              <div class="enemy-desc">Basic - Direct pursuit</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="volatile" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">! Volatile</div>
              <div class="enemy-desc">Explodes on death</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="berserker" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name"> Berserker</div>
              <div class="enemy-desc">Charges at player</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="maniac" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name"> Maniac</div>
              <div class="enemy-desc">Erratic movement</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="serpent" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">~ Serpent</div>
              <div class="enemy-desc">Zigzag pattern</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="prowler" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">() Prowler</div>
              <div class="enemy-desc">Flanking attacks</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="leaper" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name"> Leaper</div>
              <div class="enemy-desc">Jump attacks</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="vortex" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name"> Vortex</div>
              <div class="enemy-desc">Shoots in spiral pattern</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="divider" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Y Divider</div>
              <div class="enemy-desc">Splits into 2-3</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="trapper" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name"> Trapper</div>
              <div class="enemy-desc">Lays mines</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="bomber" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name"> Bomber</div>
              <div class="enemy-desc">Throws grenades</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="juggernaut" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name"> Juggernaut</div>
              <div class="enemy-desc">Shield + knockback</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="stalker" data-enemy-shooter="true" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">+ Shooter</div>
              <div class="enemy-desc">Single projectile</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="stalker" data-enemy-shooter="true" data-shoot-pattern="spread" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">+ Spread Shooter</div>
              <div class="enemy-desc">Triple spread shot</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#888888" data-enemy-behavior="stalker" data-enemy-shooter="true" data-shoot-pattern="burst" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">+ Burst Shooter</div>
              <div class="enemy-desc">Rapid 3-shot burst</div>
            </div>
          </div>
        </div>
        
        <div class="enemy-category">
          <h4> SPECIAL TYPES</h4>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#800080" data-enemy-behavior="superboss" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Super Boss</div>
              <div class="enemy-desc">Wave 10/20/30  9x HP</div>
            </div>
          </div>
          <div class="enemy-entry">
            <canvas class="enemy-preview-canvas" data-enemy-color="#FFCC00" data-enemy-behavior="boss" width="160" height="160"></canvas>
            <div class="enemy-info">
              <div class="enemy-name">Mini Boss</div>
              <div class="enemy-desc">Wave 5/15/25  2x HP</div>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  // ===== Options Menu Functions =====
  let optionsMenuOpen = false;
  let optionsMenuInitialized = false;
  
  function showOptionsMenu() {
    if (optionsMenuOpen) return;
    optionsMenuOpen = true;
    
    // Hide start menu
    banner.style.display = 'none';
    
    // Show and setup options panel
    optionsPanel.style.display = 'block';
    optionsPanel.style.animation = 'optionsFadeIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
    
    // Only create content once
    if (!optionsMenuInitialized) {
      optionsMenuInitialized = true;
      // Clear options panel content ONLY on first creation
      optionsPanel.innerHTML = '';
    
    // Create options screen elements with tabs (exact copy of pause menu)
    
    // Tab container
    const tabContainer = document.createElement('div');
    tabContainer.className = 'tab-container';
    
    const controlsTab = document.createElement('button');
    controlsTab.className = 'tab-button active';
    controlsTab.textContent = 'Controls';
    controlsTab.onclick = (e) => switchOptionsTab('controls', e);
    
    const enemiesTab = document.createElement('button');
    enemiesTab.className = 'tab-button';
    enemiesTab.textContent = 'Enemies';
    enemiesTab.onclick = (e) => switchOptionsTab('enemies', e);
    
    const crystalsTab = document.createElement('button');
    crystalsTab.className = 'tab-button';
    crystalsTab.textContent = 'Crystals';
    crystalsTab.onclick = (e) => switchOptionsTab('crystals', e);
    
    tabContainer.appendChild(controlsTab);
    tabContainer.appendChild(enemiesTab);
    tabContainer.appendChild(crystalsTab);
    
    // Controls panel (default active)
    const controlsDiv = document.createElement('div');
    controlsDiv.id = 'options-controls-content';
    controlsDiv.className = 'controls-panel tab-content active';
    controlsDiv.innerHTML = createControlsHTML();
    
    // Enemy legend panel
    const enemiesDiv = document.createElement('div');
    enemiesDiv.id = 'options-enemies-content';
    enemiesDiv.className = 'controls-panel tab-content';
    enemiesDiv.innerHTML = createEnemyLegendHTML();
    
    // Initialize enemy preview animations when panel is created
    setTimeout(() => {
      if (document.querySelector('.enemy-preview-canvas')) {
        initEnemyPreviews();
      }
    }, 100);
    
    // Crystals panel
    const crystalsDiv = document.createElement('div');
    crystalsDiv.id = 'options-crystals-content';
    crystalsDiv.className = 'controls-panel tab-content';
    crystalsDiv.innerHTML = createCrystalLegendHTML();
    
    const backBtn = document.createElement('button');
    backBtn.id = 'optionsBackBtn';
    backBtn.textContent = 'Back';
    backBtn.onclick = hideOptionsMenu;
    
    // Add tab switching function for options
    window.switchOptionsTab = function(tabName, evt) {
      // Update tab buttons
      optionsPanel.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
      });
      if (evt && evt.target) {
        evt.target.classList.add('active');
      }
      
      // Update content panels
      optionsPanel.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      const targetContent = optionsPanel.querySelector('#options-' + tabName + '-content');
      if (targetContent) {
        targetContent.classList.add('active');
      }
      
      // Initialize preview animations when switching tabs
      if (tabName === 'enemies') {
        setTimeout(() => {
          initEnemyPreviews();
        }, 50);
      } else if (tabName === 'crystals') {
        setTimeout(() => {
          initCrystalPreviews();
        }, 50);
      }
    };
    
    optionsPanel.appendChild(tabContainer);
    optionsPanel.appendChild(controlsDiv);
    optionsPanel.appendChild(enemiesDiv);
    optionsPanel.appendChild(crystalsDiv);
    optionsPanel.appendChild(backBtn);
    } // End of if (!optionsMenuInitialized)
    
    // Re-initialize crystal animations if crystals tab is visible
    const crystalsContent = document.getElementById('options-crystals-content');
    if (crystalsContent && crystalsContent.classList.contains('active')) {
      setTimeout(() => {
        initCrystalPreviews();
      }, 50);
    }
  }
  
  function hideOptionsMenu() {
    optionsMenuOpen = false;
    // Reset animation flags when closing options menu
    crystalAnimationsRunning = false;
    crystalPreviewAnimations.forEach(anim => anim.stop());
    crystalPreviewAnimations = [];
    optionsPanel.style.animation = 'optionsFadeOut 0.3s ease-out forwards';
    setTimeout(() => {
      optionsPanel.style.display = 'none';
      // Don't clear innerHTML here - keep content for next open
    }, 300);
    banner.style.display = 'block';
  }
  
  
  // ===== Helper function to create crystal legend HTML =====
  function createCrystalLegendHTML() {
    // Create unique crystal data for rendering (colors from bulletPowerups array)
    const crystals = [
      { type: 'homing', color: '#FFD700', name: 'Homing', desc: 'Bullets auto-track enemies', category: 'ultra' },
      { type: 'explosive', color: '#FF4500', name: 'Explosive', desc: 'Area damage on impact', category: 'effect' },
      { type: 'lightning', color: '#00BFFF', name: 'Lightning', desc: 'Chain damage to nearby foes', category: 'effect' },
      { type: 'freeze', color: '#00CED1', name: 'Freeze', desc: 'Slows enemies on hit', category: 'effect' },
      { type: 'ricochet', color: '#FF69B4', name: 'Ricochet', desc: 'Bullets bounce off enemies', category: 'effect' },
      { type: 'seeking', color: '#DC143C', name: 'Seeking', desc: 'Mild homing effect', category: 'effect' },
      { type: 'shotgun', color: '#8B4513', name: 'Shotgun', desc: 'Wide spread pattern', category: 'effect' },
      { type: 'cluster', color: '#FFA500', name: 'Cluster', desc: 'Splits into mini bullets', category: 'effect' },
      { type: 'upgrade', color: '#32CD32', name: 'Dual Shot', desc: 'Front & back bullets', category: 'pattern' },
      { type: 'triple', color: '#00BFFF', name: 'Triple Shot', desc: '3-way spread', category: 'pattern' },
      { type: 'quad', color: '#FF1493', name: 'Quad Shot', desc: '4 directions', category: 'pattern' }
    ];
    
    let html = `
      <div class="crystal-legend" style="padding: 12px; font-size: 13px;">
        <div style="margin-bottom: 12px;">
          <strong style="color: var(--accent); font-size: 14px;">Crystal Types & Effects</strong>
        </div>`;
    
    // Ultra rare section
    html += `
        <div class="crystal-category" style="margin-bottom: 8px;">
          <h4 style="color: #FFD700; margin: 8px 0 4px 0; font-size: 13px;"> ULTRA RARE (0.5%)</h4>`;
    
    crystals.filter(c => c.category === 'ultra').forEach(crystal => {
      html += `
          <div class="crystal-item" style="margin: 4px 0; display: flex; align-items: center;">
            <canvas class="crystal-preview-canvas" 
                    data-crystal-type="${crystal.type}" 
                    data-crystal-color="${crystal.color}"
                    width="100" height="100"
                    style="width: 50px; height: 50px; margin-right: 8px;">
            </canvas>
            <div><span style="color: ${crystal.color};">${crystal.name}</span> - ${crystal.desc}</div>
          </div>`;
    });
    
    html += `</div>`;
    
    // Effect crystals section
    html += `
        <div class="crystal-category" style="margin-bottom: 8px;">
          <h4 style="color: #5af2c7; margin: 8px 0 4px 0; font-size: 13px;"> EFFECT CRYSTALS</h4>`;
    
    crystals.filter(c => c.category === 'effect').forEach(crystal => {
      html += `
          <div class="crystal-item" style="margin: 4px 0; display: flex; align-items: center;">
            <canvas class="crystal-preview-canvas" 
                    data-crystal-type="${crystal.type}" 
                    data-crystal-color="${crystal.color}"
                    width="100" height="100"
                    style="width: 50px; height: 50px; margin-right: 8px;">
            </canvas>
            <div><span style="color: ${crystal.color};">${crystal.name}</span> - ${crystal.desc}</div>
          </div>`;
    });
    
    html += `</div>`;
    
    // Pattern crystals section
    html += `
        <div class="crystal-category">
          <h4 style="color: #5af2c7; margin: 8px 0 4px 0; font-size: 13px;"> PATTERN CRYSTALS</h4>`;
    
    crystals.filter(c => c.category === 'pattern').forEach(crystal => {
      html += `
          <div class="crystal-item" style="margin: 4px 0; display: flex; align-items: center;">
            <canvas class="crystal-preview-canvas" 
                    data-crystal-type="${crystal.type}" 
                    data-crystal-color="${crystal.color}"
                    width="100" height="100"
                    style="width: 50px; height: 50px; margin-right: 8px;">
            </canvas>
            <div><span style="color: ${crystal.color};">${crystal.name}</span> - ${crystal.desc}</div>
          </div>`;
    });
    
    html += `</div>`;
    
    // Footer tips
    html += `
        <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--muted); font-size: 11px; color: var(--muted);">
          <div> Crystals have limited shots (25-50)</div>
          <div> Effects can stack for powerful combos</div>
          <div> Pattern upgrades double your bullets</div>
        </div>
      </div>
    `;
    
    // Don't initialize here - it's done when switching tabs
    
    return html;
  }

  // ===== Helper function to create controls HTML =====
  function createControlsHTML() {
    return `
      <div class="controls-title"><strong>Controls</strong></div>
      <div class="control-row">
        <div class="control-keys"><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></div>
        <div class="control-desc">Move around the arena</div>
      </div>
      <div class="control-row">
        <div class="control-keys"><kbd>Mouse</kbd></div>
        <div class="control-desc">Aim and shoot</div>
      </div>
      <div class="control-row">
        <div class="control-keys"><kbd>Shift</kbd></div>
        <div class="control-desc">Dash through enemies</div>
      </div>
      <div class="control-row">
        <div class="control-keys"><kbd>Space</kbd></div>
        <div class="control-desc">Emergency leap</div>
      </div>
      <div class="control-row">
        <div class="control-keys"><kbd>P</kbd> or <kbd>ESC</kbd></div>
        <div class="control-desc">Pause / Resume game</div>
      </div>
      <div class="control-row">
        <div class="control-keys"><kbd>F11</kbd></div>
        <div class="control-desc">Toggle fullscreen</div>
      </div>
      <div class="mobile-note">Mobile: Touch left side to move, right side to aim/shoot<br>
       Sprint (bottom left) |  Leap (bottom right) |  Pause (top right)</div>
    `;
  }
  
  // ===== Pause / Resume =====
  function togglePause(){
    if (!game || (game.state!==STATE.RUN && game.state!==STATE.PAUSE)) return;
    if (game.state === STATE.RUN) {
      setState(game, STATE.PAUSE);
      banner.style.display = 'block';
      banner.style.animation = 'pauseSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
      // Clear banner content efficiently
      banner.innerHTML = '';
      
      // Create pause screen elements with tabs
      
      // Tab container
      const tabContainer = document.createElement('div');
      tabContainer.className = 'tab-container';
      
      const controlsTab = document.createElement('button');
      controlsTab.className = 'tab-button active';
      controlsTab.textContent = 'Controls';
      controlsTab.onclick = (e) => switchTab('controls', e);
      
      const enemiesTab = document.createElement('button');
      enemiesTab.className = 'tab-button';
      enemiesTab.textContent = 'Enemies';
      enemiesTab.onclick = (e) => switchTab('enemies', e);
      
      const upgradesTab = document.createElement('button');
      upgradesTab.className = 'tab-button';
      upgradesTab.textContent = 'Upgrades';
      upgradesTab.onclick = (e) => switchTab('upgrades', e);
      
      const crystalsTab = document.createElement('button');
      crystalsTab.className = 'tab-button';
      crystalsTab.textContent = 'Crystals';
      crystalsTab.onclick = (e) => switchTab('crystals', e);
      
      tabContainer.appendChild(controlsTab);
      tabContainer.appendChild(enemiesTab);
      tabContainer.appendChild(upgradesTab);
      tabContainer.appendChild(crystalsTab);
      
      // Controls panel (default active)
      const controlsDiv = document.createElement('div');
      controlsDiv.id = 'controls-content';
      controlsDiv.className = 'controls-panel tab-content active';
      controlsDiv.innerHTML = createControlsHTML();
      
      // Enemy legend panel
      const enemiesDiv = document.createElement('div');
      enemiesDiv.id = 'enemies-content';
      enemiesDiv.className = 'controls-panel tab-content';
      enemiesDiv.innerHTML = createEnemyLegendHTML();
      
      // Initialize enemy preview animations when panel is created
      setTimeout(() => {
        if (document.querySelector('.enemy-preview-canvas')) {
          initEnemyPreviews();
        }
      }, 100);
      
      // Upgrades panel
      const upgradesDiv = document.createElement('div');
      upgradesDiv.id = 'upgrades-content';
      upgradesDiv.className = 'controls-panel tab-content';
      upgradesDiv.style.cssText = 'padding: 12px; font-size: 13px;';
      
      const upgradesTitle = document.createElement('div');
      upgradesTitle.style.marginBottom = '8px';
      const upgradesStrong = document.createElement('strong');
      upgradesStrong.textContent = 'Active Upgrades';
      upgradesTitle.appendChild(upgradesStrong);
      
      const upgradesList = document.createElement('div');
      upgradesList.style.cssText = 'max-height: 120px; overflow-y: auto; line-height: 1.4;';
      
      const upgrades = createUpgradesDisplay();
      upgrades.forEach(upgrade => {
        const upgradeItem = document.createElement('div');
        upgradeItem.style.cssText = 'margin: 2px 0; color: #5af2c7;';
        upgradeItem.textContent = ' ' + upgrade;
        upgradesList.appendChild(upgradeItem);
      });
      
      upgradesDiv.appendChild(upgradesTitle);
      upgradesDiv.appendChild(upgradesList);
      
      // Crystals panel
      const crystalsDiv = document.createElement('div');
      crystalsDiv.id = 'crystals-content';
      crystalsDiv.className = 'controls-panel tab-content';
      crystalsDiv.innerHTML = createCrystalLegendHTML();
      
      const startBtn = document.createElement('button');
      startBtn.id = 'startBtn';
      startBtn.textContent = 'Resume';

      const mainMenuBtn = document.createElement('button');
      mainMenuBtn.id = 'mainMenuBtn';
      mainMenuBtn.textContent = 'Main Menu';
      mainMenuBtn.style.cssText = 'margin-top: 12px; background: #ff5b6e; border-color: #ff5b6e;';

      // Add tab switching function
      window.switchTab = function(tabName, evt) {
        // Update tab buttons - scope to pause banner only
        banner.querySelectorAll('.tab-button').forEach(btn => {
          btn.classList.remove('active');
        });
        if (evt && evt.target) {
          evt.target.classList.add('active');
        }
        
        // Update content panels - scope to pause banner only
        banner.querySelectorAll('.tab-content').forEach(content => {
          content.classList.remove('active');
        });
        const targetContent = banner.querySelector('#' + tabName + '-content');
        if (targetContent) {
          targetContent.classList.add('active');
        }
        
        // Initialize preview animations when switching tabs
        if (tabName === 'enemies') {
          setTimeout(() => {
            initEnemyPreviews();
          }, 50);
        } else if (tabName === 'crystals') {
          setTimeout(() => {
            initCrystalPreviews();
          }, 50);
        }
      };
      
      banner.appendChild(tabContainer);
      banner.appendChild(controlsDiv);
      banner.appendChild(enemiesDiv);
      banner.appendChild(upgradesDiv);
      banner.appendChild(crystalsDiv);
      banner.appendChild(startBtn);
      banner.appendChild(mainMenuBtn);

      // Re-attach event listener to the new Resume button
      document.getElementById('startBtn').addEventListener('click', () => {
        initAudio();
        if (game && game.state === STATE.PAUSE) {
          // Resume from pause
          togglePause();
        } else {
          // Start new game
          start();
        }
      });

      // Main Menu button returns to initial state by reloading the page
      document.getElementById('mainMenuBtn').addEventListener('click', () => {
        window.location.reload();
      });
    } else {
      banner.style.animation = 'pauseSlideOut 0.3s ease-out forwards';
      setTimeout(() => {
        banner.style.display = 'none';
      }, 300);
      // Reset animation flags when closing pause menu
      crystalAnimationsRunning = false;
      crystalPreviewAnimations.forEach(anim => anim.stop());
      crystalPreviewAnimations = [];
      game.state = STATE.RUN;
      // Restore original banner content efficiently
      banner.innerHTML = '';
      
      // Create start screen elements with enhanced styling
      
      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'controls-panel';
      controlsDiv.innerHTML = createControlsHTML();
      
      const startBtn = document.createElement('button');
      startBtn.id = 'startBtn';
      startBtn.textContent = 'Start';
      
      banner.appendChild(controlsDiv);
      banner.appendChild(startBtn);
      // Re-attach event listener to the new Start button
      document.getElementById('startBtn').addEventListener('click', () => { 
        initAudio(); 
        if (game && game.state === STATE.PAUSE) {
          // Resume from pause
          togglePause();
        } else {
          // Start new game
          start(); 
        }
      });
    }
  }

  // ===== Start / Restart =====
  function start(){
    // Clear all existing game entities before creating new game
    enemies.items.forEach(e => e.alive = false);
    bullets.items.forEach(b => b.alive = false);
    particles.items.forEach(p => p.alive = false);
    
    // Clear any pools that might have grown
    enemies.items.length = 0;
    bullets.items.length = 0;
    particles.items.length = 0;
    
    game = newGame();
    // Animate out existing screens
    if (banner.style.display !== 'none') {
      banner.style.animation = 'pauseSlideOut 0.3s ease-out forwards';
      setTimeout(() => { banner.style.display = 'none'; }, 300);
    }
    if (gameOverPanel.style.display !== 'none') {
      gameOverPanel.style.animation = 'gameOverSlideOut 0.4s ease-out forwards';
      setTimeout(() => { gameOverPanel.style.display = 'none'; }, 400);
    } else {
      banner.style.display = 'none';
      gameOverPanel.style.display = 'none';
    }
    
    // Animate HUD fade in
    const hud = document.getElementById('hud');
    hud.style.animation = 'hudFadeIn 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards';
    hud.style.opacity = '1';
    hud.style.visibility = 'visible';
    game.state = STATE.RUN;
    
    // Show mobile controls during gameplay
    if (isMobile) {
      if (mobileControls) mobileControls.style.display = 'block';
      if (touchZonesElement) touchZonesElement.style.display = 'block';
    }
    // Center player
    game.player.x = canvas.width/2;
    game.player.y = canvas.height/2;
    
    // AAA Game Start Effect - Ultimate Edition with ALL enhancements!
    gameStartOverlay.style.opacity = '1';
    gameStartOverlay.style.display = 'block';

    // Get all effect layers (impact flash, center bursts, chromatic aberration, corners, ring wave, rays, particles)
    const startImpactFlash = gameStartOverlay.querySelector('.start-impact-flash');
    const startVignette = gameStartOverlay.querySelector('.start-vignette');
    const startEnergyBurst = gameStartOverlay.querySelector('.start-energy-burst:not([class*="-t"]):not([class*="-b"]):not([class*="-chroma"])');
    const startEnergyBurstChromaR = gameStartOverlay.querySelector('.start-energy-burst-chroma-r');
    const startEnergyBurstChromaB = gameStartOverlay.querySelector('.start-energy-burst-chroma-b');
    const startEnergyBurstTL = gameStartOverlay.querySelector('.start-energy-burst-tl');
    const startEnergyBurstTR = gameStartOverlay.querySelector('.start-energy-burst-tr');
    const startEnergyBurstBL = gameStartOverlay.querySelector('.start-energy-burst-bl');
    const startEnergyBurstBR = gameStartOverlay.querySelector('.start-energy-burst-br');
    const startRingWave = gameStartOverlay.querySelector('.start-ring-wave');
    const startRays = gameStartOverlay.querySelector('.start-rays:not([class*="-t"]):not([class*="-b"])');
    const startRaysTL = gameStartOverlay.querySelector('.start-rays-tl');
    const startRaysTR = gameStartOverlay.querySelector('.start-rays-tr');
    const startRaysBL = gameStartOverlay.querySelector('.start-rays-bl');
    const startRaysBR = gameStartOverlay.querySelector('.start-rays-br');
    const startParticles = gameStartOverlay.querySelector('.start-particles:not(.start-particles-mirror)');
    const startParticlesMirror = gameStartOverlay.querySelector('.start-particles-mirror');

    // Reset all animations
    if (startImpactFlash) startImpactFlash.style.animation = 'none';
    if (startVignette) startVignette.style.animation = 'none';
    if (startEnergyBurst) startEnergyBurst.style.animation = 'none';
    if (startEnergyBurstChromaR) startEnergyBurstChromaR.style.animation = 'none';
    if (startEnergyBurstChromaB) startEnergyBurstChromaB.style.animation = 'none';
    if (startEnergyBurstTL) startEnergyBurstTL.style.animation = 'none';
    if (startEnergyBurstTR) startEnergyBurstTR.style.animation = 'none';
    if (startEnergyBurstBL) startEnergyBurstBL.style.animation = 'none';
    if (startEnergyBurstBR) startEnergyBurstBR.style.animation = 'none';
    if (startRingWave) startRingWave.style.animation = 'none';
    if (startRays) startRays.style.animation = 'none';
    if (startRaysTL) startRaysTL.style.animation = 'none';
    if (startRaysTR) startRaysTR.style.animation = 'none';
    if (startRaysBL) startRaysBL.style.animation = 'none';
    if (startRaysBR) startRaysBR.style.animation = 'none';
    if (startParticles) startParticles.style.animation = 'none';
    if (startParticlesMirror) startParticlesMirror.style.animation = 'none';

    // Trigger all animations with ultimate polish!
    setTimeout(() => {
      if (startImpactFlash) startImpactFlash.style.animation = 'startImpactFlash 0.2s ease-out';
      if (startVignette) startVignette.style.animation = 'startVignette 1.8s ease-out';
      if (startEnergyBurst) startEnergyBurst.style.animation = 'startEnergyBurst 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      if (startEnergyBurstChromaR) startEnergyBurstChromaR.style.animation = 'startEnergyBurst 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      if (startEnergyBurstChromaB) startEnergyBurstChromaB.style.animation = 'startEnergyBurstChromaOffset 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      if (startEnergyBurstTL) startEnergyBurstTL.style.animation = 'startEnergyBurstCorner 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      if (startEnergyBurstTR) startEnergyBurstTR.style.animation = 'startEnergyBurstCorner 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.1s';
      if (startEnergyBurstBL) startEnergyBurstBL.style.animation = 'startEnergyBurstCorner 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.2s';
      if (startEnergyBurstBR) startEnergyBurstBR.style.animation = 'startEnergyBurstCorner 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.3s';
      if (startRingWave) startRingWave.style.animation = 'startRingExpansion 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      if (startRays) startRays.style.animation = 'startRays 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      if (startRaysTL) startRaysTL.style.animation = 'startRaysCornerReverse 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      if (startRaysTR) startRaysTR.style.animation = 'startRaysCornerReverse 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.1s';
      if (startRaysBL) startRaysBL.style.animation = 'startRaysCornerReverse 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.2s';
      if (startRaysBR) startRaysBR.style.animation = 'startRaysCornerReverse 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.3s';
      if (startParticles) startParticles.style.animation = 'startParticles 1.8s ease-out';
      if (startParticlesMirror) startParticlesMirror.style.animation = 'startParticles 1.8s ease-out 0.15s';
    }, 10);

    // Aggressive screen shake for maximum impact!
    canvas.style.animation = 'screenShake 0.3s ease-out';
    setTimeout(() => {
      canvas.style.animation = '';
    }, 300);

    // Hide overlay after animation completes (1.8s + 0.3s fadeout)
    setTimeout(() => {
      gameStartOverlay.style.transition = 'opacity 0.3s ease-out';
      gameStartOverlay.style.opacity = '0';
      setTimeout(() => {
        gameStartOverlay.style.display = 'none';
        gameStartOverlay.style.transition = '';
      }, 300);
    }, 1800);
    // Clear pools
    for (const it of bullets.items) it.alive = false;
    for (const it of enemies.items) it.alive = false;
    for (const it of particles.items) it.alive = false;
    for (const it of pickups.items) it.alive = false;
    for (const it of mines.items) it.alive = false;
    for (const it of bloodStains.items) it.alive = false;
    for (const it of enemyBullets.items) it.alive = false;
    
    // Start first wave
    game.waveActive = true;
    
    // Reset wave announcement state properly
    if (waveAnnouncement) {
      waveAnnouncement.style.animation = '';
      waveAnnouncement.style.display = 'none';
      waveAnnouncement.style.opacity = '';
      waveAnnouncement.dataset.active = 'false';
      // Clear any existing timeouts to prevent flash
      waveAnnouncementTimeouts.forEach(timeout => clearTimeout(timeout));
      waveAnnouncementTimeouts = [];
    }
    
    // Reset wave transition state
    waveTransitionInProgress = false;
    if (nextWaveTimeoutId) {
      clearTimeout(nextWaveTimeoutId);
      nextWaveTimeoutId = null;
    }
    
    // Spawn first wave enemies within 2-4 seconds
    const spawnDuration = 2000 + Math.random() * 2000; // 2-4 seconds
    const spawnInterval = spawnDuration / game.waveEnemiesTarget;
    
    for (let i = 0; i < game.waveEnemiesTarget; i++) {
      setTimeout(() => {
        if (game.waveActive) {
          spawnEnemy(game);
          game.waveEnemiesSpawned++;
        }
      }, i * spawnInterval);
    }
  }

  startBtn.addEventListener('click', () => {
    initAudio();

    // Check orientation before starting on mobile
    if (isMobile && window.innerHeight > window.innerWidth) {
      if (orientationWarning) {
        orientationWarning.classList.add('show');
      }
      return; // Don't start if in portrait
    }

    if (game && game.state === STATE.PAUSE) {
      // Resume from pause
      togglePause();
    } else {
      // Start new game - this will trigger the starting loadout popup
      start();
      // Show starting loadout dialog after a brief delay (let game start animation play)
      setTimeout(() => {
        showStartingLoadoutDialog();
      }, 800); // After game start overlay begins
    }
  });
  restartBtn.addEventListener('click', () => {
    start();
    // Show starting loadout dialog after a brief delay
    setTimeout(() => {
      showStartingLoadoutDialog();
    }, 800);
  });
  
  // Options button listener
  optionsBtn.addEventListener('click', () => {
    showOptionsMenu();
  });

  // Start in menu
  game = newGame();

  // Improve crispness on some displays
  ctx.imageSmoothingEnabled = false;

  // Visibility pause
  document.addEventListener('visibilitychange', () => {
    if (document.hidden && game && game.state === STATE.RUN){
      togglePause();
    }
  });
  </script>
</body>
</html>
